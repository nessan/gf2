<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitSpan&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitSpan.html','','classgf2_1_1BitSpan-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitSpan&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A <em>bit_span</em> is a non-owning view of contiguous bits in a bit-store. <br  />
.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitSpan_8h_source.html">BitSpan.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a6c4a5e998a79a565733aec2b7ca5c774" id="r_a6c4a5e998a79a565733aec2b7ca5c774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4a5e998a79a565733aec2b7ca5c774">BitSpan</a> (Word *data, <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> <a class="el" href="#ac703c2a0163f4f5f99d5796706fe0215">offset</a>, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a394bdf415ce323567537b31779244da7">size</a>)</td></tr>
<tr class="memdesc:a6c4a5e998a79a565733aec2b7ca5c774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a non-owning view over bits stored in contiguous words &mdash; a bit-span.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Required BitStore Concept Methods:</div></td></tr>
<tr class="memitem:a394bdf415ce323567537b31779244da7" id="r_a394bdf415ce323567537b31779244da7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394bdf415ce323567537b31779244da7">size</a> () const</td></tr>
<tr class="memdesc:a394bdf415ce323567537b31779244da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits in the bit-span.  <br /></td></tr>
<tr class="memitem:ace3504c9101c1696e92c9188dfb601b4" id="r_ace3504c9101c1696e92c9188dfb601b4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace3504c9101c1696e92c9188dfb601b4">words</a> () const</td></tr>
<tr class="memdesc:ace3504c9101c1696e92c9188dfb601b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>minimum</em> number of words needed to hold the bits in the bit-span.  <br /></td></tr>
<tr class="memitem:a5fb42074c8d31f1197962bf968861cbe" id="r_a5fb42074c8d31f1197962bf968861cbe"><td class="memItemLeft" align="right" valign="top">constexpr word_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb42074c8d31f1197962bf968861cbe">word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a5fb42074c8d31f1197962bf968861cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "word"'s worth of bits from the bit-span.  <br /></td></tr>
<tr class="memitem:a9eea3be4a464e84bd015c5ff7c89a814" id="r_a9eea3be4a464e84bd015c5ff7c89a814"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eea3be4a464e84bd015c5ff7c89a814">set_word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, word_type value)</td></tr>
<tr class="memdesc:a9eea3be4a464e84bd015c5ff7c89a814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a "word"'s worth of bits in the bit-span.  <br /></td></tr>
<tr class="memitem:a82991653375eb8b86036b1aee9df0335" id="r_a82991653375eb8b86036b1aee9df0335"><td class="memItemLeft" align="right" valign="top"><a id="a82991653375eb8b86036b1aee9df0335" name="a82991653375eb8b86036b1aee9df0335"></a>
constexpr const Word *&#160;</td><td class="memItemRight" valign="bottom"><b>store</b> () const</td></tr>
<tr class="memdesc:a82991653375eb8b86036b1aee9df0335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the first bit-span word in some underlying span of words (const version). <br /></td></tr>
<tr class="memitem:a96380cd43590de3df86186f9c7c45d46" id="r_a96380cd43590de3df86186f9c7c45d46"><td class="memItemLeft" align="right" valign="top"><a id="a96380cd43590de3df86186f9c7c45d46" name="a96380cd43590de3df86186f9c7c45d46"></a>
constexpr Word *&#160;</td><td class="memItemRight" valign="bottom"><b>store</b> ()</td></tr>
<tr class="memdesc:a96380cd43590de3df86186f9c7c45d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the first bit-span word in some underlying span of words (non-const version). <br /></td></tr>
<tr class="memitem:ac703c2a0163f4f5f99d5796706fe0215" id="r_ac703c2a0163f4f5f99d5796706fe0215"><td class="memItemLeft" align="right" valign="top"><a id="ac703c2a0163f4f5f99d5796706fe0215" name="ac703c2a0163f4f5f99d5796706fe0215"></a>
constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b> () const</td></tr>
<tr class="memdesc:ac703c2a0163f4f5f99d5796706fe0215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bits) of the first bit in the bit-span within the first bit-span word. <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Accessors:</div></td></tr>
<tr class="memitem:ae3fbdca67b049aa5bef82749ea4fe235" id="r_ae3fbdca67b049aa5bef82749ea4fe235"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3fbdca67b049aa5bef82749ea4fe235">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:ae3fbdca67b049aa5bef82749ea4fe235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a52e7a98ecc073c73f2229b6c471792a7" id="r_a52e7a98ecc073c73f2229b6c471792a7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e7a98ecc073c73f2229b6c471792a7">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a52e7a98ecc073c73f2229b6c471792a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value of the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a34e94da15e0f3e36fe52e06973226f98" id="r_a34e94da15e0f3e36fe52e06973226f98"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e94da15e0f3e36fe52e06973226f98">front</a> () const</td></tr>
<tr class="memdesc:a34e94da15e0f3e36fe52e06973226f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:adf7aee770c68ff00c5661e603eaf92d4" id="r_adf7aee770c68ff00c5661e603eaf92d4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf7aee770c68ff00c5661e603eaf92d4">back</a> () const</td></tr>
<tr class="memdesc:adf7aee770c68ff00c5661e603eaf92d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Mutators:</div></td></tr>
<tr class="memitem:a3b2047e801d179d9e243ab338f0c6773" id="r_a3b2047e801d179d9e243ab338f0c6773"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b2047e801d179d9e243ab338f0c6773">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, bool value=true)</td></tr>
<tr class="memdesc:a3b2047e801d179d9e243ab338f0c6773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:ad8584cdaf5dc5d174cb57ee2af870bf2" id="r_ad8584cdaf5dc5d174cb57ee2af870bf2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8584cdaf5dc5d174cb57ee2af870bf2">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:ad8584cdaf5dc5d174cb57ee2af870bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "reference" to the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a476bf6e5ea68d524e2fca165b83ba8bc" id="r_a476bf6e5ea68d524e2fca165b83ba8bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a476bf6e5ea68d524e2fca165b83ba8bc">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a476bf6e5ea68d524e2fca165b83ba8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining.  <br /></td></tr>
<tr class="memitem:a5b96d192e6044535677defc3f8b085e1" id="r_a5b96d192e6044535677defc3f8b085e1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b96d192e6044535677defc3f8b085e1">swap</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i0, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i1)</td></tr>
<tr class="memdesc:a5b96d192e6044535677defc3f8b085e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bits in the bit-span at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Span Queries:</div></td></tr>
<tr class="memitem:a9b4d90a83d5f00f72d1bb5b4931afc07" id="r_a9b4d90a83d5f00f72d1bb5b4931afc07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b4d90a83d5f00f72d1bb5b4931afc07">is_empty</a> () const</td></tr>
<tr class="memdesc:a9b4d90a83d5f00f72d1bb5b4931afc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit-span is empty, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a3f4d5eb0f8ba3946b7f05997b1fd68d8" id="r_a3f4d5eb0f8ba3946b7f05997b1fd68d8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f4d5eb0f8ba3946b7f05997b1fd68d8">any</a> () const</td></tr>
<tr class="memdesc:a3f4d5eb0f8ba3946b7f05997b1fd68d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if at least one bit in the bit-span is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a7e851f65c3c245dacda0a74553955188" id="r_a7e851f65c3c245dacda0a74553955188"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e851f65c3c245dacda0a74553955188">all</a> () const</td></tr>
<tr class="memdesc:a7e851f65c3c245dacda0a74553955188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all bits in the bit-span are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ae7585b2c017b08faf41f0750b615aa2f" id="r_ae7585b2c017b08faf41f0750b615aa2f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7585b2c017b08faf41f0750b615aa2f">none</a> () const</td></tr>
<tr class="memdesc:ae7585b2c017b08faf41f0750b615aa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no bits in the bit-span are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">BitSpan Mutators:</div></td></tr>
<tr class="memitem:a0ca9d22615ea6325767b4280d846ecce" id="r_a0ca9d22615ea6325767b4280d846ecce"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ca9d22615ea6325767b4280d846ecce">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:a0ca9d22615ea6325767b4280d846ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the bit-span to the boolean <span class="tt">value</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:ac8e60c305a7e007fa362a2f3925a2d63" id="r_ac8e60c305a7e007fa362a2f3925a2d63"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e60c305a7e007fa362a2f3925a2d63">flip_all</a> ()</td></tr>
<tr class="memdesc:ac8e60c305a7e007fa362a2f3925a2d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bits in the bit-span and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Copying into the BitSpan:</div></td></tr>
<tr class="memitem:ae29df65f10c228aa9b8db2f02c594e9a" id="r_ae29df65f10c228aa9b8db2f02c594e9a"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:ae29df65f10c228aa9b8db2f02c594e9a template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae29df65f10c228aa9b8db2f02c594e9a">copy</a> (Src src)</td></tr>
<tr class="memdesc:ae29df65f10c228aa9b8db2f02c594e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-span and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a113a63f7038841536c1bfe409bd0c91b" id="r_a113a63f7038841536c1bfe409bd0c91b"><td class="memTemplParams" colspan="2">template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</td></tr>
<tr class="memitem:a113a63f7038841536c1bfe409bd0c91b template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113a63f7038841536c1bfe409bd0c91b">copy</a> (Iter src_begin, Iter src_end)</td></tr>
<tr class="memdesc:a113a63f7038841536c1bfe409bd0c91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to this <em>equal-sized</em> bit-span.  <br /></td></tr>
<tr class="memitem:a5a469b4c376d7204f7c22235e8674233" id="r_a5a469b4c376d7204f7c22235e8674233"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:a5a469b4c376d7204f7c22235e8674233 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a469b4c376d7204f7c22235e8674233">copy</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:a5a469b4c376d7204f7c22235e8674233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from an equal-sized <span class="tt">src</span> bit-store and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a0c79f0cab59d53053971e9f84ca0a5a3" id="r_a0c79f0cab59d53053971e9f84ca0a5a3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:a0c79f0cab59d53053971e9f84ca0a5a3 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c79f0cab59d53053971e9f84ca0a5a3">copy</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a0c79f0cab59d53053971e9f84ca0a5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from an equal-sized <span class="tt">std::bitset</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Fills:</div></td></tr>
<tr class="memitem:ae04bc0e7a9c0227b0993675e871cd085" id="r_ae04bc0e7a9c0227b0993675e871cd085"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae04bc0e7a9c0227b0993675e871cd085">copy</a> (std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:ae04bc0e7a9c0227b0993675e871cd085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the bit-span by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:af413badf300407b7135af3ee9ee32c76" id="r_af413badf300407b7135af3ee9ee32c76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af413badf300407b7135af3ee9ee32c76">fill_random</a> (double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:af413badf300407b7135af3ee9ee32c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the bit-span with random bits and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts:</div></td></tr>
<tr class="memitem:af6565a89efdf0ed61935915868041506" id="r_af6565a89efdf0ed61935915868041506"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6565a89efdf0ed61935915868041506">count_ones</a> () const</td></tr>
<tr class="memdesc:af6565a89efdf0ed61935915868041506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in the bit-span.  <br /></td></tr>
<tr class="memitem:ab41c18bc9e9fb37a2436a3ef3063dbc5" id="r_ab41c18bc9e9fb37a2436a3ef3063dbc5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab41c18bc9e9fb37a2436a3ef3063dbc5">count_zeros</a> () const</td></tr>
<tr class="memdesc:ab41c18bc9e9fb37a2436a3ef3063dbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in the bit-span.  <br /></td></tr>
<tr class="memitem:a059036b3f45a74c977db87e131ec06ee" id="r_a059036b3f45a74c977db87e131ec06ee"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a059036b3f45a74c977db87e131ec06ee">leading_zeros</a> () const</td></tr>
<tr class="memdesc:a059036b3f45a74c977db87e131ec06ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in the bit-span.  <br /></td></tr>
<tr class="memitem:a7aef10820711679c5d9bcc8ec7507b64" id="r_a7aef10820711679c5d9bcc8ec7507b64"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aef10820711679c5d9bcc8ec7507b64">trailing_zeros</a> () const</td></tr>
<tr class="memdesc:a7aef10820711679c5d9bcc8ec7507b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in the bit-span.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Set-bit Indices:</div></td></tr>
<tr class="memitem:a0fdef5132eb0b3c7740b044819f64b93" id="r_a0fdef5132eb0b3c7740b044819f64b93"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fdef5132eb0b3c7740b044819f64b93">first_set</a> () const</td></tr>
<tr class="memdesc:a0fdef5132eb0b3c7740b044819f64b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in the bit-span or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:acddfd80b128f10f3fff457ab25aeb259" id="r_acddfd80b128f10f3fff457ab25aeb259"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acddfd80b128f10f3fff457ab25aeb259">last_set</a> () const</td></tr>
<tr class="memdesc:acddfd80b128f10f3fff457ab25aeb259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last set bit in the bit-span or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:a3aea63deddac89a9f375e9888b7f0d05" id="r_a3aea63deddac89a9f375e9888b7f0d05"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aea63deddac89a9f375e9888b7f0d05">next_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a3aea63deddac89a9f375e9888b7f0d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next set bit after <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more set bits exist.  <br /></td></tr>
<tr class="memitem:aada8bd4b9e0ebb906850af368800e27c" id="r_aada8bd4b9e0ebb906850af368800e27c"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada8bd4b9e0ebb906850af368800e27c">previous_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:aada8bd4b9e0ebb906850af368800e27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous set bit before <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Unset-bit Indices:</div></td></tr>
<tr class="memitem:a9da6a99b6ebcfe256ea7f42be2a28fa2" id="r_a9da6a99b6ebcfe256ea7f42be2a28fa2"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da6a99b6ebcfe256ea7f42be2a28fa2">first_unset</a> () const</td></tr>
<tr class="memdesc:a9da6a99b6ebcfe256ea7f42be2a28fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first unset bit in the bit-span or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:ab0fd1eeeb86c93c01b299ef6ea37c28b" id="r_ab0fd1eeeb86c93c01b299ef6ea37c28b"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0fd1eeeb86c93c01b299ef6ea37c28b">last_unset</a> () const</td></tr>
<tr class="memdesc:ab0fd1eeeb86c93c01b299ef6ea37c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last unset bit in the bit-span or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:a6fdfccbb5f1edf0c95258da7d21e6c4d" id="r_a6fdfccbb5f1edf0c95258da7d21e6c4d"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fdfccbb5f1edf0c95258da7d21e6c4d">next_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a6fdfccbb5f1edf0c95258da7d21e6c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next unset bit after <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr class="memitem:ad388e08f60848e03910e2c0a4a779d2f" id="r_ad388e08f60848e03910e2c0a4a779d2f"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad388e08f60848e03910e2c0a4a779d2f">previous_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:ad388e08f60848e03910e2c0a4a779d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Iterators:</div></td></tr>
<tr class="memitem:a8362316bef3380d4ff685dd7e21f27ba" id="r_a8362316bef3380d4ff685dd7e21f27ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8362316bef3380d4ff685dd7e21f27ba">bits</a> () const</td></tr>
<tr class="memdesc:a8362316bef3380d4ff685dd7e21f27ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-span.  <br /></td></tr>
<tr class="memitem:a5879dd98bba06102949ff3d1d9da59a2" id="r_a5879dd98bba06102949ff3d1d9da59a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5879dd98bba06102949ff3d1d9da59a2">bits</a> ()</td></tr>
<tr class="memdesc:a5879dd98bba06102949ff3d1d9da59a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const iterator over the values of the bits in the mutable bit-span.  <br /></td></tr>
<tr class="memitem:aac52c3efe00a377beb8ab1007944e0b1" id="r_aac52c3efe00a377beb8ab1007944e0b1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac52c3efe00a377beb8ab1007944e0b1">set_bits</a> () const</td></tr>
<tr class="memdesc:aac52c3efe00a377beb8ab1007944e0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-span.  <br /></td></tr>
<tr class="memitem:a1de37852da1f30fba3fe368b50b05a96" id="r_a1de37852da1f30fba3fe368b50b05a96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de37852da1f30fba3fe368b50b05a96">unset_bits</a> () const</td></tr>
<tr class="memdesc:a1de37852da1f30fba3fe368b50b05a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-span.  <br /></td></tr>
<tr class="memitem:aa9dc6987e7cd000ddae27d53b5734078" id="r_aa9dc6987e7cd000ddae27d53b5734078"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9dc6987e7cd000ddae27d53b5734078">store_words</a> () const</td></tr>
<tr class="memdesc:aa9dc6987e7cd000ddae27d53b5734078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over all the <em>words</em> underlying the bit-span.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Exports:</div></td></tr>
<tr class="memitem:ad07d3093b1f91f1613f9344f45690eab" id="r_ad07d3093b1f91f1613f9344f45690eab"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07d3093b1f91f1613f9344f45690eab">to_words</a> (std::output_iterator&lt; word_type &gt; auto out)</td></tr>
<tr class="memdesc:ad07d3093b1f91f1613f9344f45690eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-span and puts them into the passed output iterator.  <br /></td></tr>
<tr class="memitem:af936e824e11da1392f9ad55e5f2fe742" id="r_af936e824e11da1392f9ad55e5f2fe742"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af936e824e11da1392f9ad55e5f2fe742">to_words</a> () const</td></tr>
<tr class="memdesc:af936e824e11da1392f9ad55e5f2fe742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-span as a <span class="tt">std::vector&lt;word_type&gt;</span>.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Spans:</div></td></tr>
<tr class="memitem:aa08ebd188936122fa769a87869d342b5" id="r_aa08ebd188936122fa769a87869d342b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa08ebd188936122fa769a87869d342b5">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:aa08ebd188936122fa769a87869d342b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an immutable sub-span encompassing the bit-span's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr class="memitem:a7a55c65e3f89e15e365fb64f6e973c43" id="r_a7a55c65e3f89e15e365fb64f6e973c43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a55c65e3f89e15e365fb64f6e973c43">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:a7a55c65e3f89e15e365fb64f6e973c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an mutable sub-span encompassing the bit-span's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-vectors:</div></td></tr>
<tr class="memitem:a06b220f8ea7fbfd8633e7b3d34fea232" id="r_a06b220f8ea7fbfd8633e7b3d34fea232"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b220f8ea7fbfd8633e7b3d34fea232">sub</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a06b220f8ea7fbfd8633e7b3d34fea232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <em>clone</em> of the span elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Splits:</div></td></tr>
<tr class="memitem:ae116b38d6233851868423b5351684880" id="r_ae116b38d6233851868423b5351684880"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae116b38d6233851868423b5351684880">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;left, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;right) const</td></tr>
<tr class="memdesc:ae116b38d6233851868423b5351684880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-span as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">size()</a>)</span> respectively.  <br /></td></tr>
<tr class="memitem:a564210492d2ca4ee46841bfb0c111b70" id="r_a564210492d2ca4ee46841bfb0c111b70"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564210492d2ca4ee46841bfb0c111b70">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at) const</td></tr>
<tr class="memdesc:a564210492d2ca4ee46841bfb0c111b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-span as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">size()</a>)</span> respectively.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Riffling:</div></td></tr>
<tr class="memitem:aeb83fa6b8e6e2adfafd090fed6d69184" id="r_aeb83fa6b8e6e2adfafd090fed6d69184"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb83fa6b8e6e2adfafd090fed6d69184">riffled</a> (<a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;dst) const</td></tr>
<tr class="memdesc:aeb83fa6b8e6e2adfafd090fed6d69184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the bits of this bit-span with zeros storing the result into the bit-vector <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:af2acc05992f0c81467ff45246b7065ef" id="r_af2acc05992f0c81467ff45246b7065ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2acc05992f0c81467ff45246b7065ef">riffled</a> () const</td></tr>
<tr class="memdesc:af2acc05992f0c81467ff45246b7065ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the result of riffling the bits in this bit-span with zeros.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations:</div></td></tr>
<tr class="memitem:a8944b9e4308a59b2f2a8a9d4b725a57e" id="r_a8944b9e4308a59b2f2a8a9d4b725a57e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8944b9e4308a59b2f2a8a9d4b725a57e">to_binary_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:a8944b9e4308a59b2f2a8a9d4b725a57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-span.  <br /></td></tr>
<tr class="memitem:a8f5e28cc16718e22973c9fec0ddfe077" id="r_a8f5e28cc16718e22973c9fec0ddfe077"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:a8f5e28cc16718e22973c9fec0ddfe077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-span.  <br /></td></tr>
<tr class="memitem:aaba2ace208f196f67c90700eb41c9621" id="r_aaba2ace208f196f67c90700eb41c9621"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaba2ace208f196f67c90700eb41c9621">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:aaba2ace208f196f67c90700eb41c9621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "pretty" string representation of the bit-span.  <br /></td></tr>
<tr class="memitem:aa1b295282604bd942c5831fb835d4af3" id="r_aa1b295282604bd942c5831fb835d4af3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b295282604bd942c5831fb835d4af3">to_hex_string</a> () const</td></tr>
<tr class="memdesc:aa1b295282604bd942c5831fb835d4af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "hex" string representation of the bits in the bit-span.  <br /></td></tr>
<tr class="memitem:a13bcadd21771898d4c4eb383fa1c4432" id="r_a13bcadd21771898d4c4eb383fa1c4432"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13bcadd21771898d4c4eb383fa1c4432">describe</a> () const</td></tr>
<tr class="memdesc:a13bcadd21771898d4c4eb383fa1c4432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multi-line string describing the bit-span in some detail.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a43bd1a46665cff81a8906d687cc7cb4e" id="r_a43bd1a46665cff81a8906d687cc7cb4e"><td class="memItemLeft" align="right" valign="top"><a id="a43bd1a46665cff81a8906d687cc7cb4e" name="a43bd1a46665cff81a8906d687cc7cb4e"></a>
static constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bits_per_word</b> = <a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Word&gt;</td></tr>
<tr class="memdesc:a43bd1a46665cff81a8906d687cc7cb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant &ndash; the number of bits in a <span class="tt">Word</span>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word = usize&gt;<br />
class gf2::BitSpan&lt; Word &gt;</div><p>A <em>bit_span</em> is a non-owning view of contiguous bits in a bit-store. <br  />
. </p>
<p>Bit-spans created from const bit-stores will have a type like <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;const <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a>&gt;</span>, while bit-spans from non-const bit-stores will have a type like <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;<a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a>&gt;</span>. The existence or absence of that <span class="tt">const</span> qualifier in the template paramater is important as it allows us to maintain const-correctness for the underlying container. The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;const <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a>&gt;</span> type is read-only, the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;<a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a>&gt;</span> type is read-write.</p>
<p>What matters is the <em>interior</em> const-ness of the span. In fact, you can generally pass a bit-span by value and not worry about passing a reference/const reference &ndash; the type is small enough to pass on the stack. This is similar in spirit to the <span class="tt">std::span&lt;T&gt;</span> template class.</p>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a></span> class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> concept so is itself a bit-span. This means you can take spans of spans, pass them to methods that accept bit-stores, and so forth. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6c4a5e998a79a565733aec2b7ca5c774" name="a6c4a5e998a79a565733aec2b7ca5c774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4a5e998a79a565733aec2b7ca5c774">&#9670;&#160;</a></span>BitSpan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::BitSpan </td>
          <td>(</td>
          <td class="paramtype">Word *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a non-owning view over bits stored in contiguous words &mdash; a bit-span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the first word that holds the span's bits. </td></tr>
    <tr><td class="paramname">offset</td><td>The bit-offset within <span class="tt">data[0]</span> where the span begins. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bits in the span.</td></tr>
  </table>
  </dd>
</dl>
<p>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a></span> is <em>non-owning</em> view into a contiguous span of <span class="tt"><a class="el" href="#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">size</a></span> bits which are assumed to be stored in contiguous words starting at the <span class="tt"><a class="el" href="#ac703c2a0163f4f5f99d5796706fe0215" title="Returns the offset (in bits) of the first bit in the bit-span within the first bit-span word.">offset</a></span> bit of the word <span class="tt">data[0]</span>.</p>
<p>Generally bit-spans are constructed using the <span class="tt"><a class="el" href="#aa08ebd188936122fa769a87869d342b5" title="Returns an immutable sub-span encompassing the bit-span&#39;s bits in the half-open range [begin,...">span</a></span> method of any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> compatible object.</p>
<h1 class="doxsection"><a class="anchor" id="note-13"></a>
Note</h1>
<p>It is the responsibility of the caller to ensure that the underlying store of unsigneds continues to exist for as long as the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="example-259"></a>
Example</h1>
<div class="fragment"><div class="line">std::vector&lt;u8&gt; <a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>{0b1010&#39;1010, 0b1100&#39;1100};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitSpan.html">BitSpan</a> s{<a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>.data(), 0, 16};</div>
<div class="line">assert_eq(s.<a class="code hl_function" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a>(), <span class="stringliteral">&quot;0101010100110011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitSpan_html"><div class="ttname"><a href="classgf2_1_1BitSpan.html">gf2::BitSpan</a></div><div class="ttdoc">A bit_span is a non-owning view of contiguous bits in a bit-store.  .</div><div class="ttdef"><b>Definition</b> BitSpan.h:30</div></div>
<div class="ttc" id="aclassgf2_1_1BitSpan_html_a8f5e28cc16718e22973c9fec0ddfe077"><div class="ttname"><a href="#a8f5e28cc16718e22973c9fec0ddfe077">gf2::BitSpan::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-span.</div><div class="ttdef"><b>Definition</b> BitSpan.h:1083</div></div>
<div class="ttc" id="aclassgf2_1_1BitSpan_html_ace3504c9101c1696e92c9188dfb601b4"><div class="ttname"><a href="#ace3504c9101c1696e92c9188dfb601b4">gf2::BitSpan::words</a></div><div class="ttdeci">constexpr usize words() const</div><div class="ttdoc">Returns the minimum number of words needed to hold the bits in the bit-span.</div><div class="ttdef"><b>Definition</b> BitSpan.h:116</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a7e851f65c3c245dacda0a74553955188" name="a7e851f65c3c245dacda0a74553955188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e851f65c3c245dacda0a74553955188">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all bits in the bit-span are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-spans have no set bits (logical connective for <span class="tt"><a class="el" href="#a7e851f65c3c245dacda0a74553955188" title="Returns true if all bits in the bit-span are set, false otherwise.">all</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-274"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,3);</div>
<div class="line">assert_eq(v.all(), <span class="keyword">false</span>);</div>
<div class="line">v.set(0);</div>
<div class="line">v.set(1);</div>
<div class="line">assert_eq(v.all(), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(u.all(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a66ff1e24db7bf631af2d638dd0b620c1"><div class="ttname"><a href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">gf2::BitVector::zeros</a></div><div class="ttdeci">static constexpr BitVector zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVector.h:196</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3f4d5eb0f8ba3946b7f05997b1fd68d8" name="a3f4d5eb0f8ba3946b7f05997b1fd68d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4d5eb0f8ba3946b7f05997b1fd68d8">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if at least one bit in the bit-span is set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-spans have no set bits (logical connective for <span class="tt"><a class="el" href="#a3f4d5eb0f8ba3946b7f05997b1fd68d8" title="Returns true if at least one bit in the bit-span is set, false otherwise.">any</a></span> is <span class="tt">OR</span> with identity <span class="tt">false</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-273"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,3);</div>
<div class="line">assert_eq(v.any(), <span class="keyword">false</span>);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.any(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf7aee770c68ff00c5661e603eaf92d4" name="adf7aee770c68ff00c5661e603eaf92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7aee770c68ff00c5661e603eaf92d4">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-79"></a>
Panics</h1>
<p>In debug mode the method panics of the bit-span is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-267"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(0,3);</div>
<div class="line">assert_eq(v.back(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_abcfb7a88f30c8faa177519571a76ba8d"><div class="ttname"><a href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">gf2::BitVector::ones</a></div><div class="ttdeci">static constexpr BitVector ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVector.h:204</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5879dd98bba06102949ff3d1d9da59a2" name="a5879dd98bba06102949ff3d1d9da59a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5879dd98bba06102949ff3d1d9da59a2">&#9670;&#160;</a></span>bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const iterator over the values of the bits in the mutable bit-span. </p>
<p>You can use this iterator to iterate over the bits in the bit-span to get <em>or</em> set the value of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="note-19"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-297"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = u.span(4,12);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : s.bits()) bit = <span class="keyword">false</span>;</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;00000000&quot;</span>)</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a>(), <span class="stringliteral">&quot;11110000000011&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8362316bef3380d4ff685dd7e21f27ba" name="a8362316bef3380d4ff685dd7e21f27ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8362316bef3380d4ff685dd7e21f27ba">&#9670;&#160;</a></span>bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-span. </p>
<p>You can use this iterator to iterate over the bits in the bit-span and get the values of each bit as a <span class="tt">bool</span>.</p>
<h1 class="doxsection"><a class="anchor" id="note-18"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-296"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = u.span(4,12);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : s.bits()) assert_eq(bit, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a113a63f7038841536c1bfe409bd0c91b" name="a113a63f7038841536c1bfe409bd0c91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113a63f7038841536c1bfe409bd0c91b">&#9670;&#160;</a></span>copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to this <em>equal-sized</em> bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="note-15"></a>
Note</h1>
<p>We allow <em>any</em> unsigned integral source, e.g. copying <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> words into a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of the correct size.</p>
<h1 class="doxsection"><a class="anchor" id="panics-85"></a>
Panics</h1>
<p>Panics if the size of this bit-span does not match the number of bits in the source iteration.</p>
<h1 class="doxsection"><a class="anchor" id="example-279"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitArray.html">BitArray&lt;52, u8&gt;</a> v;</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitArray.html#a5696c182958a4495cda1c3c1a10cbfd8">span</a>(2,50);</div>
<div class="line">std::vector&lt;u16&gt; src = { 0b1010101010101010, 0b1010101010101010, 0b1111111111111111 };</div>
<div class="line">s.copy(src.begin(), src.end());</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="classgf2_1_1BitArray.html#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0001010101010101010101010101010101111111111111111100&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html"><div class="ttname"><a href="classgf2_1_1BitArray.html">gf2::BitArray</a></div><div class="ttdoc">A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...</div><div class="ttdef"><b>Definition</b> BitArray.h:24</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a5696c182958a4495cda1c3c1a10cbfd8"><div class="ttname"><a href="classgf2_1_1BitArray.html#a5696c182958a4495cda1c3c1a10cbfd8">gf2::BitArray::span</a></div><div class="ttdeci">constexpr auto span(usize begin, usize end) const</div><div class="ttdoc">Returns an immutable bit-span encompassing the bit-array&#39;s bits in the half-open range [begin,...</div><div class="ttdef"><b>Definition</b> BitArray.h:1021</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a7e7ba662c7a451fb55b1f64d29d013d1"><div class="ttname"><a href="classgf2_1_1BitArray.html#a7e7ba662c7a451fb55b1f64d29d013d1">gf2::BitArray::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1190</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5a469b4c376d7204f7c22235e8674233" name="a5a469b4c376d7204f7c22235e8674233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a469b4c376d7204f7c22235e8674233">&#9670;&#160;</a></span>copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from an equal-sized <span class="tt">src</span> bit-store and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-16"></a>
Note</h1>
<p>This is one of the few methods in the library that <em>doesn't</em> require the two stores to have the same <span class="tt">word_type</span>. You can use it to convert between different <span class="tt">word_type</span> stores (e.g., from <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;<a class="el" href="namespacegf2.html#ad1e43953e374bea8222087e4aba6c74a" title="Word type alias for a 32-bit unsigned integer.">u32</a>&gt;</span> to <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>) as long as the sizes match.</p>
<h1 class="doxsection"><a class="anchor" id="panics-86"></a>
Panics</h1>
<p>Panics if the size of the bit-span does not match the number of bits in the source store.</p>
<h1 class="doxsection"><a class="anchor" id="example-280"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(16);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(0,10);</div>
<div class="line">s.copy(<a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10));</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aeed3a5c646dbc7c38b4298574734ae4a"><div class="ttname"><a href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">gf2::BitVector::alternating</a></div><div class="ttdeci">static constexpr BitVector alternating(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n looking like 101010....</div><div class="ttdef"><b>Definition</b> BitVector.h:239</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae29df65f10c228aa9b8db2f02c594e9a" name="ae29df65f10c228aa9b8db2f02c594e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29df65f10c228aa9b8db2f02c594e9a">&#9670;&#160;</a></span>copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-span and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-14"></a>
Note</h1>
<ol type="1">
<li>We allow <em>any</em> unsigned integral source, e.g. copying a single <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of size 64.</li>
<li>The least-significant bit of the source becomes the bit at index 0 in the bit-span.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="panics-84"></a>
Panics</h1>
<p>Panics if the size of the bit-span does not match the number of bits in the source integer type.</p>
<h1 class="doxsection"><a class="anchor" id="example-278"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> v{26};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(3, 19);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">s.copy(src);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;00001010101010101010000000&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u32&gt;</a> w{26};</div>
<div class="line"><span class="keyword">auto</span> t = w.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(3, 19);</div>
<div class="line">t.copy(src);</div>
<div class="line">assert_eq(t.to_string(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;00001010101010101010000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html"><div class="ttname"><a href="classgf2_1_1BitVector.html">gf2::BitVector</a></div><div class="ttdoc">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...</div><div class="ttdef"><b>Definition</b> BitVector.h:23</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a0afbe86b05c12a2a7a7d69ac519035ea"><div class="ttname"><a href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">gf2::BitVector::span</a></div><div class="ttdeci">constexpr auto span(usize begin, usize end) const</div><div class="ttdoc">Returns an immutable bit-span encompassing the bit-vector&#39;s bits in the half-open range [begin,...</div><div class="ttdef"><b>Definition</b> BitVector.h:1598</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad2b8ef3dc6d1ea250253135172bb48e7"><div class="ttname"><a href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">gf2::BitVector::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1763</div></div>
<div class="ttc" id="anamespacegf2_html_ae858164ae3b877b1f9ea2606fae215a0"><div class="ttname"><a href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">gf2::u16</a></div><div class="ttdeci">std::uint16_t u16</div><div class="ttdoc">Word type alias for a 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0c79f0cab59d53053971e9f84ca0a5a3" name="a0c79f0cab59d53053971e9f84ca0a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c79f0cab59d53053971e9f84ca0a5a3">&#9670;&#160;</a></span>copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from an equal-sized <span class="tt">std::bitset</span> and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-17"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> which is the reverse of our convention.</p>
<h1 class="doxsection"><a class="anchor" id="panics-87"></a>
Panics</h1>
<p>Panics if the size of the bit-span does not match the number of bits in the source bitset.</p>
<h1 class="doxsection"><a class="anchor" id="example-281"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(16);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(0,10);</div>
<div class="line">s.copy(src);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0101010101111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae04bc0e7a9c0227b0993675e871cd085" name="ae04bc0e7a9c0227b0993675e871cd085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04bc0e7a9c0227b0993675e871cd085">&#9670;&#160;</a></span>copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the bit-span by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-282"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(16);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(0,10);</div>
<div class="line">s.copy([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010111111&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6565a89efdf0ed61935915868041506" name="af6565a89efdf0ed61935915868041506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6565a89efdf0ed61935915868041506">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in the bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="example-284"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,10);</div>
<div class="line">assert_eq(s.count_ones(), 0);</div>
<div class="line">v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">set</a>(2);</div>
<div class="line">assert_eq(s.count_ones(), 1);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a73c5c0d160af7ae95e495e1288f73440"><div class="ttname"><a href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">gf2::BitVector::set</a></div><div class="ttdeci">constexpr auto set(usize i, bool value=true)</div><div class="ttdoc">Sets the bit-element i to the specified boolean value &amp; returns this for chaining....</div><div class="ttdef"><b>Definition</b> BitVector.h:984</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab41c18bc9e9fb37a2436a3ef3063dbc5" name="ab41c18bc9e9fb37a2436a3ef3063dbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41c18bc9e9fb37a2436a3ef3063dbc5">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in the bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="example-285"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,10);</div>
<div class="line">assert_eq(s.count_zeros(), 8);</div>
<div class="line">v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">set</a>(2);</div>
<div class="line">assert_eq(s.count_zeros(), 7);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a13bcadd21771898d4c4eb383fa1c4432" name="a13bcadd21771898d4c4eb383fa1c4432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bcadd21771898d4c4eb383fa1c4432">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::describe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a multi-line string describing the bit-span in some detail. </p>
<p>This method is useful for debugging but you should not rely on the output format which may change. </p>

</div>
</div>
<a id="af413badf300407b7135af3ee9ee32c76" name="af413badf300407b7135af3ee9ee32c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af413badf300407b7135af3ee9ee32c76">&#9670;&#160;</a></span>fill_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::fill_random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the bit-span with random bits and returns a reference to this for chaining. </p>
<p>The default call <span class="tt"><a class="el" href="#af413badf300407b7135af3ee9ee32c76" title="Fill the bit-span with random bits and returns a reference to this for chaining.">fill_random()</a></span> sets each bit to 1 with probability 0.5 (fair coin).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the fill is all zeros, if <span class="tt">p &gt; 1</span> then the fill is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-283"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> u{10}, v{10};</div>
<div class="line"><span class="keyword">auto</span> s = u.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,10);</div>
<div class="line"><span class="keyword">auto</span> t = v.span(2,10);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line">s.fill_random(0.5, seed);</div>
<div class="line">t.fill_random(0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="anamespacegf2_html_a770302128133591da0ca93ded6abf8aa"><div class="ttname"><a href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">gf2::u64</a></div><div class="ttdeci">std::uint64_t u64</div><div class="ttdoc">Word type alias for a 64-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0fdef5132eb0b3c7740b044819f64b93" name="a0fdef5132eb0b3c7740b044819f64b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdef5132eb0b3c7740b044819f64b93">&#9670;&#160;</a></span>first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::first_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first set bit in the bit-span or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-288"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(s.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(4);</div>
<div class="line">assert(s.first_set() == std::optional&lt;usize&gt;{0});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9da6a99b6ebcfe256ea7f42be2a28fa2" name="a9da6a99b6ebcfe256ea7f42be2a28fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da6a99b6ebcfe256ea7f42be2a28fa2">&#9670;&#160;</a></span>first_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::first_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first unset bit in the bit-span or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-292"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(s.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(4, <span class="keyword">false</span>);</div>
<div class="line">assert(s.first_unset() == std::optional&lt;usize&gt;{0});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a476bf6e5ea68d524e2fca165b83ba8bc" name="a476bf6e5ea68d524e2fca165b83ba8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476bf6e5ea68d524e2fca165b83ba8bc">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-82"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-270"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,5);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">v.flip(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0111&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;1011111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac8e60c305a7e007fa362a2f3925a2d63" name="ac8e60c305a7e007fa362a2f3925a2d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e60c305a7e007fa362a2f3925a2d63">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bits in the bit-span and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-277"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(5,10);</div>
<div class="line">v.flip_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;11111&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0000011111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a34e94da15e0f3e36fe52e06973226f98" name="a34e94da15e0f3e36fe52e06973226f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e94da15e0f3e36fe52e06973226f98">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-78"></a>
Panics</h1>
<p>In debug mode the method panics of the bit-span is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-266"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(0,3);</div>
<div class="line">assert_eq(v.front(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae3fbdca67b049aa5bef82749ea4fe235" name="ae3fbdca67b049aa5bef82749ea4fe235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fbdca67b049aa5bef82749ea4fe235">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-76"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-264"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> u{10};</div>
<div class="line"><span class="keyword">auto</span> v = u.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(0,2);</div>
<div class="line">assert_eq(v.get(0), <span class="keyword">false</span>);</div>
<div class="line">u.<a class="code hl_function" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.get(0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9b4d90a83d5f00f72d1bb5b4931afc07" name="a9b4d90a83d5f00f72d1bb5b4931afc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4d90a83d5f00f72d1bb5b4931afc07">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit-span is empty, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="example-272"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,1);</div>
<div class="line">assert_eq(v.is_empty(), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> w = u.span(0,1);</div>
<div class="line">assert_eq(w.is_empty(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acddfd80b128f10f3fff457ab25aeb259" name="acddfd80b128f10f3fff457ab25aeb259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddfd80b128f10f3fff457ab25aeb259">&#9670;&#160;</a></span>last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::last_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last set bit in the bit-span or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-289"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.last_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(s.last_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(11);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;00000001&quot;</span>);</div>
<div class="line">assert(s.last_set() == std::optional&lt;usize&gt;{7});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab0fd1eeeb86c93c01b299ef6ea37c28b" name="ab0fd1eeeb86c93c01b299ef6ea37c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fd1eeeb86c93c01b299ef6ea37c28b">&#9670;&#160;</a></span>last_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::last_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last unset bit in the bit-span or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-293"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(4, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;01111111&quot;</span>);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{0});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a059036b3f45a74c977db87e131ec06ee" name="a059036b3f45a74c977db87e131ec06ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059036b3f45a74c977db87e131ec06ee">&#9670;&#160;</a></span>leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::leading_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in the bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="example-286"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{37};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,10);</div>
<div class="line">assert_eq(s.leading_zeros(), 8);</div>
<div class="line">v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">set</a>(11);</div>
<div class="line">assert_eq(s.leading_zeros(), 8);</div>
<div class="line">v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440">set</a>(2);</div>
<div class="line">assert_eq(s.leading_zeros(), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3aea63deddac89a9f375e9888b7f0d05" name="a3aea63deddac89a9f375e9888b7f0d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aea63deddac89a9f375e9888b7f0d05">&#9670;&#160;</a></span>next_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::next_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next set bit after <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more set bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-290"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.next_set(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(5);</div>
<div class="line">v.set(6);</div>
<div class="line">assert(s.next_set(0) == std::optional&lt;usize&gt;{1});</div>
<div class="line">assert(s.next_set(1) == std::optional&lt;usize&gt;{2});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6fdfccbb5f1edf0c95258da7d21e6c4d" name="a6fdfccbb5f1edf0c95258da7d21e6c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdfccbb5f1edf0c95258da7d21e6c4d">&#9670;&#160;</a></span>next_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::next_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next unset bit after <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-294"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(11, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;11111110&quot;</span>);</div>
<div class="line">assert(s.last_unset() == std::optional&lt;usize&gt;{7});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae7585b2c017b08faf41f0750b615aa2f" name="ae7585b2c017b08faf41f0750b615aa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7585b2c017b08faf41f0750b615aa2f">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no bits in the bit-span are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-spans have no set bits (logical connective for <span class="tt"><a class="el" href="#ae7585b2c017b08faf41f0750b615aa2f" title="Returns true if no bits in the bit-span are set, false otherwise.">none</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-275"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,3);</div>
<div class="line">assert_eq(v.none(), <span class="keyword">true</span>);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.none(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad8584cdaf5dc5d174cb57ee2af870bf2" name="ad8584cdaf5dc5d174cb57ee2af870bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8584cdaf5dc5d174cb57ee2af870bf2">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "reference" to the bit element <span class="tt">i</span>. </p>
<p>The returned object is a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference for the bit element at <span class="tt">index</span> rather than a true reference.</p>
<p><b>Note:</b> The referenced bit-span must continue to exist while the <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="panics-81"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-269"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(0,5);</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;00100&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">v[3] = w[3];</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;00110&quot;</span>);</div>
<div class="line">v[4] |= w[4];</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;00111&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0011100000&quot;</span>)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a52e7a98ecc073c73f2229b6c471792a7" name="a52e7a98ecc073c73f2229b6c471792a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e7a98ecc073c73f2229b6c471792a7">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boolean value of the bit element <span class="tt">i</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-77"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-265"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> u{10};</div>
<div class="line"><span class="keyword">auto</span> v = u.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(1, 4);</div>
<div class="line">assert_eq(v[0], <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aada8bd4b9e0ebb906850af368800e27c" name="aada8bd4b9e0ebb906850af368800e27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada8bd4b9e0ebb906850af368800e27c">&#9670;&#160;</a></span>previous_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::previous_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous set bit before <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-291"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.previous_set(s.size()) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(5);</div>
<div class="line">v.set(6);</div>
<div class="line">assert(s.previous_set(s.size()) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(s.previous_set(2) == std::optional&lt;usize&gt;{1});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad388e08f60848e03910e2c0a4a779d2f" name="ad388e08f60848e03910e2c0a4a779d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad388e08f60848e03910e2c0a4a779d2f">&#9670;&#160;</a></span>previous_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::previous_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-span or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-295"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert(s.previous_unset(s.size()) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(5, <span class="keyword">false</span>);</div>
<div class="line">v.set(6, <span class="keyword">false</span>);</div>
<div class="line">assert(s.previous_unset(s.size()) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(s.previous_unset(2) == std::optional&lt;usize&gt;{1});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af2acc05992f0c81467ff45246b7065ef" name="af2acc05992f0c81467ff45246b7065ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2acc05992f0c81467ff45246b7065ef">&#9670;&#160;</a></span>riffled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the result of riffling the bits in this bit-span with zeros. </p>
<p>If bit-span has the bits <span class="tt">abcde</span> then the output bit-vector will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-309"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line"><span class="keyword">auto</span> dst = v.span(4,14).riffled();</div>
<div class="line">assert_eq(dst.to_string(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeb83fa6b8e6e2adfafd090fed6d69184" name="aeb83fa6b8e6e2adfafd090fed6d69184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb83fa6b8e6e2adfafd090fed6d69184">&#9670;&#160;</a></span>riffled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the bits of this bit-span with zeros storing the result into the bit-vector <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> will have the bits of this bit-span interleaved with zeros. For example, if this bit-span has the bits <span class="tt">abcde</span> then <span class="tt">dst</span> will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-308"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> dst;</div>
<div class="line">v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(4,14).riffled(dst);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3b2047e801d179d9e243ab338f0c6773" name="a3b2047e801d179d9e243ab338f0c6773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2047e801d179d9e243ab338f0c6773">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-80"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-268"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(0,3);</div>
<div class="line">assert_eq(v.get(0), <span class="keyword">false</span>);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.get(0), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(u.get(0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0ca9d22615ea6325767b4280d846ecce" name="a0ca9d22615ea6325767b4280d846ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca9d22615ea6325767b4280d846ecce">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits in the bit-span to the boolean <span class="tt">value</span> and returns a reference to this for chaining. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-276"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(5,10);</div>
<div class="line">v.set_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;11111&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0000011111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aac52c3efe00a377beb8ab1007944e0b1" name="aac52c3efe00a377beb8ab1007944e0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac52c3efe00a377beb8ab1007944e0b1">&#9670;&#160;</a></span>set_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::set_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-span. </p>
<p>You can use this iterator to iterate over the set bits in the bit-span and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-298"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(19);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(s.set_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{0, 2, 4, 6}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9eea3be4a464e84bd015c5ff7c89a814" name="a9eea3be4a464e84bd015c5ff7c89a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eea3be4a464e84bd015c5ff7c89a814">&#9670;&#160;</a></span>set_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::set_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a "word"'s worth of bits in the bit-span. </p>
<p>These spans are views into a contiguous range of bits from some underlying array of unsigned words. Generally a bit-span is not aligned with the word boundaries of that array. However, the bit-span can synthesise words <em>as if</em> it copied the bits and shifted them down so that element 0 is at bit-position zero in synthetic word number 0. This function sets those words by altering bits in pairs of adjacent words in the underlying array.</p>
<h1 class="doxsection"><a class="anchor" id="example-263"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;u8&gt;::from_string</a>(<span class="stringliteral">&quot;0000_0000_1111_1111&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4, 12);     <span class="comment">// The span covers words 0 and 1 in the span underlying v.</span></div>
<div class="line">assert_eq(s.words(), 1);    <span class="comment">// However, it can be fitted into a single synthetic word!</span></div>
<div class="line">assert_eq(s.word(0), 0b1111&#39;0000);</div>
<div class="line">s.set_word(0, 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000111111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a17ba4f50de43f5e84ef3943ad77410ea"><div class="ttname"><a href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">gf2::BitVector::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:411</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a394bdf415ce323567537b31779244da7" name="a394bdf415ce323567537b31779244da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394bdf415ce323567537b31779244da7">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits in the bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="example-260"></a>
Example</h1>
<div class="fragment"><div class="line">std::vector&lt;u8&gt; <a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>{0b1010&#39;1010, 0b1100&#39;1100};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitSpan.html">BitSpan</a> s{<a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>.data(), 0, 16};</div>
<div class="line">assert_eq(s.<a class="code hl_function" href="#a394bdf415ce323567537b31779244da7">size</a>(), 16);</div>
<div class="ttc" id="aclassgf2_1_1BitSpan_html_a394bdf415ce323567537b31779244da7"><div class="ttname"><a href="#a394bdf415ce323567537b31779244da7">gf2::BitSpan::size</a></div><div class="ttdeci">constexpr usize size() const</div><div class="ttdoc">Returns the number of bits in the bit-span.</div><div class="ttdef"><b>Definition</b> BitSpan.h:100</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a55c65e3f89e15e365fb64f6e973c43" name="a7a55c65e3f89e15e365fb64f6e973c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a55c65e3f89e15e365fb64f6e973c43">&#9670;&#160;</a></span>span() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an mutable sub-span encompassing the bit-span's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Mutability here is deep &ndash; the interior pointer in the returned sub-span is to <em>non-const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-89"></a>
Panics</h1>
<p>This method panics if the sub-span range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-304"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s0 = v.span(4,12);</div>
<div class="line">assert_eq(s0.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> s1 = s0.span(4,8);</div>
<div class="line">assert_eq(s1.to_string(), <span class="stringliteral">&quot;1010&quot;</span>)</div>
<div class="line">s1.<a class="code hl_function" href="#a0ca9d22615ea6325767b4280d846ecce">set_all</a>();</div>
<div class="line">assert_eq(s1.<a class="code hl_function" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a>(), <span class="stringliteral">&quot;1111&quot;</span>)</div>
<div class="line">assert_eq(s0.<a class="code hl_function" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a>(), <span class="stringliteral">&quot;10101111&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a8f5e28cc16718e22973c9fec0ddfe077">to_string</a>(), <span class="stringliteral">&quot;10101010111110&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitSpan_html_a0ca9d22615ea6325767b4280d846ecce"><div class="ttname"><a href="#a0ca9d22615ea6325767b4280d846ecce">gf2::BitSpan::set_all</a></div><div class="ttdeci">auto set_all(bool value=true)</div><div class="ttdoc">Sets the bits in the bit-span to the boolean value and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitSpan.h:422</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa08ebd188936122fa769a87869d342b5" name="aa08ebd188936122fa769a87869d342b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ebd188936122fa769a87869d342b5">&#9670;&#160;</a></span>span() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an immutable sub-span encompassing the bit-span's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Span mutability is deep &ndash; the interior pointer in the returned sub-span is to <em>const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-88"></a>
Panics</h1>
<p>This method panics if the sub-span range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-303"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s0 = v.span(4,12);</div>
<div class="line">assert_eq(s0.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> s1 = s0.span(4,8);</div>
<div class="line">assert_eq(s1.to_string(), <span class="stringliteral">&quot;1010&quot;</span>)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a564210492d2ca4ee46841bfb0c111b70" name="a564210492d2ca4ee46841bfb0c111b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564210492d2ca4ee46841bfb0c111b70">&#9670;&#160;</a></span>split_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-span as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are returned as a pair of bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>].</p>
<p>On return, <span class="tt">left</span> is a clone of the bits from the start of the bit-span up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-span. This bit-span itself is not modified.</p>
<h1 class="doxsection"><a class="anchor" id="panics-92"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-span.</p>
<h1 class="doxsection"><a class="anchor" id="example-307"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = u.span(4,12);</div>
<div class="line"><span class="keyword">auto</span> [left, right] = s.split_at(5);</div>
<div class="line">assert_eq(left.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.to_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae116b38d6233851868423b5351684880" name="ae116b38d6233851868423b5351684880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae116b38d6233851868423b5351684880">&#9670;&#160;</a></span>split_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-span as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>.</p>
<p>On return, <span class="tt">left</span> contains the bits from the start of the bit-span up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-span. This bit-span itself is not modified.</p>
<p>This lets one reuse the <span class="tt">left</span> and <span class="tt">right</span> destinations without having to allocate new bit-vectors. This is useful when implementing iterative algorithms that need to split a bit-span into two parts repeatedly.</p>
<h1 class="doxsection"><a class="anchor" id="panics-91"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-span.</p>
<h1 class="doxsection"><a class="anchor" id="example-306"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = u.span(4,12);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> left, right;</div>
<div class="line">s.<a class="code hl_function" href="classgf2_1_1BitVector.html#a6e2078e3f40d295f483d87a09d26a92f">split_at</a>(5, left, right);</div>
<div class="line">assert_eq(left.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a6e2078e3f40d295f483d87a09d26a92f"><div class="ttname"><a href="classgf2_1_1BitVector.html#a6e2078e3f40d295f483d87a09d26a92f">gf2::BitVector::split_at</a></div><div class="ttdeci">constexpr void split_at(usize at, BitVector&lt; word_type &gt; &amp;left, BitVector&lt; word_type &gt; &amp;right) const</div><div class="ttdoc">Views the bit-vector as two parts containing the elements [0, at) and [at, size()) respectively.</div><div class="ttdef"><b>Definition</b> BitVector.h:1664</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9dc6987e7cd000ddae27d53b5734078" name="aa9dc6987e7cd000ddae27d53b5734078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dc6987e7cd000ddae27d53b5734078">&#9670;&#160;</a></span>store_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::store_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over all the <em>words</em> underlying the bit-span. </p>
<p>You can use this iterator to iterate over the words in the bit-span and read the <span class="tt">Word</span> value of each word. You <b>cannot</b> use this iterator to modify the words in the span.</p>
<h1 class="doxsection"><a class="anchor" id="note-20"></a>
Note</h1>
<p>The words here are likely a synthetic construct. The expectation is that the bit <span class="tt">0</span> in the span is located at the bit-location <span class="tt">0</span> of <span class="tt">word(0)</span>. That is always the case for bit-vectors but bit-slices typically synthesise "words" on the fly from adjacent pairs of bit-vector words. Nevertheless, almost all the methods in <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> are implemented efficiently by operating on those words.</p>
<h1 class="doxsection"><a class="anchor" id="example-300"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(100);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,14);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a> = std::ranges::to&lt;std::vector&gt;(s.store_words());</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a06b220f8ea7fbfd8633e7b3d34fea232" name="a06b220f8ea7fbfd8633e7b3d34fea232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b220f8ea7fbfd8633e7b3d34fea232">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <em>clone</em> of the span elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-90"></a>
Panics</h1>
<p>This method panics if the sub-span range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-305"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = u.span(4,12);</div>
<div class="line"><span class="keyword">auto</span> v = s.sub(0,4);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;11111111&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101111111110&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b96d192e6044535677defc3f8b085e1" name="a5b96d192e6044535677defc3f8b085e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b96d192e6044535677defc3f8b085e1">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bits in the bit-span at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-83"></a>
Panics</h1>
<p>In debug mode the indices are bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-271"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v = u.span(1,5);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0100000000&quot;</span>);</div>
<div class="line">v.swap(0, 1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0100&quot;</span>);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8944b9e4308a59b2f2a8a9d4b725a57e" name="a8944b9e4308a59b2f2a8a9d4b725a57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8944b9e4308a59b2f2a8a9d4b725a57e">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-span. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-310"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{14};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,12);</div>
<div class="line">assert_eq(s.to_binary_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">s.set(0);</div>
<div class="line">assert_eq(s.to_binary_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[0,0,1,0,0,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a7cc78c5e7773c30d8da8916af258d081"><div class="ttname"><a href="classgf2_1_1BitVector.html#a7cc78c5e7773c30d8da8916af258d081">gf2::BitVector::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1742</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa1b295282604bd942c5831fb835d4af3" name="aa1b295282604bd942c5831fb835d4af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b295282604bd942c5831fb835d4af3">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "hex" string representation of the bits in the bit-span. </p>
<p>The output is a string of hex characters without any spaces, commas, or other formatting.</p>
<p>The string may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
 Empty bit-vectors are represented as the empty string.</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<p>The output is in <em>vector-order</em>. If "h0" is the first hex digit in the output string, you can print it as four binary digits <span class="tt">v_0v_1v_2v_3</span>. For example, if h0 = "A" which is <span class="tt">1010</span> in binary, then v = 1010.</p>
<h1 class="doxsection"><a class="anchor" id="example-313"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line">assert_eq(v.span(4,4).to_hex_string(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">assert_eq(v.span(4,8).to_hex_string(), <span class="stringliteral">&quot;F&quot;</span>);</div>
<div class="line">assert_eq(v.span(4,9).to_hex_string(), <span class="stringliteral">&quot;F1.2&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaba2ace208f196f67c90700eb41c9621" name="aaba2ace208f196f67c90700eb41c9621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba2ace208f196f67c90700eb41c9621">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "pretty" string representation of the bit-span. </p>
<p>The output is a string of 0's and 1's with spaces between each bit, and the whole thing enclosed in square brackets.</p>
<h1 class="doxsection"><a class="anchor" id="example-312"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(14);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(2,12);</div>
<div class="line">assert_eq(s.to_pretty_string(), <span class="stringliteral">&quot;[1,0,1,0,1,0,1,0,1,0]&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> empty = v.span(3,3);</div>
<div class="line">assert_eq(empty.to_pretty_string(), <span class="stringliteral">&quot;[]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f5e28cc16718e22973c9fec0ddfe077" name="a8f5e28cc16718e22973c9fec0ddfe077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5e28cc16718e22973c9fec0ddfe077">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-span. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-311"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{14};</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea">span</a>(2,12);</div>
<div class="line">assert_eq(s.to_binary_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">s.set(0);</div>
<div class="line">assert_eq(s.to_binary_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[0,0,1,0,0,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af936e824e11da1392f9ad55e5f2fe742" name="af936e824e11da1392f9ad55e5f2fe742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af936e824e11da1392f9ad55e5f2fe742">&#9670;&#160;</a></span>to_words() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-span as a <span class="tt">std::vector&lt;word_type&gt;</span>. </p>
<p><b>Note:</b> The last word in the vector may not be fully occupied but unused slots will be all zeros.</p>
<h1 class="doxsection"><a class="anchor" id="example-302"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(100);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,14);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a> = s.to_words();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ace3504c9101c1696e92c9188dfb601b4">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad07d3093b1f91f1613f9344f45690eab" name="ad07d3093b1f91f1613f9344f45690eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07d3093b1f91f1613f9344f45690eab">&#9670;&#160;</a></span>to_words() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramtype">std::output_iterator&lt; word_type &gt; auto</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-span and puts them into the passed output iterator. </p>
<h1 class="doxsection"><a class="anchor" id="note-21"></a>
Note</h1>
<ol type="1">
<li>The last word in the bit-span may not be fully occupied but unused slots will be all zeros.</li>
<li>The output iterator must be able to accept values of the bit-span's <span class="tt">word_type</span>.</li>
<li>The output iterator must have enough space to accept all the words in the bit-span.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="example-301"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(100);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,14);</div>
<div class="line">std::vector&lt;u8&gt; out8(s.words());</div>
<div class="line">s.to_words(out8.begin());</div>
<div class="line">assert_eq(out8, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="line">std::vector&lt;u16&gt; out16(s.words());</div>
<div class="line">s.to_words(out16.begin());</div>
<div class="line">assert_eq(out16, (std::vector&lt;u16&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7aef10820711679c5d9bcc8ec7507b64" name="a7aef10820711679c5d9bcc8ec7507b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aef10820711679c5d9bcc8ec7507b64">&#9670;&#160;</a></span>trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::trailing_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in the bit-span. </p>
<h1 class="doxsection"><a class="anchor" id="example-287"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(27);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(2,10);</div>
<div class="line">assert_eq(s.trailing_zeros(), 8);</div>
<div class="line">v.set(11);</div>
<div class="line">assert_eq(s.trailing_zeros(), 8);</div>
<div class="line">v.set(2);</div>
<div class="line">assert_eq(s.trailing_zeros(), 7);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1de37852da1f30fba3fe368b50b05a96" name="a1de37852da1f30fba3fe368b50b05a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de37852da1f30fba3fe368b50b05a96">&#9670;&#160;</a></span>unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::unset_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-span. </p>
<p>You can use this iterator to iterate over the unset bits in the bit-span and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-299"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(19);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4,12);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(s.unset_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{1, 3, 5, 7}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5fb42074c8d31f1197962bf968861cbe" name="a5fb42074c8d31f1197962bf968861cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb42074c8d31f1197962bf968861cbe">&#9670;&#160;</a></span>word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word_type <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "word"'s worth of bits from the bit-span. </p>
<p>These spans are views into a contiguous range of bits from some underlying array of unsigned words. Generally a bit-span is not aligned with the word boundaries of that array. However, the bit-span can synthesise words <em>as if</em> it copied the bits and shifted them down so that element 0 is at bit-position zero in synthetic word number 0. This function returns those words by combining bits from pairs of adjacent words in the true underlying array.</p>
<h1 class="doxsection"><a class="anchor" id="example-262"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;u8&gt;::from_string</a>(<span class="stringliteral">&quot;0000&#39;0000&#39;1111&#39;1111&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4, 12);     <span class="comment">// The span covers words 0 and 1 in the span underlying v.</span></div>
<div class="line">assert_eq(s.words(), 1);    <span class="comment">// However, it can be fitted into a single synthetic word!</span></div>
<div class="line">assert_eq(s.word(0), 0b1111&#39;0000);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ace3504c9101c1696e92c9188dfb601b4" name="ace3504c9101c1696e92c9188dfb601b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3504c9101c1696e92c9188dfb601b4">&#9670;&#160;</a></span>words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitSpan.html">gf2::BitSpan</a>&lt; Word &gt;::words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>minimum</em> number of words needed to hold the bits in the bit-span. </p>
<p>These bit-spans are views into a contiguous range of bits from some underlying array of unsigned words. Generally a bit-span is not aligned with the word boundaries of that array. However, the bit-span can synthesise words <em>as if</em> it copied the bits and shifted them down so that element 0 is at bit-position zero in synthetic word number 0. This function returns the number of such words.</p>
<h1 class="doxsection"><a class="anchor" id="example-261"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(18);</div>
<div class="line">assert_eq(v.words(), 3);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(4, 12);     <span class="comment">// The span covers words 0 and 1 in the span underlying v.</span></div>
<div class="line">assert_eq(s.words(), 1);    <span class="comment">// However, it can be fitted into a single synthetic word!</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitSpan.html">BitSpan</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
