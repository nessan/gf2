// This file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `Unsigned.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-24 15:10:18

#include "../include/gf2/Unsigned.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    // Trace the source for the tests.
    auto header_file = "Unsigned.h";
    std::size_t test_count = 31;
    std::println(stderr, "Running {} tests extracted from: `{}`", test_count, header_file);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for `{}`:", doxy::max_fails, header_file);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    // Run the tests ...
    header_line = 51;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BITS<u16>, 16);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 60;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ZERO<u8>, 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 69;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ONE<u8>, 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 78;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(MAX<u8>, 255);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 87;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ALTERNATING<u8>, 0b0101'0101);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 102;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(with_set_bits<u8>(0, 0), 0b0000'0000);
        assert_eq(with_set_bits<u8>(0, 1), 0b0000'0001);
        assert_eq(with_set_bits<u8>(0, 2), 0b0000'0011);
        assert_eq(with_set_bits<u8>(1, 3), 0b0000'0110);
        assert_eq(with_set_bits<u8>(0, 8), 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 122;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(with_unset_bits<u8>(0, 0), 0b1111'1111);
        assert_eq(with_unset_bits<u8>(0, 1), 0b1111'1110);
        assert_eq(with_unset_bits<u8>(0, 2), 0b1111'1100);
        assert_eq(with_unset_bits<u8>(1, 3), 0b1111'1001);
        assert_eq(with_unset_bits<u8>(0, 8), 0b0000'0000);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 147;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b0000'0000;
        set_bits(word, 1, 3);
        assert_eq(word, 0b0000'0110);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 165;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        reset_bits(word, 1, 3);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 187;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b0000'0000;
        set_except_bits(word, 1, 3);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 209;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        reset_except_bits(word, 1, 3);
        assert_eq(word, 0b000'0110);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 231;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u32  n32 = 0x12345678;
        auto m32 = reverse_bits(n32);
        assert_eq(m32, 0x1e6a2c48);
        u64  n64 = 0x1234567890123456;
        auto m64 = reverse_bits(n64);
        assert_eq(m64, 0x6a2c48091e6a2c48);
        u16 zero = 0;
        assert_eq(reverse_bits(zero), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 258;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        replace_bits(word, 1, 3, 0b0000'0000);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 287;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        auto [lo, hi] = riffle(word);
        assert_eq(lo, 0b0101'0101);
        assert_eq(hi, 0b0101'0101);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 320;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(count_ones(u8{0b0000'0000}), 0);
        assert_eq(count_ones(u8{0b0000'0001}), 1);
        assert_eq(count_ones(u8{0b0000'0010}), 1);
        assert_eq(count_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 335;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(count_zeros(u8{0b0000'0000}), 8);
        assert_eq(count_zeros(u8{0b0000'0001}), 7);
        assert_eq(count_zeros(u8{0b0000'0010}), 7);
        assert_eq(count_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 350;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(trailing_zeros(u8{0b0000'0000}), 8);
        assert_eq(trailing_zeros(u8{0b0000'0001}), 0);
        assert_eq(trailing_zeros(u8{0b0000'0010}), 1);
        assert_eq(trailing_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 365;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(leading_zeros(u8{0b0000'0000}), 8);
        assert_eq(leading_zeros(u8{0b0000'0001}), 7);
        assert_eq(leading_zeros(u8{0b0000'0010}), 6);
        assert_eq(leading_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 380;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(trailing_ones(u8{0b0000'0000}), 0);
        assert_eq(trailing_ones(u8{0b0000'0001}), 1);
        assert_eq(trailing_ones(u8{0b0000'0010}), 0);
        assert_eq(trailing_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 395;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(leading_ones(u8{0b0000'0000}), 0);
        assert_eq(leading_ones(u8{0b0000'0001}), 0);
        assert_eq(leading_ones(u8{0b1000'0010}), 1);
        assert_eq(leading_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 410;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(lowest_set_bit(u8{0b0000'0000}) == std::optional<u8>{});
        assert(lowest_set_bit(u8{0b0000'0001}) == std::optional<u8>{0});
        assert(lowest_set_bit(u8{0b0000'0010}) == std::optional<u8>{1});
        assert(lowest_set_bit(u8{0b1000'0000}) == std::optional<u8>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 430;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(highest_set_bit(u8{0b0000'0000}) == std::optional<u8>{});
        assert(highest_set_bit(u8{0b0000'0001}) == std::optional<u8>{0});
        assert(highest_set_bit(u8{0b0000'0010}) == std::optional<u8>{1});
        assert(highest_set_bit(u8{0b1000'0000}) == std::optional<u8>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 446;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(lowest_unset_bit(u8{0b1111'1111}) == std::optional<u8>{});
        assert(lowest_unset_bit(u8{0b0001'1000}) == std::optional<u8>{0});
        assert(lowest_unset_bit(u8{0b0000'1001}) == std::optional<u8>{1});
        assert(lowest_unset_bit(u8{0b1000'1111}) == std::optional<u8>{4});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 462;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(highest_unset_bit(u8{0b1111'1111}) == std::optional<u8>{});
        assert(highest_unset_bit(u8{0b1100'0000}) == std::optional<u8>{5});
        assert(highest_unset_bit(u8{0b0001'0011}) == std::optional<u8>{7});
        assert(highest_unset_bit(u8{0b1000'0000}) == std::optional<u8>{6});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 482;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(to_binary_string(u8{0b0000'0011}), "00000011");
        assert_eq(to_binary_string(u8{0b1111'1111}), "11111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 497;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(to_hex_string(u8{0b0000'0011}), "03");
        assert_eq(to_hex_string(u8{0b1111'1111}), "FF");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 516;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(words_needed<u8>(0), 0);
        assert_eq(words_needed<u8>(8), 1);
        assert_eq(words_needed<u8>(19), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 533;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(word_index<u8>(0), 0);
        assert_eq(word_index<u8>(8), 1);
        assert_eq(word_index<u8>(19), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 549;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(bit_offset<u8>(0), 0);
        assert_eq(bit_offset<u8>(8), 0);
        assert_eq(bit_offset<u8>(19), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 566;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(index_and_offset<u8>(0), (std::pair{0, 0}));
        assert_eq(index_and_offset<u8>(8), (std::pair{1, 0}));
        assert_eq(index_and_offset<u8>(19), (std::pair{2, 3}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 583;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(index_and_mask<u8>(0), (std::pair{0, 1}));
        assert_eq(index_and_mask<u8>(8), (std::pair{1, 1}));
        assert_eq(index_and_mask<u8>(19), (std::pair{2, 1 << 3}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    // Print a summary of the tests results.
    if (fails == 0) {
        std::println(stderr, "[{}] All {} tests PASSED", header_file, test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Test FAIL summary for `{}`: Ran {} of a possible {} tests, PASSED: {}, FAILED: {}", header_file, test, test_count, test - fails, fails);
        std::print(stderr, "--------------------------------------------------------------------------------------");
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}