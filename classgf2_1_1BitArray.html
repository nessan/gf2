<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitArray&lt; N, Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitArray.html','','classgf2_1_1BitArray-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitArray&lt; N, Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A fixed-size "vector" over GF(2) with <span class="tt">N</span> bit elements compactly stored in a standard array of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. The elements in a bit-array are initially all set to 0.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitArray_8h_source.html">BitArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a82a5c674165737fe7c72832867734ea6" id="r_a82a5c674165737fe7c72832867734ea6"><td class="memItemLeft" align="right" valign="top"><a id="a82a5c674165737fe7c72832867734ea6" name="a82a5c674165737fe7c72832867734ea6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_type</b> = Word</td></tr>
<tr class="memdesc:a82a5c674165737fe7c72832867734ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying unsigned word type used to store the bits. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Required BitStore Concept Methods.</div></td></tr>
<tr class="memitem:a7ad104649695be7a116b76eab3978b10" id="r_a7ad104649695be7a116b76eab3978b10"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ad104649695be7a116b76eab3978b10">size</a> () const</td></tr>
<tr class="memdesc:a7ad104649695be7a116b76eab3978b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bit-elements in the bit-array.  <br /></td></tr>
<tr class="memitem:afd6f73573f642499f95fe90639dc949f" id="r_afd6f73573f642499f95fe90639dc949f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6f73573f642499f95fe90639dc949f">words</a> () const</td></tr>
<tr class="memdesc:afd6f73573f642499f95fe90639dc949f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words in the bit-array's underlying word store.  <br /></td></tr>
<tr class="memitem:a1f2ba699dc21d37cdcd955b3baa54a98" id="r_a1f2ba699dc21d37cdcd955b3baa54a98"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98">word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a1f2ba699dc21d37cdcd955b3baa54a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns word <span class="tt">i</span> from the bit-array's underlying word store.  <br /></td></tr>
<tr class="memitem:ae9764d1b0853ec06b086499a3ab9d823" id="r_ae9764d1b0853ec06b086499a3ab9d823"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9764d1b0853ec06b086499a3ab9d823">set_word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, Word <a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98">word</a>)</td></tr>
<tr class="memdesc:ae9764d1b0853ec06b086499a3ab9d823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets word <span class="tt">i</span> in the bit-array's underlying word store to <span class="tt">value</span> (masked if necessary).  <br /></td></tr>
<tr class="memitem:aa4052a792e8bc521a5a0a99bd696f804" id="r_aa4052a792e8bc521a5a0a99bd696f804"><td class="memItemLeft" align="right" valign="top">constexpr const Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4052a792e8bc521a5a0a99bd696f804">store</a> () const</td></tr>
<tr class="memdesc:aa4052a792e8bc521a5a0a99bd696f804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the underlying store of words .  <br /></td></tr>
<tr class="memitem:ac2fe777c10a479db548f03e7dab14b0f" id="r_ac2fe777c10a479db548f03e7dab14b0f"><td class="memItemLeft" align="right" valign="top">constexpr Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2fe777c10a479db548f03e7dab14b0f">store</a> ()</td></tr>
<tr class="memdesc:ac2fe777c10a479db548f03e7dab14b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying store of words.  <br /></td></tr>
<tr class="memitem:a7c933a9a3a7083e9d529d27fbd7c2622" id="r_a7c933a9a3a7083e9d529d27fbd7c2622"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c933a9a3a7083e9d529d27fbd7c2622">offset</a> () const</td></tr>
<tr class="memdesc:a7c933a9a3a7083e9d529d27fbd7c2622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bits) of the first bit in the bit-array within the first word.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors:</div></td></tr>
<tr class="memitem:ae52f2a1cd4ba693f95405eaa007b42fc" id="r_ae52f2a1cd4ba693f95405eaa007b42fc"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> ()</td></tr>
<tr class="memdesc:ae52f2a1cd4ba693f95405eaa007b42fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-array of length <span class="tt">N</span> with all the bit elements set to 0.  <br /></td></tr>
<tr class="memitem:a569ff1ae6099c874abcb496104fa6ce8" id="r_a569ff1ae6099c874abcb496104fa6ce8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a569ff1ae6099c874abcb496104fa6ce8">BitArray</a> (Word <a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98">word</a>)</td></tr>
<tr class="memdesc:a569ff1ae6099c874abcb496104fa6ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-array with <span class="tt">N</span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98" title="Returns word i from the bit-array&#39;s underlying word store.">word</a></span>.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Accessors for Individual Bits:</div></td></tr>
<tr class="memitem:aaa00b06652d4701559e37f9a510048a4" id="r_aaa00b06652d4701559e37f9a510048a4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa00b06652d4701559e37f9a510048a4">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:aaa00b06652d4701559e37f9a510048a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a21b4970c7bc711da4888caaeb71fbbab" id="r_a21b4970c7bc711da4888caaeb71fbbab"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21b4970c7bc711da4888caaeb71fbbab">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a21b4970c7bc711da4888caaeb71fbbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value of the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a399a6f87005a45a028c582d71201ee16" id="r_a399a6f87005a45a028c582d71201ee16"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a399a6f87005a45a028c582d71201ee16">front</a> () const</td></tr>
<tr class="memdesc:a399a6f87005a45a028c582d71201ee16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a017bf4fa4deddd2a4f660aec879b2450" id="r_a017bf4fa4deddd2a4f660aec879b2450"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a017bf4fa4deddd2a4f660aec879b2450">back</a> () const</td></tr>
<tr class="memdesc:a017bf4fa4deddd2a4f660aec879b2450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Mutators:</div></td></tr>
<tr class="memitem:a07520d5580bf502c10a4b5e53aa7d667" id="r_a07520d5580bf502c10a4b5e53aa7d667"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, bool value=true)</td></tr>
<tr class="memdesc:a07520d5580bf502c10a4b5e53aa7d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:a203a3d6a790f50d83edcb9ed6b41ca9c" id="r_a203a3d6a790f50d83edcb9ed6b41ca9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a203a3d6a790f50d83edcb9ed6b41ca9c">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a203a3d6a790f50d83edcb9ed6b41ca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "reference" to the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a1cc837e63f24b06f9d6d756435451542" id="r_a1cc837e63f24b06f9d6d756435451542"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc837e63f24b06f9d6d756435451542">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a1cc837e63f24b06f9d6d756435451542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining.  <br /></td></tr>
<tr class="memitem:a88a6d06d4385f76d7b2de8c65cbe95e7" id="r_a88a6d06d4385f76d7b2de8c65cbe95e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a6d06d4385f76d7b2de8c65cbe95e7">swap</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i0, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i1)</td></tr>
<tr class="memdesc:a88a6d06d4385f76d7b2de8c65cbe95e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bits in the bit-array at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">BitArray Queries:</div></td></tr>
<tr class="memitem:ad9a3e55e8989e6c85c9ec7ea4d0f7d7b" id="r_ad9a3e55e8989e6c85c9ec7ea4d0f7d7b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a3e55e8989e6c85c9ec7ea4d0f7d7b">is_empty</a> () const</td></tr>
<tr class="memdesc:ad9a3e55e8989e6c85c9ec7ea4d0f7d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit-array is empty, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a765eeb4afcf8135e670176939cf3cc74" id="r_a765eeb4afcf8135e670176939cf3cc74"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a765eeb4afcf8135e670176939cf3cc74">any</a> () const</td></tr>
<tr class="memdesc:a765eeb4afcf8135e670176939cf3cc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if at least one bit in the bit-array is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a495ffc84725d778f6df7e2189f622644" id="r_a495ffc84725d778f6df7e2189f622644"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495ffc84725d778f6df7e2189f622644">all</a> () const</td></tr>
<tr class="memdesc:a495ffc84725d778f6df7e2189f622644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all bits in the bit-array are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a900179c6249e397df28923963bc4e701" id="r_a900179c6249e397df28923963bc4e701"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a900179c6249e397df28923963bc4e701">none</a> () const</td></tr>
<tr class="memdesc:a900179c6249e397df28923963bc4e701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no bits in the bit-array are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">BitArray Whole Array Mutators:</div></td></tr>
<tr class="memitem:aab2791cfd5ff853058cc609a4d3b354c" id="r_aab2791cfd5ff853058cc609a4d3b354c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:aab2791cfd5ff853058cc609a4d3b354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the bits in the bit-array to the boolean <span class="tt">value</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:ac03f099279bd6d712604d8d2468b0a74" id="r_ac03f099279bd6d712604d8d2468b0a74"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac03f099279bd6d712604d8d2468b0a74">flip_all</a> ()</td></tr>
<tr class="memdesc:ac03f099279bd6d712604d8d2468b0a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bits in the bit-array and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Copying into the BitArray:</div></td></tr>
<tr class="memitem:a6bbfb8e5e1b435b698caf37e85f23173" id="r_a6bbfb8e5e1b435b698caf37e85f23173"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:a6bbfb8e5e1b435b698caf37e85f23173 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a> (Src src)</td></tr>
<tr class="memdesc:a6bbfb8e5e1b435b698caf37e85f23173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-array. Returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a9b261afd0bd70025f4d02c79841d80f6" id="r_a9b261afd0bd70025f4d02c79841d80f6"><td class="memTemplParams" colspan="2">template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</td></tr>
<tr class="memitem:a9b261afd0bd70025f4d02c79841d80f6 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b261afd0bd70025f4d02c79841d80f6">copy</a> (Iter src_begin, Iter src_end)</td></tr>
<tr class="memdesc:a9b261afd0bd70025f4d02c79841d80f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to this <em>equal-sized</em> bit-array.  <br /></td></tr>
<tr class="memitem:ab519ea74f5c99f8de2dfe7868f5c2e59" id="r_ab519ea74f5c99f8de2dfe7868f5c2e59"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:ab519ea74f5c99f8de2dfe7868f5c2e59 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab519ea74f5c99f8de2dfe7868f5c2e59">copy</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:ab519ea74f5c99f8de2dfe7868f5c2e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to this <em>equal-sized</em> bit-array and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a04b6537b8fc7e153e63a5fff962a2da5" id="r_a04b6537b8fc7e153e63a5fff962a2da5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b6537b8fc7e153e63a5fff962a2da5">copy</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a04b6537b8fc7e153e63a5fff962a2da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from a <span class="tt">std::bitset</span> to this <em>equal-sized</em> bit-array and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">BitArray Fills:</div></td></tr>
<tr class="memitem:a4964592bbf2abe874c697f3103646993" id="r_a4964592bbf2abe874c697f3103646993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4964592bbf2abe874c697f3103646993">copy</a> (std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a4964592bbf2abe874c697f3103646993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the bit-array by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a62a56d20bc5fbfcd02f60906095ce694" id="r_a62a56d20bc5fbfcd02f60906095ce694"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a56d20bc5fbfcd02f60906095ce694">fill_random</a> (double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:a62a56d20bc5fbfcd02f60906095ce694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the bit-array with random bits and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts:</div></td></tr>
<tr class="memitem:aec2366220f35b59668ce49ee8900ecd3" id="r_aec2366220f35b59668ce49ee8900ecd3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec2366220f35b59668ce49ee8900ecd3">count_ones</a> () const</td></tr>
<tr class="memdesc:aec2366220f35b59668ce49ee8900ecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in the bit-array.  <br /></td></tr>
<tr class="memitem:a23e7628e2a6037aeed139fec41890031" id="r_a23e7628e2a6037aeed139fec41890031"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23e7628e2a6037aeed139fec41890031">count_zeros</a> () const</td></tr>
<tr class="memdesc:a23e7628e2a6037aeed139fec41890031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in the bit-array.  <br /></td></tr>
<tr class="memitem:a0f54b5aa38bc62c0eb525456408a7b7c" id="r_a0f54b5aa38bc62c0eb525456408a7b7c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f54b5aa38bc62c0eb525456408a7b7c">leading_zeros</a> () const</td></tr>
<tr class="memdesc:a0f54b5aa38bc62c0eb525456408a7b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in the bit-array.  <br /></td></tr>
<tr class="memitem:a60c2d91492bfab341c5fa299884aef54" id="r_a60c2d91492bfab341c5fa299884aef54"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60c2d91492bfab341c5fa299884aef54">trailing_zeros</a> () const</td></tr>
<tr class="memdesc:a60c2d91492bfab341c5fa299884aef54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in the bit-array.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Set-bit Indices:</div></td></tr>
<tr class="memitem:a7a241a6121e734616ef0f6533b107c0f" id="r_a7a241a6121e734616ef0f6533b107c0f"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a> () const</td></tr>
<tr class="memdesc:a7a241a6121e734616ef0f6533b107c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in the bit-array or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:a70869fd293d876be776d4a7664bd0382" id="r_a70869fd293d876be776d4a7664bd0382"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70869fd293d876be776d4a7664bd0382">last_set</a> () const</td></tr>
<tr class="memdesc:a70869fd293d876be776d4a7664bd0382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last set bit in the bit-array or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:a577fdc130a647d7eedada866c420103e" id="r_a577fdc130a647d7eedada866c420103e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a577fdc130a647d7eedada866c420103e">next_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a577fdc130a647d7eedada866c420103e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next set bit after <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more set bits exist.  <br /></td></tr>
<tr class="memitem:a73051c3f6075d625c1a78ae6afd735c2" id="r_a73051c3f6075d625c1a78ae6afd735c2"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73051c3f6075d625c1a78ae6afd735c2">previous_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a73051c3f6075d625c1a78ae6afd735c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous set bit before <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Unset-bit Indices:</div></td></tr>
<tr class="memitem:a511097c7ce5605ff98cda300d6ce558a" id="r_a511097c7ce5605ff98cda300d6ce558a"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a> () const</td></tr>
<tr class="memdesc:a511097c7ce5605ff98cda300d6ce558a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first unset bit in the bit-array or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:ab97cae6007e7a9155f3bc44aeea8396c" id="r_ab97cae6007e7a9155f3bc44aeea8396c"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a> () const</td></tr>
<tr class="memdesc:ab97cae6007e7a9155f3bc44aeea8396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last unset bit in the bit-array or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:ac98ac1300c5ceaa2d0ad24a26b60b297" id="r_ac98ac1300c5ceaa2d0ad24a26b60b297"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:ac98ac1300c5ceaa2d0ad24a26b60b297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next unset bit after <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr class="memitem:a2f70552ecd9a67ade70df35fc747bb03" id="r_a2f70552ecd9a67ade70df35fc747bb03"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a2f70552ecd9a67ade70df35fc747bb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">BitArray Iterators:</div></td></tr>
<tr class="memitem:ae827ae81443b13b09791f8987accc35e" id="r_ae827ae81443b13b09791f8987accc35e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae827ae81443b13b09791f8987accc35e">bits</a> () const</td></tr>
<tr class="memdesc:ae827ae81443b13b09791f8987accc35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-array.  <br /></td></tr>
<tr class="memitem:a94cc67cea544738ec8e66d7be8e6aaf6" id="r_a94cc67cea544738ec8e66d7be8e6aaf6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94cc67cea544738ec8e66d7be8e6aaf6">bits</a> ()</td></tr>
<tr class="memdesc:a94cc67cea544738ec8e66d7be8e6aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const iterator over the values of the bits in the mutable bit-array.  <br /></td></tr>
<tr class="memitem:a29841ea6a7a2723d17ed2f49df9ca5ba" id="r_a29841ea6a7a2723d17ed2f49df9ca5ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29841ea6a7a2723d17ed2f49df9ca5ba">set_bits</a> () const</td></tr>
<tr class="memdesc:a29841ea6a7a2723d17ed2f49df9ca5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-array.  <br /></td></tr>
<tr class="memitem:a3d9e5783287dcffdc7f7479c5a017867" id="r_a3d9e5783287dcffdc7f7479c5a017867"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9e5783287dcffdc7f7479c5a017867">unset_bits</a> () const</td></tr>
<tr class="memdesc:a3d9e5783287dcffdc7f7479c5a017867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-array.  <br /></td></tr>
<tr class="memitem:a12153716c09132e0920158ca213fe958" id="r_a12153716c09132e0920158ca213fe958"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12153716c09132e0920158ca213fe958">store_words</a> () const</td></tr>
<tr class="memdesc:a12153716c09132e0920158ca213fe958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over all the <em>words</em> underlying the v.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Exports:</div></td></tr>
<tr class="memitem:a80e2eec6b618e005b794c20bc5367458" id="r_a80e2eec6b618e005b794c20bc5367458"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80e2eec6b618e005b794c20bc5367458">to_words</a> (std::output_iterator&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; auto out)</td></tr>
<tr class="memdesc:a80e2eec6b618e005b794c20bc5367458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-array and puts them into the passed output iterator.  <br /></td></tr>
<tr class="memitem:a2a0b33fa5dda7332b371911b27a662ed" id="r_a2a0b33fa5dda7332b371911b27a662ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a0b33fa5dda7332b371911b27a662ed">to_words</a> () const</td></tr>
<tr class="memdesc:a2a0b33fa5dda7332b371911b27a662ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-array as a <span class="tt">std::vector&lt;<a class="el" href="#a82a5c674165737fe7c72832867734ea6" title="The underlying unsigned word type used to store the bits.">word_type</a>&gt;</span>.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Spans:</div></td></tr>
<tr class="memitem:a5696c182958a4495cda1c3c1a10cbfd8" id="r_a5696c182958a4495cda1c3c1a10cbfd8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5696c182958a4495cda1c3c1a10cbfd8">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a5696c182958a4495cda1c3c1a10cbfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <em>immutable</em> bit-span encompassing the bit-array's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr class="memitem:a4e798dfeac46955832ea25062ad80523" id="r_a4e798dfeac46955832ea25062ad80523"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e798dfeac46955832ea25062ad80523">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:a4e798dfeac46955832ea25062ad80523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable bit-span encompassing the bit-array's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-vectors:</div></td></tr>
<tr class="memitem:a1487ea33eae413fc582a77fb16e62fa7" id="r_a1487ea33eae413fc582a77fb16e62fa7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1487ea33eae413fc582a77fb16e62fa7">sub</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a1487ea33eae413fc582a77fb16e62fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Splits:</div></td></tr>
<tr class="memitem:ad780efa43f9e461bb5dd7bfda85529bc" id="r_ad780efa43f9e461bb5dd7bfda85529bc"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad780efa43f9e461bb5dd7bfda85529bc">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;left, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;right) const</td></tr>
<tr class="memdesc:ad780efa43f9e461bb5dd7bfda85529bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views the bit-array as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a7ad104649695be7a116b76eab3978b10" title="Returns the number of bit-elements in the bit-array.">size()</a>)</span> respectively.  <br /></td></tr>
<tr class="memitem:a8bfb334e59717269501038fc27192482" id="r_a8bfb334e59717269501038fc27192482"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bfb334e59717269501038fc27192482">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at) const</td></tr>
<tr class="memdesc:a8bfb334e59717269501038fc27192482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views the bit-array as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a7ad104649695be7a116b76eab3978b10" title="Returns the number of bit-elements in the bit-array.">size()</a>)</span> respectively.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Riffling:</div></td></tr>
<tr class="memitem:a23cc27cefe65bd9b7459b564cd007534" id="r_a23cc27cefe65bd9b7459b564cd007534"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23cc27cefe65bd9b7459b564cd007534">riffled</a> (<a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a23cc27cefe65bd9b7459b564cd007534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the bits of this bit-array with zeros storing the result into the bit-vector <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:a994126b6ffb6541fb5d240d44e521bf8" id="r_a994126b6ffb6541fb5d240d44e521bf8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994126b6ffb6541fb5d240d44e521bf8">riffled</a> () const</td></tr>
<tr class="memdesc:a994126b6ffb6541fb5d240d44e521bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the result of riffling the bits in this bit-array with zeros.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations:</div></td></tr>
<tr class="memitem:aecc7e50f56ff23a9df63f6505daf5f7d" id="r_aecc7e50f56ff23a9df63f6505daf5f7d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecc7e50f56ff23a9df63f6505daf5f7d">to_binary_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:aecc7e50f56ff23a9df63f6505daf5f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-array.  <br /></td></tr>
<tr class="memitem:a7e7ba662c7a451fb55b1f64d29d013d1" id="r_a7e7ba662c7a451fb55b1f64d29d013d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:a7e7ba662c7a451fb55b1f64d29d013d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-array.  <br /></td></tr>
<tr class="memitem:a6755c8905474c30b4b07186f5eeb593e" id="r_a6755c8905474c30b4b07186f5eeb593e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6755c8905474c30b4b07186f5eeb593e">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:a6755c8905474c30b4b07186f5eeb593e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "pretty" string representation of the bit-array.  <br /></td></tr>
<tr class="memitem:a58407dca6afa59df2174fec1c730ebd8" id="r_a58407dca6afa59df2174fec1c730ebd8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58407dca6afa59df2174fec1c730ebd8">to_hex_string</a> () const</td></tr>
<tr class="memdesc:a58407dca6afa59df2174fec1c730ebd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "hex" string representation of the bits in the bit-array.  <br /></td></tr>
<tr class="memitem:af4615980c6bea5c571f4b718ed4e18b4" id="r_af4615980c6bea5c571f4b718ed4e18b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4615980c6bea5c571f4b718ed4e18b4">describe</a> () const</td></tr>
<tr class="memdesc:af4615980c6bea5c571f4b718ed4e18b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multi-line string describing the bit-array in some detail.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Factory Constructors:</div></td></tr>
<tr class="memitem:a13f8f554ace87292834f608fb0751255" id="r_a13f8f554ace87292834f608fb0751255"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13f8f554ace87292834f608fb0751255">zeros</a> ()</td></tr>
<tr class="memdesc:a13f8f554ace87292834f608fb0751255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are all 0.  <br /></td></tr>
<tr class="memitem:a67ed2efa8a38a1bf3dbfc3d331806355" id="r_a67ed2efa8a38a1bf3dbfc3d331806355"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ed2efa8a38a1bf3dbfc3d331806355">ones</a> ()</td></tr>
<tr class="memdesc:a67ed2efa8a38a1bf3dbfc3d331806355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are all 1.  <br /></td></tr>
<tr class="memitem:a031cbb90b8f238feaa4e229ad591dbd1" id="r_a031cbb90b8f238feaa4e229ad591dbd1"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a031cbb90b8f238feaa4e229ad591dbd1">constant</a> (bool value)</td></tr>
<tr class="memdesc:a031cbb90b8f238feaa4e229ad591dbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are set to <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a5af5e7878acfef3183ebe90ed51e5762" id="r_a5af5e7878acfef3183ebe90ed51e5762"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af5e7878acfef3183ebe90ed51e5762">unit</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a5af5e7878acfef3183ebe90ed51e5762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a "unit" bit-array of length <span class="tt">N</span> where only element <span class="tt">i</span> is set.  <br /></td></tr>
<tr class="memitem:ad9339fa7fd1194c526743a16883da957" id="r_ad9339fa7fd1194c526743a16883da957"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9339fa7fd1194c526743a16883da957">alternating</a> ()</td></tr>
<tr class="memdesc:ad9339fa7fd1194c526743a16883da957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of length <span class="tt">N</span> looking like <span class="tt">101010...</span>.  <br /></td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Construct BitArrays with Random Fills:</div></td></tr>
<tr class="memitem:acfbd3d13cf6f1050b32fbd30054b8448" id="r_acfbd3d13cf6f1050b32fbd30054b8448"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbd3d13cf6f1050b32fbd30054b8448">random</a> (double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:acfbd3d13cf6f1050b32fbd30054b8448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are picked at random.  <br /></td></tr>
<tr class="memitem:ac3ce12d8dff51751e6434d1fa287b65c" id="r_ac3ce12d8dff51751e6434d1fa287b65c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3ce12d8dff51751e6434d1fa287b65c">seeded_random</a> (<a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed)</td></tr>
<tr class="memdesc:ac3ce12d8dff51751e6434d1fa287b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a76cc891c25b8b9da8fcb9a07e2d2cbda" id="r_a76cc891c25b8b9da8fcb9a07e2d2cbda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76cc891c25b8b9da8fcb9a07e2d2cbda">biased_random</a> (double p)</td></tr>
<tr class="memdesc:a76cc891c25b8b9da8fcb9a07e2d2cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a32be0a97782d0e03d6f4bd81b7ca6519" id="r_a32be0a97782d0e03d6f4bd81b7ca6519"><td class="memItemLeft" align="right" valign="top"><a id="a32be0a97782d0e03d6f4bd81b7ca6519" name="a32be0a97782d0e03d6f4bd81b7ca6519"></a>
static constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bits_per_word</b> = <a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Word&gt;</td></tr>
<tr class="memdesc:a32be0a97782d0e03d6f4bd81b7ca6519"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits per <span class="tt">Word</span>. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Helper Method:</h2></td></tr>
<tr class="memitem:a7a8e145c0864f8245ee1d0cb935faa9b" id="r_a7a8e145c0864f8245ee1d0cb935faa9b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a8e145c0864f8245ee1d0cb935faa9b">clean</a> ()</td></tr>
<tr class="memdesc:a7a8e145c0864f8245ee1d0cb935faa9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets any unused bits in the <em>last</em> occupied word to 0.  <br /></td></tr>
<tr class="memitem:a5bcdfdb6362b71cb2c73e684914ab279" id="r_a5bcdfdb6362b71cb2c73e684914ab279"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; <br />
requires (<a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Src&gt; == N)</td></tr>
<tr class="memitem:a5bcdfdb6362b71cb2c73e684914ab279 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bcdfdb6362b71cb2c73e684914ab279">from</a> (Src src)</td></tr>
<tr class="memdesc:a5bcdfdb6362b71cb2c73e684914ab279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-array by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance.  <br /></td></tr>
<tr class="memitem:a9ad5d26dd30796f1fb0da4aaf74a2d2b" id="r_a9ad5d26dd30796f1fb0da4aaf74a2d2b"><td class="memTemplParams" colspan="2">template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</td></tr>
<tr class="memitem:a9ad5d26dd30796f1fb0da4aaf74a2d2b template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad5d26dd30796f1fb0da4aaf74a2d2b">from</a> (Iter src_begin, Iter src_end)</td></tr>
<tr class="memdesc:a9ad5d26dd30796f1fb0da4aaf74a2d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-array by copying <em>all</em> the bits from an iteration of <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>s.  <br /></td></tr>
<tr class="memitem:a4d89093857a783b598995b6a45b8c8dd" id="r_a4d89093857a783b598995b6a45b8c8dd"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d89093857a783b598995b6a45b8c8dd">from</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a4d89093857a783b598995b6a45b8c8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-array from the bits of a <span class="tt">std::bitset</span>.  <br /></td></tr>
<tr class="memitem:a6ede5ef1640515441b749d6071fcf8c1" id="r_a6ede5ef1640515441b749d6071fcf8c1"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ede5ef1640515441b749d6071fcf8c1">from</a> (std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a6ede5ef1640515441b749d6071fcf8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-array by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, N)</span>.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt;<br />
class gf2::BitArray&lt; N, Word &gt;</div><p>A fixed-size "vector" over GF(2) with <span class="tt">N</span> bit elements compactly stored in a standard array of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. The elements in a bit-array are initially all set to 0. </p>
<p><span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;N&gt;</span> is similar to <span class="tt">std::bitset&lt;N&gt;</span> but has a richer set of functionality.</p>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a></span> class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> concept. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae52f2a1cd4ba693f95405eaa007b42fc" name="ae52f2a1cd4ba693f95405eaa007b42fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52f2a1cd4ba693f95405eaa007b42fc">&#9670;&#160;</a></span>BitArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::BitArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-array of length <span class="tt">N</span> with all the bit elements set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-16"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> u;</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a7e7ba662c7a451fb55b1f64d29d013d1"><div class="ttname"><a href="#a7e7ba662c7a451fb55b1f64d29d013d1">gf2::BitArray::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1244</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ae52f2a1cd4ba693f95405eaa007b42fc"><div class="ttname"><a href="#ae52f2a1cd4ba693f95405eaa007b42fc">gf2::BitArray::BitArray</a></div><div class="ttdeci">constexpr BitArray()</div><div class="ttdoc">Constructs a bit-array of length N with all the bit elements set to 0.</div><div class="ttdef"><b>Definition</b> BitArray.h:148</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a569ff1ae6099c874abcb496104fa6ce8" name="a569ff1ae6099c874abcb496104fa6ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569ff1ae6099c874abcb496104fa6ce8">&#9670;&#160;</a></span>BitArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::BitArray </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-array with <span class="tt">N</span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98" title="Returns word i from the bit-array&#39;s underlying word store.">word</a></span>. </p>
<p>The final copy of <span class="tt"><a class="el" href="#a1f2ba699dc21d37cdcd955b3baa54a98" title="Returns word i from the bit-array&#39;s underlying word store.">word</a></span> may be truncated and padded with zeros (unused bit slots are always set to zero).</p>
<h1 class="doxsection"><a class="anchor" id="example-17"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v{<a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0101&#39;0101}};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a872a69469085fcdddf299ae4adc3c940"><div class="ttname"><a href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">gf2::u8</a></div><div class="ttdeci">std::uint8_t u8</div><div class="ttdoc">Word type alias for an 8-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:30</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a495ffc84725d778f6df7e2189f622644" name="a495ffc84725d778f6df7e2189f622644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ffc84725d778f6df7e2189f622644">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all bits in the bit-array are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-arrays have no set bits (logical connective for <span class="tt"><a class="el" href="#a495ffc84725d778f6df7e2189f622644" title="Returns true if all bits in the bit-array are set, false otherwise.">all</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-40"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;3&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a495ffc84725d778f6df7e2189f622644">all</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(1);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a495ffc84725d778f6df7e2189f622644">all</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a07520d5580bf502c10a4b5e53aa7d667"><div class="ttname"><a href="#a07520d5580bf502c10a4b5e53aa7d667">gf2::BitArray::set</a></div><div class="ttdeci">constexpr auto set(usize i, bool value=true)</div><div class="ttdoc">Sets the bit-element i to the specified boolean value &amp; returns this for chaining....</div><div class="ttdef"><b>Definition</b> BitArray.h:459</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a495ffc84725d778f6df7e2189f622644"><div class="ttname"><a href="#a495ffc84725d778f6df7e2189f622644">gf2::BitArray::all</a></div><div class="ttdeci">constexpr bool all() const</div><div class="ttdoc">Returns true if all bits in the bit-array are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:573</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad9339fa7fd1194c526743a16883da957" name="ad9339fa7fd1194c526743a16883da957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9339fa7fd1194c526743a16883da957">&#9670;&#160;</a></span>alternating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of length <span class="tt">N</span> looking like <span class="tt">101010...</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-22"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ad9339fa7fd1194c526743a16883da957">BitArray&lt;10, u8&gt;::alternating</a>();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ad9339fa7fd1194c526743a16883da957"><div class="ttname"><a href="#ad9339fa7fd1194c526743a16883da957">gf2::BitArray::alternating</a></div><div class="ttdeci">static constexpr BitArray alternating()</div><div class="ttdoc">Factory method to generate a bit-array of length N looking like 101010....</div><div class="ttdef"><b>Definition</b> BitArray.h:223</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a765eeb4afcf8135e670176939cf3cc74" name="a765eeb4afcf8135e670176939cf3cc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765eeb4afcf8135e670176939cf3cc74">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if at least one bit in the bit-array is set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-arrays have no set bits (logical connective for <span class="tt"><a class="el" href="#a765eeb4afcf8135e670176939cf3cc74" title="Returns true if at least one bit in the bit-array is set, false otherwise.">any</a></span> is <span class="tt">OR</span> with identity <span class="tt">false</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-39"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a765eeb4afcf8135e670176939cf3cc74">any</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a765eeb4afcf8135e670176939cf3cc74">any</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a765eeb4afcf8135e670176939cf3cc74"><div class="ttname"><a href="#a765eeb4afcf8135e670176939cf3cc74">gf2::BitArray::any</a></div><div class="ttdeci">constexpr bool any() const</div><div class="ttdoc">Returns true if at least one bit in the bit-array is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:558</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a017bf4fa4deddd2a4f660aec879b2450" name="a017bf4fa4deddd2a4f660aec879b2450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017bf4fa4deddd2a4f660aec879b2450">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-6"></a>
Panics</h1>
<p>In debug mode the method panics if the bit-array is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-33"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a017bf4fa4deddd2a4f660aec879b2450">back</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a017bf4fa4deddd2a4f660aec879b2450">back</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a017bf4fa4deddd2a4f660aec879b2450"><div class="ttname"><a href="#a017bf4fa4deddd2a4f660aec879b2450">gf2::BitArray::back</a></div><div class="ttdeci">constexpr bool back() const</div><div class="ttdoc">Returns true if the last bit element is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:440</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_aab2791cfd5ff853058cc609a4d3b354c"><div class="ttname"><a href="#aab2791cfd5ff853058cc609a4d3b354c">gf2::BitArray::set_all</a></div><div class="ttdeci">constexpr auto set_all(bool value=true)</div><div class="ttdoc">Sets all the bits in the bit-array to the boolean value and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitArray.h:602</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a76cc891c25b8b9da8fcb9a07e2d2cbda" name="a76cc891c25b8b9da8fcb9a07e2d2cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cc891c25b8b9da8fcb9a07e2d2cbda">&#9670;&#160;</a></span>biased_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-29"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a76cc891c25b8b9da8fcb9a07e2d2cbda">BitArray&lt;10&gt;::biased_random</a>(0.3);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a76cc891c25b8b9da8fcb9a07e2d2cbda">BitArray&lt;10&gt;::biased_random</a>(0.3);</div>
<div class="line">assert_eq(u.size(), v.size());</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a76cc891c25b8b9da8fcb9a07e2d2cbda"><div class="ttname"><a href="#a76cc891c25b8b9da8fcb9a07e2d2cbda">gf2::BitArray::biased_random</a></div><div class="ttdeci">static BitArray biased_random(double p)</div><div class="ttdoc">Factory method to generate a bit-array of size N where the elements are from independent fair coin fl...</div><div class="ttdef"><b>Definition</b> BitArray.h:379</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94cc67cea544738ec8e66d7be8e6aaf6" name="a94cc67cea544738ec8e66d7be8e6aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cc67cea544738ec8e66d7be8e6aaf6">&#9670;&#160;</a></span>bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const iterator over the values of the bits in the mutable bit-array. </p>
<p>You can use this iterator to iterate over the bits in the store to get <em>or</em> set the value of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="note-8"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-63"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : v.<a class="code hl_function" href="#ae827ae81443b13b09791f8987accc35e">bits</a>()) bit = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ae827ae81443b13b09791f8987accc35e"><div class="ttname"><a href="#ae827ae81443b13b09791f8987accc35e">gf2::BitArray::bits</a></div><div class="ttdeci">constexpr auto bits() const</div><div class="ttdoc">Returns a const iterator over the bool values of the bits in the const bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:961</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae827ae81443b13b09791f8987accc35e" name="ae827ae81443b13b09791f8987accc35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae827ae81443b13b09791f8987accc35e">&#9670;&#160;</a></span>bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-array. </p>
<p>You can use this iterator to iterate over the bits in the store and get the values of each bit as a <span class="tt">bool</span>.</p>
<h1 class="doxsection"><a class="anchor" id="note-7"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-62"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : v.<a class="code hl_function" href="#ae827ae81443b13b09791f8987accc35e">bits</a>()) assert_eq(bit, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a8e145c0864f8245ee1d0cb935faa9b" name="a7a8e145c0864f8245ee1d0cb935faa9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e145c0864f8245ee1d0cb935faa9b">&#9670;&#160;</a></span>clean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::clean </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets any unused bits in the <em>last</em> occupied word to 0. </p>
<p>You can use this helper method to enforce the guarantee that unused bits in the store are always set to 0. </p>

</div>
</div>
<a id="a031cbb90b8f238feaa4e229ad591dbd1" name="a031cbb90b8f238feaa4e229ad591dbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031cbb90b8f238feaa4e229ad591dbd1">&#9670;&#160;</a></span>constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::constant </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are set to <span class="tt">value</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-20"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a031cbb90b8f238feaa4e229ad591dbd1">BitArray&lt;10&gt;::constant</a>(<span class="keyword">true</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a031cbb90b8f238feaa4e229ad591dbd1">BitArray&lt;10&gt;::constant</a>(<span class="keyword">false</span>);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a031cbb90b8f238feaa4e229ad591dbd1"><div class="ttname"><a href="#a031cbb90b8f238feaa4e229ad591dbd1">gf2::BitArray::constant</a></div><div class="ttdeci">static constexpr BitArray constant(bool value)</div><div class="ttdoc">Factory method to generate a bit-array of length N where the elements are set to value.</div><div class="ttdef"><b>Definition</b> BitArray.h:198</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9b261afd0bd70025f4d02c79841d80f6" name="a9b261afd0bd70025f4d02c79841d80f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b261afd0bd70025f4d02c79841d80f6">&#9670;&#160;</a></span>copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to this <em>equal-sized</em> bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="note-4"></a>
Note</h1>
<p>We allow <em>any</em> unsigned integral source, e.g. copying <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> words into a <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;N,<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of the correct size.</p>
<h1 class="doxsection"><a class="anchor" id="panics-12"></a>
Panics</h1>
<p>Panics if the size of this bit-array does not match the number of bits in the source iteration.</p>
<h1 class="doxsection"><a class="anchor" id="example-45"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;48, u8&gt;</a> v;</div>
<div class="line">std::vector&lt;u16&gt; src = { 0b1010101010101010, 0b1010101010101010, 0b1111111111111111 };</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(src.begin(), src.end());</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitArray.html">BitArray&lt;48, u32&gt;</a> w;</div>
<div class="line">w.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(src.begin(), src.end());</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html"><div class="ttname"><a href="classgf2_1_1BitArray.html">gf2::BitArray</a></div><div class="ttdoc">A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...</div><div class="ttdef"><b>Definition</b> BitArray.h:24</div></div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a6bbfb8e5e1b435b698caf37e85f23173"><div class="ttname"><a href="#a6bbfb8e5e1b435b698caf37e85f23173">gf2::BitArray::copy</a></div><div class="ttdeci">constexpr auto copy(Src src)</div><div class="ttdoc">Copies all the bits from any unsigned integral src value to this equal-sized bit-array....</div><div class="ttdef"><b>Definition</b> BitArray.h:645</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab519ea74f5c99f8de2dfe7868f5c2e59" name="ab519ea74f5c99f8de2dfe7868f5c2e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab519ea74f5c99f8de2dfe7868f5c2e59">&#9670;&#160;</a></span>copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to this <em>equal-sized</em> bit-array and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-5"></a>
Note</h1>
<p>This is one of the few methods in the library that <em>doesn't</em> require the two stores to have the same <span class="tt"><a class="el" href="#a82a5c674165737fe7c72832867734ea6" title="The underlying unsigned word type used to store the bits.">word_type</a></span>. You can use it to convert between different <span class="tt"><a class="el" href="#a82a5c674165737fe7c72832867734ea6" title="The underlying unsigned word type used to store the bits.">word_type</a></span> stores (e.g., from <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;<a class="el" href="namespacegf2.html#ad1e43953e374bea8222087e4aba6c74a" title="Word type alias for a 32-bit unsigned integer.">u32</a>&gt;</span> to <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>) as long as the sizes match.</p>
<h1 class="doxsection"><a class="anchor" id="panics-13"></a>
Panics</h1>
<p>Panics if the sizes of this bit-array and the <span class="tt">src</span> bit-store do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-46"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u64&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(<a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10));</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aeed3a5c646dbc7c38b4298574734ae4a"><div class="ttname"><a href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">gf2::BitVector::alternating</a></div><div class="ttdeci">static constexpr BitVector alternating(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n looking like 101010....</div><div class="ttdef"><b>Definition</b> BitVector.h:239</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6bbfb8e5e1b435b698caf37e85f23173" name="a6bbfb8e5e1b435b698caf37e85f23173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbfb8e5e1b435b698caf37e85f23173">&#9670;&#160;</a></span>copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-array. Returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="notes"></a>
Notes:</h1>
<ol type="1">
<li>We allow <em>any</em> unsigned integral source, e.g. copying a single <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of size 64.</li>
<li>The least-significant bit of the source becomes the bit at index 0 in the bit-array.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="panics-11"></a>
Panics</h1>
<p>Panics if the size of the bit-array does not match the number of bits in the source integer type.</p>
<h1 class="doxsection"><a class="anchor" id="example-44"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;16, u8&gt;</a> v;</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;16, u32&gt;</a> w;</div>
<div class="line">w.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(src);</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ae858164ae3b877b1f9ea2606fae215a0"><div class="ttname"><a href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">gf2::u16</a></div><div class="ttdeci">std::uint16_t u16</div><div class="ttdoc">Word type alias for a 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a04b6537b8fc7e153e63a5fff962a2da5" name="a04b6537b8fc7e153e63a5fff962a2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b6537b8fc7e153e63a5fff962a2da5">&#9670;&#160;</a></span>copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from a <span class="tt">std::bitset</span> to this <em>equal-sized</em> bit-array and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-6"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> which is the reverse of our convention.</p>
<h1 class="doxsection"><a class="anchor" id="panics-14"></a>
Panics</h1>
<p>Panics if the size of the bit-array does not match the number of bits in the source <span class="tt">std::bitset</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-47"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitArray.html">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4964592bbf2abe874c697f3103646993" name="a4964592bbf2abe874c697f3103646993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4964592bbf2abe874c697f3103646993">&#9670;&#160;</a></span>copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the bit-array by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-48"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7ad104649695be7a116b76eab3978b10">size</a>(), 10);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a7ad104649695be7a116b76eab3978b10"><div class="ttname"><a href="#a7ad104649695be7a116b76eab3978b10">gf2::BitArray::size</a></div><div class="ttdeci">constexpr usize size() const</div><div class="ttdoc">Returns the number of bit-elements in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:46</div></div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aec2366220f35b59668ce49ee8900ecd3" name="aec2366220f35b59668ce49ee8900ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2366220f35b59668ce49ee8900ecd3">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in the bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="example-50"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aec2366220f35b59668ce49ee8900ecd3">count_ones</a>(), 0);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aec2366220f35b59668ce49ee8900ecd3">count_ones</a>(), 1);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_aec2366220f35b59668ce49ee8900ecd3"><div class="ttname"><a href="#aec2366220f35b59668ce49ee8900ecd3">gf2::BitArray::count_ones</a></div><div class="ttdeci">constexpr usize count_ones() const</div><div class="ttdoc">Returns the number of set bits in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:772</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23e7628e2a6037aeed139fec41890031" name="a23e7628e2a6037aeed139fec41890031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e7628e2a6037aeed139fec41890031">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in the bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="example-51"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a23e7628e2a6037aeed139fec41890031">count_zeros</a>(), 10);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a23e7628e2a6037aeed139fec41890031">count_zeros</a>(), 9);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a23e7628e2a6037aeed139fec41890031"><div class="ttname"><a href="#a23e7628e2a6037aeed139fec41890031">gf2::BitArray::count_zeros</a></div><div class="ttdeci">constexpr usize count_zeros() const</div><div class="ttdoc">Returns the number of unset bits in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:783</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af4615980c6bea5c571f4b718ed4e18b4" name="af4615980c6bea5c571f4b718ed4e18b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4615980c6bea5c571f4b718ed4e18b4">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::describe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a multi-line string describing the bit-array in some detail. </p>
<p>This method is useful for debugging but you should not rely on the output format which may change. </p>

</div>
</div>
<a id="a62a56d20bc5fbfcd02f60906095ce694" name="a62a56d20bc5fbfcd02f60906095ce694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a56d20bc5fbfcd02f60906095ce694">&#9670;&#160;</a></span>fill_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::fill_random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the bit-array with random bits and returns a reference to this for chaining. </p>
<p>The default call <span class="tt"><a class="el" href="#a62a56d20bc5fbfcd02f60906095ce694" title="Fill the bit-array with random bits and returns a reference to this for chaining.">fill_random()</a></span> sets each bit to 1 with probability 0.5 (fair coin).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the fill is all zeros, if <span class="tt">p &gt; 1</span> then the fill is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-49"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> u, v;</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line">u.<a class="code hl_function" href="#a62a56d20bc5fbfcd02f60906095ce694">fill_random</a>(0.5, seed);</div>
<div class="line">v.<a class="code hl_function" href="#a62a56d20bc5fbfcd02f60906095ce694">fill_random</a>(0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a62a56d20bc5fbfcd02f60906095ce694"><div class="ttname"><a href="#a62a56d20bc5fbfcd02f60906095ce694">gf2::BitArray::fill_random</a></div><div class="ttdeci">constexpr auto fill_random(double p=0.5, u64 seed=0)</div><div class="ttdoc">Fill the bit-array with random bits and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitArray.h:754</div></div>
<div class="ttc" id="anamespacegf2_html_a770302128133591da0ca93ded6abf8aa"><div class="ttname"><a href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">gf2::u64</a></div><div class="ttdeci">std::uint64_t u64</div><div class="ttdoc">Word type alias for a 64-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a241a6121e734616ef0f6533b107c0f" name="a7a241a6121e734616ef0f6533b107c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a241a6121e734616ef0f6533b107c0f">&#9670;&#160;</a></span>first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::first_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first set bit in the bit-array or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-54"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a>() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a>() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a7a241a6121e734616ef0f6533b107c0f">first_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a7a241a6121e734616ef0f6533b107c0f"><div class="ttname"><a href="#a7a241a6121e734616ef0f6533b107c0f">gf2::BitArray::first_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_set() const</div><div class="ttdoc">Returns the index of the first set bit in the bit-array or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitArray.h:829</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a511097c7ce5605ff98cda300d6ce558a" name="a511097c7ce5605ff98cda300d6ce558a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511097c7ce5605ff98cda300d6ce558a">&#9670;&#160;</a></span>first_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::first_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first unset bit in the bit-array or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-58"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert(v.<a class="code hl_function" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a>() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a>() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a511097c7ce5605ff98cda300d6ce558a">first_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a511097c7ce5605ff98cda300d6ce558a"><div class="ttname"><a href="#a511097c7ce5605ff98cda300d6ce558a">gf2::BitArray::first_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_unset() const</div><div class="ttdoc">Returns the index of the first unset bit in the bit-array or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitArray.h:893</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1cc837e63f24b06f9d6d756435451542" name="a1cc837e63f24b06f9d6d756435451542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc837e63f24b06f9d6d756435451542">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-9"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-36"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a67ed2efa8a38a1bf3dbfc3d331806355">BitArray&lt;10, u8&gt;::ones</a>();</div>
<div class="line">v.flip(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0111111111&quot;</span>);</div>
<div class="line">v.flip(1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111111&quot;</span>);</div>
<div class="line">v.flip(9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111110&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a67ed2efa8a38a1bf3dbfc3d331806355"><div class="ttname"><a href="#a67ed2efa8a38a1bf3dbfc3d331806355">gf2::BitArray::ones</a></div><div class="ttdeci">static constexpr BitArray ones()</div><div class="ttdoc">Factory method to generate a bit-array of length N where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitArray.h:187</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac03f099279bd6d712604d8d2468b0a74" name="ac03f099279bd6d712604d8d2468b0a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03f099279bd6d712604d8d2468b0a74">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bits in the bit-array and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-43"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#ac03f099279bd6d712604d8d2468b0a74">flip_all</a>();</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ac03f099279bd6d712604d8d2468b0a74"><div class="ttname"><a href="#ac03f099279bd6d712604d8d2468b0a74">gf2::BitArray::flip_all</a></div><div class="ttdeci">constexpr auto flip_all()</div><div class="ttdoc">Flips the value of the bits in the bit-array and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitArray.h:615</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9ad5d26dd30796f1fb0da4aaf74a2d2b" name="a9ad5d26dd30796f1fb0da4aaf74a2d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad5d26dd30796f1fb0da4aaf74a2d2b">&#9670;&#160;</a></span>from() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;typename Iter&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-array by copying <em>all</em> the bits from an iteration of <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>s. </p>
<h1 class="doxsection"><a class="anchor" id="note-1"></a>
Note</h1>
<p>We allow <em>any</em> unsigned integral source, e.g. copying <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> words into a <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;N, <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-2"></a>
Panics</h1>
<p>Panics if the number of bits in the source iteration does not match <span class="tt">N</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-24"></a>
Example</h1>
<div class="fragment"><div class="line">std::vector&lt;u16&gt; src = { 0b1010101010101010, 0b1010101010101010, 0b1111111111111111 };</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;48, u8&gt;::from</a>(src.begin(), src.end());</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;48, u32&gt;::from</a>(src.begin(), src.end());</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a5bcdfdb6362b71cb2c73e684914ab279"><div class="ttname"><a href="#a5bcdfdb6362b71cb2c73e684914ab279">gf2::BitArray::from</a></div><div class="ttdeci">static constexpr BitArray from(Src src)</div><div class="ttdoc">Factory method to construct a bit-array by copying all the bits from any Unsigned instance.</div><div class="ttdef"><b>Definition</b> BitArray.h:256</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5bcdfdb6362b71cb2c73e684914ab279" name="a5bcdfdb6362b71cb2c73e684914ab279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcdfdb6362b71cb2c73e684914ab279">&#9670;&#160;</a></span>from() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; <br />
requires (<a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Src&gt; == N)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-array by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance. </p>
<h1 class="doxsection"><a class="anchor" id="note"></a>
Note</h1>
<p>The source type <span class="tt">Src</span> must have exactly <span class="tt">N</span> bits.</p>
<h1 class="doxsection"><a class="anchor" id="example-23"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> s8 = 0b01010101;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;8, u8&gt;::from</a>(s8);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> s16 = 0b0101010101010101;</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;16, u8&gt;::from</a>(s16);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;8, u32&gt;::from</a>(s8);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4d89093857a783b598995b6a45b8c8dd" name="a4d89093857a783b598995b6a45b8c8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d89093857a783b598995b6a45b8c8dd">&#9670;&#160;</a></span>from() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-array from the bits of a <span class="tt">std::bitset</span>. </p>
<h1 class="doxsection"><a class="anchor" id="note-2"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> ...b2b1b0., we print in <em>vector-order</em> b0b1b2...</p>
<h1 class="doxsection"><a class="anchor" id="example-25"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;10&gt;::from</a>(src);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ede5ef1640515441b749d6071fcf8c1" name="a6ede5ef1640515441b749d6071fcf8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ede5ef1640515441b749d6071fcf8c1">&#9670;&#160;</a></span>from() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-array by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, N)</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to call for each index <span class="tt">i</span> in <span class="tt">[0, N)</span>.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-26"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a5bcdfdb6362b71cb2c73e684914ab279">BitArray&lt;10, u8&gt;::from</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a399a6f87005a45a028c582d71201ee16" name="a399a6f87005a45a028c582d71201ee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399a6f87005a45a028c582d71201ee16">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-5"></a>
Panics</h1>
<p>In debug mode the method panics if the bit-array is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-32"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a399a6f87005a45a028c582d71201ee16">front</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a399a6f87005a45a028c582d71201ee16">front</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a399a6f87005a45a028c582d71201ee16"><div class="ttname"><a href="#a399a6f87005a45a028c582d71201ee16">gf2::BitArray::front</a></div><div class="ttdeci">constexpr bool front() const</div><div class="ttdoc">Returns true if the first bit element is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:426</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaa00b06652d4701559e37f9a510048a4" name="aaa00b06652d4701559e37f9a510048a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa00b06652d4701559e37f9a510048a4">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-3"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-30"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aaa00b06652d4701559e37f9a510048a4">get</a>(0), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aaa00b06652d4701559e37f9a510048a4">get</a>(0), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_aaa00b06652d4701559e37f9a510048a4"><div class="ttname"><a href="#aaa00b06652d4701559e37f9a510048a4">gf2::BitArray::get</a></div><div class="ttdeci">constexpr bool get(usize i) const</div><div class="ttdoc">Returns true if the bit at the given index i is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:397</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad9a3e55e8989e6c85c9ec7ea4d0f7d7b" name="ad9a3e55e8989e6c85c9ec7ea4d0f7d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a3e55e8989e6c85c9ec7ea4d0f7d7b">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit-array is empty, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="example-38"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad9a3e55e8989e6c85c9ec7ea4d0f7d7b">is_empty</a>(), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> u;</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#ad9a3e55e8989e6c85c9ec7ea4d0f7d7b">is_empty</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ad9a3e55e8989e6c85c9ec7ea4d0f7d7b"><div class="ttname"><a href="#ad9a3e55e8989e6c85c9ec7ea4d0f7d7b">gf2::BitArray::is_empty</a></div><div class="ttdeci">constexpr bool is_empty() const</div><div class="ttdoc">Returns true if the bit-array is empty, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:545</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70869fd293d876be776d4a7664bd0382" name="a70869fd293d876be776d4a7664bd0382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70869fd293d876be776d4a7664bd0382">&#9670;&#160;</a></span>last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::last_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last set bit in the bit-array or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-55"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a70869fd293d876be776d4a7664bd0382">last_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a70869fd293d876be776d4a7664bd0382">last_set</a>() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a70869fd293d876be776d4a7664bd0382">last_set</a>() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a70869fd293d876be776d4a7664bd0382">last_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a70869fd293d876be776d4a7664bd0382"><div class="ttname"><a href="#a70869fd293d876be776d4a7664bd0382">gf2::BitArray::last_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_set() const</div><div class="ttdoc">Returns the index of the last set bit in the bit-array or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitArray.h:844</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab97cae6007e7a9155f3bc44aeea8396c" name="ab97cae6007e7a9155f3bc44aeea8396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97cae6007e7a9155f3bc44aeea8396c">&#9670;&#160;</a></span>last_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::last_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last unset bit in the bit-array or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-59"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert(v.<a class="code hl_function" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a>() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a>() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#ab97cae6007e7a9155f3bc44aeea8396c">last_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ab97cae6007e7a9155f3bc44aeea8396c"><div class="ttname"><a href="#ab97cae6007e7a9155f3bc44aeea8396c">gf2::BitArray::last_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_unset() const</div><div class="ttdoc">Returns the index of the last unset bit in the bit-array or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitArray.h:910</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0f54b5aa38bc62c0eb525456408a7b7c" name="a0f54b5aa38bc62c0eb525456408a7b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f54b5aa38bc62c0eb525456408a7b7c">&#9670;&#160;</a></span>leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::leading_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in the bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="example-52"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a0f54b5aa38bc62c0eb525456408a7b7c">leading_zeros</a>(), 37);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a0f54b5aa38bc62c0eb525456408a7b7c">leading_zeros</a>(), 27);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> w;</div>
<div class="line">w.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="#a0f54b5aa38bc62c0eb525456408a7b7c">leading_zeros</a>(), 0);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a0f54b5aa38bc62c0eb525456408a7b7c"><div class="ttname"><a href="#a0f54b5aa38bc62c0eb525456408a7b7c">gf2::BitArray::leading_zeros</a></div><div class="ttdeci">constexpr usize leading_zeros() const</div><div class="ttdoc">Returns the number of leading zeros in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:797</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a577fdc130a647d7eedada866c420103e" name="a577fdc130a647d7eedada866c420103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577fdc130a647d7eedada866c420103e">&#9670;&#160;</a></span>next_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::next_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next set bit after <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more set bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-56"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a577fdc130a647d7eedada866c420103e">next_set</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a577fdc130a647d7eedada866c420103e">next_set</a>(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a577fdc130a647d7eedada866c420103e">next_set</a>(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a577fdc130a647d7eedada866c420103e">next_set</a>(27) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a577fdc130a647d7eedada866c420103e"><div class="ttname"><a href="#a577fdc130a647d7eedada866c420103e">gf2::BitArray::next_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_set(usize index) const</div><div class="ttdoc">Returns the index of the next set bit after index in the bit-array or {} if no more set bits exist.</div><div class="ttdef"><b>Definition</b> BitArray.h:858</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac98ac1300c5ceaa2d0ad24a26b60b297" name="ac98ac1300c5ceaa2d0ad24a26b60b297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98ac1300c5ceaa2d0ad24a26b60b297">&#9670;&#160;</a></span>next_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::next_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next unset bit after <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-60"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert(v.<a class="code hl_function" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2, <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a>(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.<a class="code hl_function" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a>(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.<a class="code hl_function" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a>(27) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#ac98ac1300c5ceaa2d0ad24a26b60b297">next_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ac98ac1300c5ceaa2d0ad24a26b60b297"><div class="ttname"><a href="#ac98ac1300c5ceaa2d0ad24a26b60b297">gf2::BitArray::next_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_unset(usize index) const</div><div class="ttdoc">Returns the index of the next unset bit after index in the bit-array or {} if no more unset bits exis...</div><div class="ttdef"><b>Definition</b> BitArray.h:926</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a900179c6249e397df28923963bc4e701" name="a900179c6249e397df28923963bc4e701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900179c6249e397df28923963bc4e701">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no bits in the bit-array are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-arrays have no set bits (logical connective for <span class="tt"><a class="el" href="#a900179c6249e397df28923963bc4e701" title="Returns true if no bits in the bit-array are set, false otherwise.">none</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-41"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a900179c6249e397df28923963bc4e701">none</a>(), <span class="keyword">true</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a900179c6249e397df28923963bc4e701">none</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a900179c6249e397df28923963bc4e701"><div class="ttname"><a href="#a900179c6249e397df28923963bc4e701">gf2::BitArray::none</a></div><div class="ttdeci">constexpr bool none() const</div><div class="ttdoc">Returns true if no bits in the bit-array are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitArray.h:586</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7c933a9a3a7083e9d529d27fbd7c2622" name="a7c933a9a3a7083e9d529d27fbd7c2622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c933a9a3a7083e9d529d27fbd7c2622">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::offset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset (in bits) of the first bit in the bit-array within the first word. </p>
<p>This is always zero for <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a></span>. </p>

</div>
</div>
<a id="a67ed2efa8a38a1bf3dbfc3d331806355" name="a67ed2efa8a38a1bf3dbfc3d331806355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ed2efa8a38a1bf3dbfc3d331806355">&#9670;&#160;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are all 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-19"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a67ed2efa8a38a1bf3dbfc3d331806355">BitArray&lt;10, u8&gt;::ones</a>();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a203a3d6a790f50d83edcb9ed6b41ca9c" name="a203a3d6a790f50d83edcb9ed6b41ca9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203a3d6a790f50d83edcb9ed6b41ca9c">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "reference" to the bit element <span class="tt">i</span>. </p>
<p>The returned object is a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference for the bit element at <span class="tt">index</span> rather than a true reference.</p>
<h1 class="doxsection"><a class="anchor" id="note-3"></a>
Note</h1>
<p>The referenced bit-array must continue to exist while the <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="panics-8"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-35"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> w;</div>
<div class="line">w.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">v[3] = w[3];</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>() == <span class="stringliteral">&quot;0011000000&quot;</span>);</div>
<div class="line">v[4] |= w[4];</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>() == <span class="stringliteral">&quot;0011100000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a21b4970c7bc711da4888caaeb71fbbab" name="a21b4970c7bc711da4888caaeb71fbbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b4970c7bc711da4888caaeb71fbbab">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boolean value of the bit element <span class="tt">i</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-4"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-31"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert(v[2] == <span class="keyword">false</span>);</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v[2] == <span class="keyword">true</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73051c3f6075d625c1a78ae6afd735c2" name="a73051c3f6075d625c1a78ae6afd735c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73051c3f6075d625c1a78ae6afd735c2">&#9670;&#160;</a></span>previous_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::previous_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous set bit before <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-57"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a73051c3f6075d625c1a78ae6afd735c2">previous_set</a>(36) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a73051c3f6075d625c1a78ae6afd735c2">previous_set</a>(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a73051c3f6075d625c1a78ae6afd735c2">previous_set</a>(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a73051c3f6075d625c1a78ae6afd735c2">previous_set</a>(2)  == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a73051c3f6075d625c1a78ae6afd735c2"><div class="ttname"><a href="#a73051c3f6075d625c1a78ae6afd735c2">gf2::BitArray::previous_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_set(usize index) const</div><div class="ttdoc">Returns the index of the previous set bit before index in the bit-array or {} if there are none.</div><div class="ttdef"><b>Definition</b> BitArray.h:872</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2f70552ecd9a67ade70df35fc747bb03" name="a2f70552ecd9a67ade70df35fc747bb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f70552ecd9a67ade70df35fc747bb03">&#9670;&#160;</a></span>previous_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::previous_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-array or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-61"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;37, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(2, <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a>(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a>(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a>(2) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a2f70552ecd9a67ade70df35fc747bb03">previous_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a2f70552ecd9a67ade70df35fc747bb03"><div class="ttname"><a href="#a2f70552ecd9a67ade70df35fc747bb03">gf2::BitArray::previous_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_unset(usize index) const</div><div class="ttdoc">Returns the index of the previous unset bit before index in the bit-array or {} if no more unset bits...</div><div class="ttdef"><b>Definition</b> BitArray.h:942</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acfbd3d13cf6f1050b32fbd30054b8448" name="acfbd3d13cf6f1050b32fbd30054b8448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd3d13cf6f1050b32fbd30054b8448">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are picked at random. </p>
<p>The default call <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">BitArray</a>&lt;&gt;::<a class="el" href="#acfbd3d13cf6f1050b32fbd30054b8448" title="Factory method to generate a bit-array of size N where the elements are picked at random.">random()</a></span> produces a random bit-array with each bit being 1 with probability 0.5 and where the RNG is seeded from entropy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-array is all zeros, if <span class="tt">p &gt; 1</span> then the bit-array is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-27"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#acfbd3d13cf6f1050b32fbd30054b8448">BitArray&lt;10&gt;::random</a>(0.5, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#acfbd3d13cf6f1050b32fbd30054b8448">BitArray&lt;10&gt;::random</a>(0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_acfbd3d13cf6f1050b32fbd30054b8448"><div class="ttname"><a href="#acfbd3d13cf6f1050b32fbd30054b8448">gf2::BitArray::random</a></div><div class="ttdeci">static BitArray random(double p=0.5, u64 seed=0)</div><div class="ttdoc">Factory method to generate a bit-array of size N where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitArray.h:344</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a994126b6ffb6541fb5d240d44e521bf8" name="a994126b6ffb6541fb5d240d44e521bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994126b6ffb6541fb5d240d44e521bf8">&#9670;&#160;</a></span>riffled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the result of riffling the bits in this bit-array with zeros. </p>
<p>If the bit-array has the bits <span class="tt">abcde</span> then the output bit-vector will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-75"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line"><span class="keyword">auto</span> dst = v.<a class="code hl_function" href="#a23cc27cefe65bd9b7459b564cd007534">riffled</a>();</div>
<div class="line">assert_eq(dst.to_string(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a23cc27cefe65bd9b7459b564cd007534"><div class="ttname"><a href="#a23cc27cefe65bd9b7459b564cd007534">gf2::BitArray::riffled</a></div><div class="ttdeci">constexpr void riffled(BitVector&lt; word_type &gt; &amp;dst) const</div><div class="ttdoc">Interleaves the bits of this bit-array with zeros storing the result into the bit-vector dst.</div><div class="ttdef"><b>Definition</b> BitArray.h:1187</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23cc27cefe65bd9b7459b564cd007534" name="a23cc27cefe65bd9b7459b564cd007534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cc27cefe65bd9b7459b564cd007534">&#9670;&#160;</a></span>riffled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the bits of this bit-array with zeros storing the result into the bit-vector <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> will have the bits of this bit-array interleaved with zeros. For example, if this bit-array has the bits <span class="tt">abcde</span> then <span class="tt">dst</span> will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-74"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v; v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> dst;</div>
<div class="line">v.<a class="code hl_function" href="#a23cc27cefe65bd9b7459b564cd007534">riffled</a>(dst);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html"><div class="ttname"><a href="classgf2_1_1BitVector.html">gf2::BitVector</a></div><div class="ttdoc">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...</div><div class="ttdef"><b>Definition</b> BitVector.h:23</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad2b8ef3dc6d1ea250253135172bb48e7"><div class="ttname"><a href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">gf2::BitVector::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1820</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac3ce12d8dff51751e6434d1fa287b65c" name="ac3ce12d8dff51751e6434d1fa287b65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ce12d8dff51751e6434d1fa287b65c">&#9670;&#160;</a></span>seeded_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of size <span class="tt">N</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random bit-arrays, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-array is all zeros, if <span class="tt">p &gt; 1</span> then the bit-array is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-28"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ac3ce12d8dff51751e6434d1fa287b65c">BitArray&lt;10&gt;::seeded_random</a>(seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ac3ce12d8dff51751e6434d1fa287b65c">BitArray&lt;10&gt;::seeded_random</a>(seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ac3ce12d8dff51751e6434d1fa287b65c"><div class="ttname"><a href="#ac3ce12d8dff51751e6434d1fa287b65c">gf2::BitArray::seeded_random</a></div><div class="ttdeci">static BitArray seeded_random(u64 seed)</div><div class="ttdoc">Factory method to generate a bit-array of size N where the elements are from independent fair coin fl...</div><div class="ttdef"><b>Definition</b> BitArray.h:366</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a07520d5580bf502c10a4b5e53aa7d667" name="a07520d5580bf502c10a4b5e53aa7d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07520d5580bf502c10a4b5e53aa7d667">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-7"></a>
Panics</h1>
<p>In debug mode the index is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-34"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v[0], <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v[0], <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aab2791cfd5ff853058cc609a4d3b354c" name="aab2791cfd5ff853058cc609a4d3b354c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2791cfd5ff853058cc609a4d3b354c">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the bits in the bit-array to the boolean <span class="tt">value</span> and returns a reference to this for chaining. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-42"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a29841ea6a7a2723d17ed2f49df9ca5ba" name="a29841ea6a7a2723d17ed2f49df9ca5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29841ea6a7a2723d17ed2f49df9ca5ba">&#9670;&#160;</a></span>set_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::set_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-array. </p>
<p>You can use this iterator to iterate over the set bits in the bit-array and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-64"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.<a class="code hl_function" href="#a29841ea6a7a2723d17ed2f49df9ca5ba">set_bits</a>());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{0, 2, 4, 6, 8}));</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a29841ea6a7a2723d17ed2f49df9ca5ba"><div class="ttname"><a href="#a29841ea6a7a2723d17ed2f49df9ca5ba">gf2::BitArray::set_bits</a></div><div class="ttdeci">constexpr auto set_bits() const</div><div class="ttdoc">Returns an iterator over the indices of any set bits in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:991</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae9764d1b0853ec06b086499a3ab9d823" name="ae9764d1b0853ec06b086499a3ab9d823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9764d1b0853ec06b086499a3ab9d823">&#9670;&#160;</a></span>set_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::set_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets word <span class="tt">i</span> in the bit-array's underlying word store to <span class="tt">value</span> (masked if necessary). </p>
<p>The final word in the store may not be fully occupied but we ensure that unused bits remain set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="panics-1"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-13"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#ae9764d1b0853ec06b086499a3ab9d823">set_word</a>(1, 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000011&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aec2366220f35b59668ce49ee8900ecd3">count_ones</a>(), 2);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ae9764d1b0853ec06b086499a3ab9d823"><div class="ttname"><a href="#ae9764d1b0853ec06b086499a3ab9d823">gf2::BitArray::set_word</a></div><div class="ttdeci">constexpr void set_word(usize i, Word word)</div><div class="ttdoc">Sets word i in the bit-array&#39;s underlying word store to value (masked if necessary).</div><div class="ttdef"><b>Definition</b> BitArray.h:98</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7ad104649695be7a116b76eab3978b10" name="a7ad104649695be7a116b76eab3978b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad104649695be7a116b76eab3978b10">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bit-elements in the bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="example-10"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7ad104649695be7a116b76eab3978b10">size</a>(), 10);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e798dfeac46955832ea25062ad80523" name="a4e798dfeac46955832ea25062ad80523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e798dfeac46955832ea25062ad80523">&#9670;&#160;</a></span>span() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable bit-span encompassing the bit-array's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Mutability here is deep &ndash; the interior pointer in the returned span is to <em>non-const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-16"></a>
Panics</h1>
<p>This method panics if the span range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-70"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="#a5696c182958a4495cda1c3c1a10cbfd8">span</a>(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1111101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a5696c182958a4495cda1c3c1a10cbfd8"><div class="ttname"><a href="#a5696c182958a4495cda1c3c1a10cbfd8">gf2::BitArray::span</a></div><div class="ttdeci">constexpr auto span(usize begin, usize end) const</div><div class="ttdoc">Returns an immutable bit-span encompassing the bit-array&#39;s bits in the half-open range [begin,...</div><div class="ttdef"><b>Definition</b> BitArray.h:1075</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5696c182958a4495cda1c3c1a10cbfd8" name="a5696c182958a4495cda1c3c1a10cbfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5696c182958a4495cda1c3c1a10cbfd8">&#9670;&#160;</a></span>span() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <em>immutable</em> bit-span encompassing the bit-array's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Immutability here is deep &ndash; the interior pointer in the returned span is to <em>const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-15"></a>
Panics</h1>
<p>This method panics if the span range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-69"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="#a5696c182958a4495cda1c3c1a10cbfd8">span</a>(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8bfb334e59717269501038fc27192482" name="a8bfb334e59717269501038fc27192482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfb334e59717269501038fc27192482">&#9670;&#160;</a></span>split_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views the bit-array as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a7ad104649695be7a116b76eab3978b10" title="Returns the number of bit-elements in the bit-array.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are returned as a pair of bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>].</p>
<p>On return, <span class="tt">left</span> is a clone of the bits from the start of the bit-array up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-array. This bit-array itself is not modified.</p>
<h1 class="doxsection"><a class="anchor" id="panics-19"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-array.</p>
<h1 class="doxsection"><a class="anchor" id="example-73"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="keyword">auto</span> [left, right] = v.<a class="code hl_function" href="#ad780efa43f9e461bb5dd7bfda85529bc">split_at</a>(5);</div>
<div class="line">assert_eq(left.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.to_string(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_ad780efa43f9e461bb5dd7bfda85529bc"><div class="ttname"><a href="#ad780efa43f9e461bb5dd7bfda85529bc">gf2::BitArray::split_at</a></div><div class="ttdeci">constexpr void split_at(usize at, BitVector&lt; word_type &gt; &amp;left, BitVector&lt; word_type &gt; &amp;right) const</div><div class="ttdoc">Views the bit-array as two parts containing the elements [0, at) and [at, size()) respectively.</div><div class="ttdef"><b>Definition</b> BitArray.h:1144</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad780efa43f9e461bb5dd7bfda85529bc" name="ad780efa43f9e461bb5dd7bfda85529bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad780efa43f9e461bb5dd7bfda85529bc">&#9670;&#160;</a></span>split_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views the bit-array as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a7ad104649695be7a116b76eab3978b10" title="Returns the number of bit-elements in the bit-array.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>.</p>
<p>On return, <span class="tt">left</span> contains the bits from the start of the bit-array up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-array. This bit-array itself is not modified.</p>
<p>This lets one reuse the <span class="tt">left</span> and <span class="tt">right</span> destinations without having to allocate new bit-vectors. This is useful when implementing iterative algorithms that need to split a bit-array into two parts repeatedly.</p>
<h1 class="doxsection"><a class="anchor" id="panics-18"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-array.</p>
<h1 class="doxsection"><a class="anchor" id="example-72"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> left, right;</div>
<div class="line">v.<a class="code hl_function" href="#ad780efa43f9e461bb5dd7bfda85529bc">split_at</a>(5, left, right);</div>
<div class="line">assert_eq(left.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.<a class="code hl_function" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac2fe777c10a479db548f03e7dab14b0f" name="ac2fe777c10a479db548f03e7dab14b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fe777c10a479db548f03e7dab14b0f">&#9670;&#160;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word * <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying store of words. </p>
<p><b>Note:</b> The pointer is non-const but you should be careful about using it to modify the words in the store.</p>
<h1 class="doxsection"><a class="anchor" id="example-15"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line"><span class="keyword">auto</span> ptr = v.<a class="code hl_function" href="#aa4052a792e8bc521a5a0a99bd696f804">store</a>();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_aa4052a792e8bc521a5a0a99bd696f804"><div class="ttname"><a href="#aa4052a792e8bc521a5a0a99bd696f804">gf2::BitArray::store</a></div><div class="ttdeci">constexpr const Word * store() const</div><div class="ttdoc">Returns a const pointer to the underlying store of words .</div><div class="ttdef"><b>Definition</b> BitArray.h:115</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa4052a792e8bc521a5a0a99bd696f804" name="aa4052a792e8bc521a5a0a99bd696f804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4052a792e8bc521a5a0a99bd696f804">&#9670;&#160;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Word * <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the underlying store of words . </p>
<h1 class="doxsection"><a class="anchor" id="example-14"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line"><span class="keyword">auto</span> ptr = v.<a class="code hl_function" href="#aa4052a792e8bc521a5a0a99bd696f804">store</a>();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a12153716c09132e0920158ca213fe958" name="a12153716c09132e0920158ca213fe958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12153716c09132e0920158ca213fe958">&#9670;&#160;</a></span>store_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::store_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over all the <em>words</em> underlying the v. </p>
<p>You can use this iterator to iterate over the words in the bit-array and read the <span class="tt">Word</span> value of each word. You <b>cannot</b> use this iterator to modify the words in the store.</p>
<h1 class="doxsection"><a class="anchor" id="example-66"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a67ed2efa8a38a1bf3dbfc3d331806355">BitArray&lt;10, u8&gt;::ones</a>();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a> = std::ranges::to&lt;std::vector&gt;(v.store_words());</div>
<div class="line">assert_eq(<a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_afd6f73573f642499f95fe90639dc949f"><div class="ttname"><a href="#afd6f73573f642499f95fe90639dc949f">gf2::BitArray::words</a></div><div class="ttdeci">constexpr usize words() const</div><div class="ttdoc">Returns the number of words in the bit-array&#39;s underlying word store.</div><div class="ttdef"><b>Definition</b> BitArray.h:59</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1487ea33eae413fc582a77fb16e62fa7" name="a1487ea33eae413fc582a77fb16e62fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1487ea33eae413fc582a77fb16e62fa7">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-17"></a>
Panics</h1>
<p>This method panics if the range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-71"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line"><span class="keyword">auto</span> s = v.<a class="code hl_function" href="#a1487ea33eae413fc582a77fb16e62fa7">sub</a>(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a1487ea33eae413fc582a77fb16e62fa7"><div class="ttname"><a href="#a1487ea33eae413fc582a77fb16e62fa7">gf2::BitArray::sub</a></div><div class="ttdeci">constexpr auto sub(usize begin, usize end) const</div><div class="ttdoc">Returns a clone of the elements in the half-open range [begin, end) as a new bit-vector.</div><div class="ttdef"><b>Definition</b> BitArray.h:1115</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a88a6d06d4385f76d7b2de8c65cbe95e7" name="a88a6d06d4385f76d7b2de8c65cbe95e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6d06d4385f76d7b2de8c65cbe95e7">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bits in the bit-array at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-10"></a>
Panics</h1>
<p>In debug mode the indices are bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-37"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a88a6d06d4385f76d7b2de8c65cbe95e7">swap</a>(0, 1);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0100000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a88a6d06d4385f76d7b2de8c65cbe95e7">swap</a>(0, 1);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a88a6d06d4385f76d7b2de8c65cbe95e7">swap</a>(0, 9);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a88a6d06d4385f76d7b2de8c65cbe95e7">swap</a>(0, 9);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a88a6d06d4385f76d7b2de8c65cbe95e7"><div class="ttname"><a href="#a88a6d06d4385f76d7b2de8c65cbe95e7">gf2::BitArray::swap</a></div><div class="ttdeci">constexpr auto swap(usize i0, usize i1)</div><div class="ttdoc">Swaps the bits in the bit-array at indices i0 and i1 and returns this for chaining.</div><div class="ttdef"><b>Definition</b> BitArray.h:527</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aecc7e50f56ff23a9df63f6505daf5f7d" name="aecc7e50f56ff23a9df63f6505daf5f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc7e50f56ff23a9df63f6505daf5f7d">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-array. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-76"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aecc7e50f56ff23a9df63f6505daf5f7d">to_binary_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aecc7e50f56ff23a9df63f6505daf5f7d">to_binary_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aecc7e50f56ff23a9df63f6505daf5f7d">to_binary_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_aecc7e50f56ff23a9df63f6505daf5f7d"><div class="ttname"><a href="#aecc7e50f56ff23a9df63f6505daf5f7d">gf2::BitArray::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1223</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a58407dca6afa59df2174fec1c730ebd8" name="a58407dca6afa59df2174fec1c730ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58407dca6afa59df2174fec1c730ebd8">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "hex" string representation of the bits in the bit-array. </p>
<p>The output is a string of hex characters without any spaces, commas, or other formatting.</p>
<p>The string may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
 Empty bit-vectors are represented as the empty string.</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-array <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-array <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-array <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-array <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<p>The output is in <em>vector-order</em>. If "h0" is the first hex digit in the output string, you can print it as four binary digits <span class="tt">v_0v_1v_2v_3</span>. For example, if h0 = "A" which is <span class="tt">1010</span> in binary, then v = 1010.</p>
<h1 class="doxsection"><a class="anchor" id="example-79"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;0&gt;</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a58407dca6afa59df2174fec1c730ebd8">to_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;4&gt;</a> v1; v1.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v1.<a class="code hl_function" href="#a58407dca6afa59df2174fec1c730ebd8">to_hex_string</a>(), <span class="stringliteral">&quot;F&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;5&gt;</a> v2; v2.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v2.<a class="code hl_function" href="#a58407dca6afa59df2174fec1c730ebd8">to_hex_string</a>(), <span class="stringliteral">&quot;F1.2&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;8&gt;</a> v3;</div>
<div class="line">v3.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v3.<a class="code hl_function" href="#aecc7e50f56ff23a9df63f6505daf5f7d">to_binary_string</a>(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line">assert_eq(v3.<a class="code hl_function" href="#a58407dca6afa59df2174fec1c730ebd8">to_hex_string</a>(), <span class="stringliteral">&quot;AA&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a58407dca6afa59df2174fec1c730ebd8"><div class="ttname"><a href="#a58407dca6afa59df2174fec1c730ebd8">gf2::BitArray::to_hex_string</a></div><div class="ttdeci">std::string to_hex_string() const</div><div class="ttdoc">Returns the &quot;hex&quot; string representation of the bits in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1294</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6755c8905474c30b4b07186f5eeb593e" name="a6755c8905474c30b4b07186f5eeb593e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6755c8905474c30b4b07186f5eeb593e">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "pretty" string representation of the bit-array. </p>
<p>The output is a string of 0's and 1's with spaces between each bit, and the whole thing enclosed in square brackets.</p>
<h1 class="doxsection"><a class="anchor" id="example-78"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a6755c8905474c30b4b07186f5eeb593e">to_pretty_string</a>(), <span class="stringliteral">&quot;[1,0,1,0,1,0,1,0,1,0]&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitArray.html">BitArray&lt;0&gt;</a> empty;</div>
<div class="line">assert_eq(empty.<a class="code hl_function" href="#a6755c8905474c30b4b07186f5eeb593e">to_pretty_string</a>(), <span class="stringliteral">&quot;[]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a6755c8905474c30b4b07186f5eeb593e"><div class="ttname"><a href="#a6755c8905474c30b4b07186f5eeb593e">gf2::BitArray::to_pretty_string</a></div><div class="ttdeci">std::string to_pretty_string() const</div><div class="ttdoc">Returns a &quot;pretty&quot; string representation of the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1261</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7e7ba662c7a451fb55b1f64d29d013d1" name="a7e7ba662c7a451fb55b1f64d29d013d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7ba662c7a451fb55b1f64d29d013d1">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-array. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-77"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a0b33fa5dda7332b371911b27a662ed" name="a2a0b33fa5dda7332b371911b27a662ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0b33fa5dda7332b371911b27a662ed">&#9670;&#160;</a></span>to_words() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-array as a <span class="tt">std::vector&lt;<a class="el" href="#a82a5c674165737fe7c72832867734ea6" title="The underlying unsigned word type used to store the bits.">word_type</a>&gt;</span>. </p>
<p><b>Note:</b> The last word in the bit-array may not be fully occupied but unused slots will be all zeros.</p>
<h1 class="doxsection"><a class="anchor" id="example-68"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a67ed2efa8a38a1bf3dbfc3d331806355">BitArray&lt;10, u8&gt;::ones</a>();</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a> = v.to_words();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a80e2eec6b618e005b794c20bc5367458" name="a80e2eec6b618e005b794c20bc5367458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e2eec6b618e005b794c20bc5367458">&#9670;&#160;</a></span>to_words() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramtype">std::output_iterator&lt; <a class="el" href="#a82a5c674165737fe7c72832867734ea6">word_type</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-array and puts them into the passed output iterator. </p>
<h1 class="doxsection"><a class="anchor" id="note-9"></a>
Note</h1>
<ul>
<li>The last word in the bit-array may not be fully occupied but unused slots will be all zeros.</li>
<li>The output iterator must be able to accept values of the bit-arrays's <span class="tt"><a class="el" href="#a82a5c674165737fe7c72832867734ea6" title="The underlying unsigned word type used to store the bits.">word_type</a></span>.</li>
<li>The output iterator must have enough space to accept all the words in the bit-array.</li>
<li>If there is extra space in the output iterator, those extra slots are left unchanged.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-67"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a67ed2efa8a38a1bf3dbfc3d331806355">BitArray&lt;10, u8&gt;::ones</a>();</div>
<div class="line">std::vector&lt;u8&gt; out8(v.words());</div>
<div class="line">v.to_words(out8.begin());</div>
<div class="line">assert_eq(out8, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="line">std::vector&lt;u16&gt; out16(v.words());</div>
<div class="line">v.to_words(out16.begin());</div>
<div class="line">assert_eq(out16, (std::vector&lt;u16&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60c2d91492bfab341c5fa299884aef54" name="a60c2d91492bfab341c5fa299884aef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c2d91492bfab341c5fa299884aef54">&#9670;&#160;</a></span>trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::trailing_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in the bit-array. </p>
<h1 class="doxsection"><a class="anchor" id="example-53"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;27, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a60c2d91492bfab341c5fa299884aef54">trailing_zeros</a>(), 27);</div>
<div class="line">v.<a class="code hl_function" href="#a07520d5580bf502c10a4b5e53aa7d667">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a60c2d91492bfab341c5fa299884aef54">trailing_zeros</a>(), 26);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a60c2d91492bfab341c5fa299884aef54"><div class="ttname"><a href="#a60c2d91492bfab341c5fa299884aef54">gf2::BitArray::trailing_zeros</a></div><div class="ttdeci">constexpr usize trailing_zeros() const</div><div class="ttdoc">Returns the number of trailing zeros in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:808</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5af5e7878acfef3183ebe90ed51e5762" name="a5af5e7878acfef3183ebe90ed51e5762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af5e7878acfef3183ebe90ed51e5762">&#9670;&#160;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a "unit" bit-array of length <span class="tt">N</span> where only element <span class="tt">i</span> is set. </p>
<p>This method panics if the condition <span class="tt">i &lt; N</span> is not met.</p>
<h1 class="doxsection"><a class="anchor" id="example-21"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a5af5e7878acfef3183ebe90ed51e5762">BitArray&lt;10&gt;::unit</a>(0).<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a5af5e7878acfef3183ebe90ed51e5762">BitArray&lt;10&gt;::unit</a>(9).<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a5af5e7878acfef3183ebe90ed51e5762"><div class="ttname"><a href="#a5af5e7878acfef3183ebe90ed51e5762">gf2::BitArray::unit</a></div><div class="ttdeci">static constexpr BitArray unit(usize i)</div><div class="ttdoc">Factory method to generate a &quot;unit&quot; bit-array of length N where only element i is set.</div><div class="ttdef"><b>Definition</b> BitArray.h:209</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3d9e5783287dcffdc7f7479c5a017867" name="a3d9e5783287dcffdc7f7479c5a017867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9e5783287dcffdc7f7479c5a017867">&#9670;&#160;</a></span>unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::unset_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-array. </p>
<p>You can use this iterator to iterate over the unset bits in the bit-array and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-65"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a6bbfb8e5e1b435b698caf37e85f23173">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.<a class="code hl_function" href="#a3d9e5783287dcffdc7f7479c5a017867">unset_bits</a>());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{1, 3, 5, 7, 9}));</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a3d9e5783287dcffdc7f7479c5a017867"><div class="ttname"><a href="#a3d9e5783287dcffdc7f7479c5a017867">gf2::BitArray::unset_bits</a></div><div class="ttdeci">constexpr auto unset_bits() const</div><div class="ttdoc">Returns an iterator over the indices of any unset bits in the bit-array.</div><div class="ttdef"><b>Definition</b> BitArray.h:1005</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1f2ba699dc21d37cdcd955b3baa54a98" name="a1f2ba699dc21d37cdcd955b3baa54a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2ba699dc21d37cdcd955b3baa54a98">&#9670;&#160;</a></span>word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns word <span class="tt">i</span> from the bit-array's underlying word store. </p>
<p>The final word in the store may not be fully occupied but we guarantee that unused bits are set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="panics"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-12"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#aab2791cfd5ff853058cc609a4d3b354c">set_all</a>();</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7e7ba662c7a451fb55b1f64d29d013d1">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a>(), 2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a1f2ba699dc21d37cdcd955b3baa54a98">word</a>(0), 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a1f2ba699dc21d37cdcd955b3baa54a98">word</a>(1), 0b0000&#39;0011);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a1f2ba699dc21d37cdcd955b3baa54a98"><div class="ttname"><a href="#a1f2ba699dc21d37cdcd955b3baa54a98">gf2::BitArray::word</a></div><div class="ttdeci">constexpr Word word(usize i) const</div><div class="ttdoc">Returns word i from the bit-array&#39;s underlying word store.</div><div class="ttdef"><b>Definition</b> BitArray.h:78</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd6f73573f642499f95fe90639dc949f" name="afd6f73573f642499f95fe90639dc949f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6f73573f642499f95fe90639dc949f">&#9670;&#160;</a></span>words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words in the bit-array's underlying word store. </p>
<p>The bit-elements are packed into a standard array with this number of words.</p>
<h1 class="doxsection"><a class="anchor" id="example-11"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u8&gt;</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a>(), 2);</div>
<div class="line"><a class="code hl_function" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray&lt;10, u16&gt;</a> v1;</div>
<div class="line">assert_eq(v1.<a class="code hl_function" href="#afd6f73573f642499f95fe90639dc949f">words</a>(), 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a13f8f554ace87292834f608fb0751255" name="a13f8f554ace87292834f608fb0751255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f8f554ace87292834f608fb0751255">&#9670;&#160;</a></span>zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N, Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae52f2a1cd4ba693f95405eaa007b42fc">BitArray</a> <a class="el" href="classgf2_1_1BitArray.html">gf2::BitArray</a>&lt; N, Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-array of length <span class="tt">N</span> where the elements are all 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-18"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a13f8f554ace87292834f608fb0751255">BitArray&lt;10, u8&gt;::zeros</a>();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitArray_html_a13f8f554ace87292834f608fb0751255"><div class="ttname"><a href="#a13f8f554ace87292834f608fb0751255">gf2::BitArray::zeros</a></div><div class="ttdeci">static constexpr BitArray zeros()</div><div class="ttdoc">Factory method to generate a bit-array of length N where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitArray.h:178</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitArray.html">BitArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
