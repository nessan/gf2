<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitVector&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitVector.html','','classgf2_1_1BitVector-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitVector&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitVector_8h_source.html">BitVector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aca1c8345774c71accac5a29b6d79e166" id="r_aca1c8345774c71accac5a29b6d79e166"><td class="memItemLeft" align="right" valign="top"><a id="aca1c8345774c71accac5a29b6d79e166" name="aca1c8345774c71accac5a29b6d79e166"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_type</b> = Word</td></tr>
<tr class="memdesc:aca1c8345774c71accac5a29b6d79e166"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying unsigned word type used to store the bits. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Required BitStore Concept Methods:</div></td></tr>
<tr class="memitem:a8b10006eb120ea7fafdeecf68adb53cb" id="r_a8b10006eb120ea7fafdeecf68adb53cb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a> () const</td></tr>
<tr class="memdesc:a8b10006eb120ea7fafdeecf68adb53cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bit-elements in the bit-vector.  <br /></td></tr>
<tr class="memitem:a916cdd15c618a1a2eb2d58d47be5eaba" id="r_a916cdd15c618a1a2eb2d58d47be5eaba"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a> () const</td></tr>
<tr class="memdesc:a916cdd15c618a1a2eb2d58d47be5eaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words in the bit-vector's underlying word store.  <br /></td></tr>
<tr class="memitem:a94f28415157fbc4b4486555fe71b98bd" id="r_a94f28415157fbc4b4486555fe71b98bd"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f28415157fbc4b4486555fe71b98bd">word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a94f28415157fbc4b4486555fe71b98bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns word <span class="tt">i</span> from the bit-vector's underlying word store.  <br /></td></tr>
<tr class="memitem:ab3edaa3f54306e82e8190372e6e4d8f6" id="r_ab3edaa3f54306e82e8190372e6e4d8f6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3edaa3f54306e82e8190372e6e4d8f6">set_word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, Word <a class="el" href="#a94f28415157fbc4b4486555fe71b98bd">word</a>)</td></tr>
<tr class="memdesc:ab3edaa3f54306e82e8190372e6e4d8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets word <span class="tt">i</span> in the bit-vector's underlying word store to <span class="tt">value</span> (masked if necessary).  <br /></td></tr>
<tr class="memitem:a05813fe7456c3b44322f29f3a34cf7af" id="r_a05813fe7456c3b44322f29f3a34cf7af"><td class="memItemLeft" align="right" valign="top">constexpr const Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05813fe7456c3b44322f29f3a34cf7af">store</a> () const</td></tr>
<tr class="memdesc:a05813fe7456c3b44322f29f3a34cf7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the underlying store of words .  <br /></td></tr>
<tr class="memitem:a154c64cdbc79b290bf1eef9bc45ee945" id="r_a154c64cdbc79b290bf1eef9bc45ee945"><td class="memItemLeft" align="right" valign="top">constexpr Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a154c64cdbc79b290bf1eef9bc45ee945">store</a> ()</td></tr>
<tr class="memdesc:a154c64cdbc79b290bf1eef9bc45ee945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying store of words.  <br /></td></tr>
<tr class="memitem:a70b5a50e5a357fda36b9faa81eb0d270" id="r_a70b5a50e5a357fda36b9faa81eb0d270"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b5a50e5a357fda36b9faa81eb0d270">offset</a> () const</td></tr>
<tr class="memdesc:a70b5a50e5a357fda36b9faa81eb0d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bits) of the first bit in the bit-vector within the first word.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors:</div></td></tr>
<tr class="memitem:a14c3dd77166009bede404d9de9f20b7f" id="r_a14c3dd77166009bede404d9de9f20b7f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>=0)</td></tr>
<tr class="memdesc:a14c3dd77166009bede404d9de9f20b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-vector of length <span class="tt">n</span> with all the bit elements set to 0.  <br /></td></tr>
<tr class="memitem:a8087d3c3ace15adb9f1167ac2c58cd4f" id="r_a8087d3c3ace15adb9f1167ac2c58cd4f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8087d3c3ace15adb9f1167ac2c58cd4f">BitVector</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>, Word <a class="el" href="#a94f28415157fbc4b4486555fe71b98bd">word</a>)</td></tr>
<tr class="memdesc:a8087d3c3ace15adb9f1167ac2c58cd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-vector with <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a94f28415157fbc4b4486555fe71b98bd" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span>.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Size and Capacity:</div></td></tr>
<tr class="memitem:a4b9cffc16ebebe17e183311de0119d55" id="r_a4b9cffc16ebebe17e183311de0119d55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b9cffc16ebebe17e183311de0119d55">capacity</a> () const</td></tr>
<tr class="memdesc:a4b9cffc16ebebe17e183311de0119d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the bit-vector.  <br /></td></tr>
<tr class="memitem:a3c460bba89b8c439f20f0b4d5330932a" id="r_a3c460bba89b8c439f20f0b4d5330932a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c460bba89b8c439f20f0b4d5330932a">remaining_capacity</a> () const</td></tr>
<tr class="memdesc:a3c460bba89b8c439f20f0b4d5330932a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating.  <br /></td></tr>
<tr class="memitem:a5bf1540020eb0b155578832dcd535513" id="r_a5bf1540020eb0b155578832dcd535513"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf1540020eb0b155578832dcd535513">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a5bf1540020eb0b155578832dcd535513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the bit-vector's capacity as much as possible.  <br /></td></tr>
<tr class="memitem:ad77aa9ce9b0abde4d43bd7062ce2e9b4" id="r_ad77aa9ce9b0abde4d43bd7062ce2e9b4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad77aa9ce9b0abde4d43bd7062ce2e9b4">clear</a> ()</td></tr>
<tr class="memdesc:ad77aa9ce9b0abde4d43bd7062ce2e9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the bit-vector so <code><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>==0</code>.  <br /></td></tr>
<tr class="memitem:a9e43be056727a9fe0b684a54e5a796d3" id="r_a9e43be056727a9fe0b684a54e5a796d3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e43be056727a9fe0b684a54e5a796d3">resize</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a9e43be056727a9fe0b684a54e5a796d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the bit-vector so that its <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a></span> is <span class="tt">n</span>.  <br /></td></tr>
<tr class="memitem:a7f30b7ca6335493a4ac73d5a54fa4038" id="r_a7f30b7ca6335493a4ac73d5a54fa4038"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f30b7ca6335493a4ac73d5a54fa4038">clean</a> ()</td></tr>
<tr class="memdesc:a7f30b7ca6335493a4ac73d5a54fa4038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets any unused bits in the <em>last</em> occupied word to 0.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Push/pop Single Elements:</div></td></tr>
<tr class="memitem:ab1ec353b0b28d8f85f402b368883405e" id="r_ab1ec353b0b28d8f85f402b368883405e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ec353b0b28d8f85f402b368883405e">push</a> (bool b)</td></tr>
<tr class="memdesc:ab1ec353b0b28d8f85f402b368883405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a single bit <span class="tt">b</span> onto the bit-vector.  <br /></td></tr>
<tr class="memitem:a7cab0bece6d69e0d89ae7a4b866ed12b" id="r_a7cab0bece6d69e0d89ae7a4b866ed12b"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cab0bece6d69e0d89ae7a4b866ed12b">pop</a> ()</td></tr>
<tr class="memdesc:a7cab0bece6d69e0d89ae7a4b866ed12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last bit from the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Appending from Various Sources:</div></td></tr>
<tr class="memitem:aa9116014ea3e714e7c5017a90a5d7ace" id="r_aa9116014ea3e714e7c5017a90a5d7ace"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:aa9116014ea3e714e7c5017a90a5d7ace template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9116014ea3e714e7c5017a90a5d7ace">append</a> (Src src)</td></tr>
<tr class="memdesc:aa9116014ea3e714e7c5017a90a5d7ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from any unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a64765cc2f7743ebfb79a838462b673fc" id="r_a64765cc2f7743ebfb79a838462b673fc"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:a64765cc2f7743ebfb79a838462b673fc template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64765cc2f7743ebfb79a838462b673fc">append</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:a64765cc2f7743ebfb79a838462b673fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> <span class="tt">src</span> onto the end of the bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:aeece6f105e8885d642f5e02355d87766" id="r_aeece6f105e8885d642f5e02355d87766"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:aeece6f105e8885d642f5e02355d87766 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeece6f105e8885d642f5e02355d87766">append</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:aeece6f105e8885d642f5e02355d87766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from a <span class="tt">std::bitset</span> onto the end of the bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:a7b73a1d27f306f5b7fc3909f46ab6809" id="r_a7b73a1d27f306f5b7fc3909f46ab6809"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a> (char c, int base)</td></tr>
<tr class="memdesc:a7b73a1d27f306f5b7fc3909f46ab6809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:a95ad154ae65e3999bb24c7ad0e03db50" id="r_a95ad154ae65e3999bb24c7ad0e03db50"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ad154ae65e3999bb24c7ad0e03db50">append_hex_digit</a> (char c)</td></tr>
<tr class="memdesc:a95ad154ae65e3999bb24c7ad0e03db50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single hex digit character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Removing Elements:</div></td></tr>
<tr class="memitem:a1dbeafd75d30e211d688822448a5da03" id="r_a1dbeafd75d30e211d688822448a5da03"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dbeafd75d30e211d688822448a5da03">split_off</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at)</td></tr>
<tr class="memdesc:a1dbeafd75d30e211d688822448a5da03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a bit-vector into two at the given index, returning a new <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a></span>.  <br /></td></tr>
<tr class="memitem:a7f68ece23b962b527abf8adffb9eb8fd" id="r_a7f68ece23b962b527abf8adffb9eb8fd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f68ece23b962b527abf8adffb9eb8fd">split_off</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; Word &gt; &amp;dst)</td></tr>
<tr class="memdesc:a7f68ece23b962b527abf8adffb9eb8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a bit-vector into two at the given index, returning the second part in <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:a9908f2bf308fd4371d920aeea320a489" id="r_a9908f2bf308fd4371d920aeea320a489"><td class="memTemplParams" colspan="2">template&lt;Unsigned Dst = Word&gt; </td></tr>
<tr class="memitem:a9908f2bf308fd4371d920aeea320a489 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; Dst &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9908f2bf308fd4371d920aeea320a489">split_off_unsigned</a> ()</td></tr>
<tr class="memdesc:a9908f2bf308fd4371d920aeea320a489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Accessors:</div></td></tr>
<tr class="memitem:a4174ea457afc81234d769dcf75f1b4ac" id="r_a4174ea457afc81234d769dcf75f1b4ac"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4174ea457afc81234d769dcf75f1b4ac">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a4174ea457afc81234d769dcf75f1b4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a46aaf33f13e4b6d79467bdb33bc36db8" id="r_a46aaf33f13e4b6d79467bdb33bc36db8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46aaf33f13e4b6d79467bdb33bc36db8">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a46aaf33f13e4b6d79467bdb33bc36db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value of the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:abaed9cf3881b1064339ca246099cdce4" id="r_abaed9cf3881b1064339ca246099cdce4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaed9cf3881b1064339ca246099cdce4">front</a> () const</td></tr>
<tr class="memdesc:abaed9cf3881b1064339ca246099cdce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ae5e06517a282d17f1e2b914e66322538" id="r_ae5e06517a282d17f1e2b914e66322538"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5e06517a282d17f1e2b914e66322538">back</a> () const</td></tr>
<tr class="memdesc:ae5e06517a282d17f1e2b914e66322538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Mutators:</div></td></tr>
<tr class="memitem:a73c5c0d160af7ae95e495e1288f73440" id="r_a73c5c0d160af7ae95e495e1288f73440"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73c5c0d160af7ae95e495e1288f73440">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, bool value=true)</td></tr>
<tr class="memdesc:a73c5c0d160af7ae95e495e1288f73440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:a3db3b1c6d620553dc2d0084f81966cf2" id="r_a3db3b1c6d620553dc2d0084f81966cf2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3db3b1c6d620553dc2d0084f81966cf2">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a3db3b1c6d620553dc2d0084f81966cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "reference" to the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:ad5425d23c332a0170eb24b8242373ad0" id="r_ad5425d23c332a0170eb24b8242373ad0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5425d23c332a0170eb24b8242373ad0">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:ad5425d23c332a0170eb24b8242373ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining.  <br /></td></tr>
<tr class="memitem:abc6a83f3db17bdad733a606ec0c04f7e" id="r_abc6a83f3db17bdad733a606ec0c04f7e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc6a83f3db17bdad733a606ec0c04f7e">swap</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i0, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i1)</td></tr>
<tr class="memdesc:abc6a83f3db17bdad733a606ec0c04f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bits in the bit-vector at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Queries:</div></td></tr>
<tr class="memitem:a26c48c7ba8dc5dacdfe886a081641e0e" id="r_a26c48c7ba8dc5dacdfe886a081641e0e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26c48c7ba8dc5dacdfe886a081641e0e">is_empty</a> () const</td></tr>
<tr class="memdesc:a26c48c7ba8dc5dacdfe886a081641e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit-vector is empty, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ac47715a1879d7e80066ca121f21d381c" id="r_ac47715a1879d7e80066ca121f21d381c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac47715a1879d7e80066ca121f21d381c">any</a> () const</td></tr>
<tr class="memdesc:ac47715a1879d7e80066ca121f21d381c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if at least one bit in the bit-vector is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ae2e0b8b3f0dd29888976c9b8c8b92656" id="r_ae2e0b8b3f0dd29888976c9b8c8b92656"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e0b8b3f0dd29888976c9b8c8b92656">all</a> () const</td></tr>
<tr class="memdesc:ae2e0b8b3f0dd29888976c9b8c8b92656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all bits in the bit-vector are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ad35a4ea3c7e58752695053c532f70104" id="r_ad35a4ea3c7e58752695053c532f70104"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35a4ea3c7e58752695053c532f70104">none</a> () const</td></tr>
<tr class="memdesc:ad35a4ea3c7e58752695053c532f70104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no bits in the bit-vector are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Mutators:</div></td></tr>
<tr class="memitem:a930b70847fba4092fa8be14a40dce295" id="r_a930b70847fba4092fa8be14a40dce295"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930b70847fba4092fa8be14a40dce295">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:a930b70847fba4092fa8be14a40dce295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the bit-vector to the boolean <span class="tt">value</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:aff3b6b072f9c5c15a05fc994a178edaa" id="r_aff3b6b072f9c5c15a05fc994a178edaa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff3b6b072f9c5c15a05fc994a178edaa">flip_all</a> ()</td></tr>
<tr class="memdesc:aff3b6b072f9c5c15a05fc994a178edaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bits in the bit-vector and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Copying into the BitVector:</div></td></tr>
<tr class="memitem:a85e93ce5352f5a87bc23e767cbe90fd7" id="r_a85e93ce5352f5a87bc23e767cbe90fd7"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:a85e93ce5352f5a87bc23e767cbe90fd7 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e93ce5352f5a87bc23e767cbe90fd7">copy</a> (Src src)</td></tr>
<tr class="memdesc:a85e93ce5352f5a87bc23e767cbe90fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-vector. Returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a17d49ceb92c3f0693361beeb9ade123e" id="r_a17d49ceb92c3f0693361beeb9ade123e"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:a17d49ceb92c3f0693361beeb9ade123e template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d49ceb92c3f0693361beeb9ade123e">copy</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:a17d49ceb92c3f0693361beeb9ade123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to this <em>equal-sized</em> bit-vector and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a1eaf930a97194cd69fbdaf750395a4ca" id="r_a1eaf930a97194cd69fbdaf750395a4ca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:a1eaf930a97194cd69fbdaf750395a4ca template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eaf930a97194cd69fbdaf750395a4ca">copy</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a1eaf930a97194cd69fbdaf750395a4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from a <span class="tt">std::bitset</span> to this <em>equal-sized</em> bit-vector and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">BitVector Fills:</div></td></tr>
<tr class="memitem:a572e1db2772a17233392d8329dbf29b5" id="r_a572e1db2772a17233392d8329dbf29b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572e1db2772a17233392d8329dbf29b5">copy</a> (std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a572e1db2772a17233392d8329dbf29b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the bit-vector by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:aa04714ab255021c1a38adbe375099f26" id="r_aa04714ab255021c1a38adbe375099f26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa04714ab255021c1a38adbe375099f26">fill_random</a> (double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:aa04714ab255021c1a38adbe375099f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the bit-vector with random bits and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts:</div></td></tr>
<tr class="memitem:ac2d2d233519d4c7531ceb2be692eae3d" id="r_ac2d2d233519d4c7531ceb2be692eae3d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d2d233519d4c7531ceb2be692eae3d">count_ones</a> () const</td></tr>
<tr class="memdesc:ac2d2d233519d4c7531ceb2be692eae3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in the bit-vector.  <br /></td></tr>
<tr class="memitem:acdc8cf20785c6091f60dfb2498a69316" id="r_acdc8cf20785c6091f60dfb2498a69316"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc8cf20785c6091f60dfb2498a69316">count_zeros</a> () const</td></tr>
<tr class="memdesc:acdc8cf20785c6091f60dfb2498a69316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in the bit-vector.  <br /></td></tr>
<tr class="memitem:a3c810f15c19034ff0fb20cc8bd038616" id="r_a3c810f15c19034ff0fb20cc8bd038616"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c810f15c19034ff0fb20cc8bd038616">leading_zeros</a> () const</td></tr>
<tr class="memdesc:a3c810f15c19034ff0fb20cc8bd038616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in the bit-vector.  <br /></td></tr>
<tr class="memitem:a1d68c1882ed92a0d9731f3c4990a9e56" id="r_a1d68c1882ed92a0d9731f3c4990a9e56"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d68c1882ed92a0d9731f3c4990a9e56">trailing_zeros</a> () const</td></tr>
<tr class="memdesc:a1d68c1882ed92a0d9731f3c4990a9e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in the bit-vector.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Set-bit Indices:</div></td></tr>
<tr class="memitem:a7880bbbf06f4ee31d9baf2d6bfa61d03" id="r_a7880bbbf06f4ee31d9baf2d6bfa61d03"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7880bbbf06f4ee31d9baf2d6bfa61d03">first_set</a> () const</td></tr>
<tr class="memdesc:a7880bbbf06f4ee31d9baf2d6bfa61d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in the bit-vector or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:a0623e155d7ddf9d08f64d3eee6e7aec3" id="r_a0623e155d7ddf9d08f64d3eee6e7aec3"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0623e155d7ddf9d08f64d3eee6e7aec3">last_set</a> () const</td></tr>
<tr class="memdesc:a0623e155d7ddf9d08f64d3eee6e7aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last set bit in the bit-vector or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:aa6f8f81db958c9e0b6749b0e1c05a974" id="r_aa6f8f81db958c9e0b6749b0e1c05a974"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f8f81db958c9e0b6749b0e1c05a974">next_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:aa6f8f81db958c9e0b6749b0e1c05a974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next set bit after <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more set bits exist.  <br /></td></tr>
<tr class="memitem:a8a1df02604e2457c56c4de2a9d00c5c3" id="r_a8a1df02604e2457c56c4de2a9d00c5c3"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a1df02604e2457c56c4de2a9d00c5c3">previous_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a8a1df02604e2457c56c4de2a9d00c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous set bit before <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Unset-bit Indices:</div></td></tr>
<tr class="memitem:ad5801c5e4bad14d86cfa9276e0e1229c" id="r_ad5801c5e4bad14d86cfa9276e0e1229c"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5801c5e4bad14d86cfa9276e0e1229c">first_unset</a> () const</td></tr>
<tr class="memdesc:ad5801c5e4bad14d86cfa9276e0e1229c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first unset bit in the bit-vector or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:ad820bf33df2faff7cc700824b370d864" id="r_ad820bf33df2faff7cc700824b370d864"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad820bf33df2faff7cc700824b370d864">last_unset</a> () const</td></tr>
<tr class="memdesc:ad820bf33df2faff7cc700824b370d864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last unset bit in the bit-vector or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:aa6ec1590bad64a8ff835918eed8afb50" id="r_aa6ec1590bad64a8ff835918eed8afb50"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6ec1590bad64a8ff835918eed8afb50">next_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:aa6ec1590bad64a8ff835918eed8afb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next unset bit after <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr class="memitem:a9000a2348948286e3d12eacaa5948ff6" id="r_a9000a2348948286e3d12eacaa5948ff6"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9000a2348948286e3d12eacaa5948ff6">previous_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a9000a2348948286e3d12eacaa5948ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Iterators:</div></td></tr>
<tr class="memitem:a899931f1989b4af7ee2ad2bdef3684b3" id="r_a899931f1989b4af7ee2ad2bdef3684b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a899931f1989b4af7ee2ad2bdef3684b3">bits</a> () const</td></tr>
<tr class="memdesc:a899931f1989b4af7ee2ad2bdef3684b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-vector.  <br /></td></tr>
<tr class="memitem:a05d4d7648a2190f143ecc316d83383b5" id="r_a05d4d7648a2190f143ecc316d83383b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05d4d7648a2190f143ecc316d83383b5">bits</a> ()</td></tr>
<tr class="memdesc:a05d4d7648a2190f143ecc316d83383b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const iterator over the values of the bits in the mutable bit-vector.  <br /></td></tr>
<tr class="memitem:a4679323bfd87481db46124b8533d7bf4" id="r_a4679323bfd87481db46124b8533d7bf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4679323bfd87481db46124b8533d7bf4">set_bits</a> () const</td></tr>
<tr class="memdesc:a4679323bfd87481db46124b8533d7bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-vector.  <br /></td></tr>
<tr class="memitem:a15d5236d2ad3e82c208ee262e67ef893" id="r_a15d5236d2ad3e82c208ee262e67ef893"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d5236d2ad3e82c208ee262e67ef893">unset_bits</a> () const</td></tr>
<tr class="memdesc:a15d5236d2ad3e82c208ee262e67ef893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-vector.  <br /></td></tr>
<tr class="memitem:aedb09244ec466632c6e1d0d2a5e877b0" id="r_aedb09244ec466632c6e1d0d2a5e877b0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb09244ec466632c6e1d0d2a5e877b0">store_words</a> () const</td></tr>
<tr class="memdesc:aedb09244ec466632c6e1d0d2a5e877b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over all the <em>words</em> underlying the bit-vector.  <br /></td></tr>
<tr class="memitem:ac1d9fee2e247cb1792314cb96a811c90" id="r_ac1d9fee2e247cb1792314cb96a811c90"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1d9fee2e247cb1792314cb96a811c90">to_words</a> () const</td></tr>
<tr class="memdesc:ac1d9fee2e247cb1792314cb96a811c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-vector.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Spans:</div></td></tr>
<tr class="memitem:a0afbe86b05c12a2a7a7d69ac519035ea" id="r_a0afbe86b05c12a2a7a7d69ac519035ea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afbe86b05c12a2a7a7d69ac519035ea">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a0afbe86b05c12a2a7a7d69ac519035ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <em>immutable</em> bit-span encompassing the bit-vector's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr class="memitem:afec09f80547d2a38c78beddb574159bc" id="r_afec09f80547d2a38c78beddb574159bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec09f80547d2a38c78beddb574159bc">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:afec09f80547d2a38c78beddb574159bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable bit-span encompassing the bit-vector's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-vectors:</div></td></tr>
<tr class="memitem:a07fe4a8c5bf228f595f7612c23911970" id="r_a07fe4a8c5bf228f595f7612c23911970"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07fe4a8c5bf228f595f7612c23911970">sub</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a07fe4a8c5bf228f595f7612c23911970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector.  <br /></td></tr>
<tr id="pub-methods-18" class="groupHeader"><td colspan="2"><div class="groupHeader">Splits:</div></td></tr>
<tr class="memitem:a6e2078e3f40d295f483d87a09d26a92f" id="r_a6e2078e3f40d295f483d87a09d26a92f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2078e3f40d295f483d87a09d26a92f">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;left, <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;right) const</td></tr>
<tr class="memdesc:a6e2078e3f40d295f483d87a09d26a92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views the bit-vector as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively.  <br /></td></tr>
<tr class="memitem:a8d1a537cc0ee85444e008ce3aec4c318" id="r_a8d1a537cc0ee85444e008ce3aec4c318"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d1a537cc0ee85444e008ce3aec4c318">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at) const</td></tr>
<tr class="memdesc:a8d1a537cc0ee85444e008ce3aec4c318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views the bit-vector as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively.  <br /></td></tr>
<tr id="pub-methods-19" class="groupHeader"><td colspan="2"><div class="groupHeader">Riffling:</div></td></tr>
<tr class="memitem:ad33314f6e953a6808a2303bc9a755a3b" id="r_ad33314f6e953a6808a2303bc9a755a3b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33314f6e953a6808a2303bc9a755a3b">riffled</a> (<a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;dst) const</td></tr>
<tr class="memdesc:ad33314f6e953a6808a2303bc9a755a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the bits of this bit-vector with zeros storing the result into the bit-vector <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:a63d0494abd47378b45d9d4a6e8ff01ff" id="r_a63d0494abd47378b45d9d4a6e8ff01ff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d0494abd47378b45d9d4a6e8ff01ff">riffled</a> () const</td></tr>
<tr class="memdesc:a63d0494abd47378b45d9d4a6e8ff01ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the result of riffling the bits in this bit-vector with zeros.  <br /></td></tr>
<tr id="pub-methods-20" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations:</div></td></tr>
<tr class="memitem:a7cc78c5e7773c30d8da8916af258d081" id="r_a7cc78c5e7773c30d8da8916af258d081"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:a7cc78c5e7773c30d8da8916af258d081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-vector.  <br /></td></tr>
<tr class="memitem:ad2b8ef3dc6d1ea250253135172bb48e7" id="r_ad2b8ef3dc6d1ea250253135172bb48e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:ad2b8ef3dc6d1ea250253135172bb48e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the bit-vector.  <br /></td></tr>
<tr class="memitem:aebf24ce533ec44f83c83105b55a3b5e3" id="r_aebf24ce533ec44f83c83105b55a3b5e3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf24ce533ec44f83c83105b55a3b5e3">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:aebf24ce533ec44f83c83105b55a3b5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "pretty" string representation of the bit-vector.  <br /></td></tr>
<tr class="memitem:afec1640c73d1be249030207fcd061ab1" id="r_afec1640c73d1be249030207fcd061ab1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec1640c73d1be249030207fcd061ab1">to_hex_string</a> () const</td></tr>
<tr class="memdesc:afec1640c73d1be249030207fcd061ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "hex" string representation of the bits in the bit-vector.  <br /></td></tr>
<tr class="memitem:a97a032fc7468f702c0a428c1eddad8dd" id="r_a97a032fc7468f702c0a428c1eddad8dd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97a032fc7468f702c0a428c1eddad8dd">describe</a> () const</td></tr>
<tr class="memdesc:a97a032fc7468f702c0a428c1eddad8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multi-line string describing the bit-vector in some detail.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Factory Constructors:</div></td></tr>
<tr class="memitem:a214dd0c738e0a17e8d6afda0c55b5962" id="r_a214dd0c738e0a17e8d6afda0c55b5962"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a214dd0c738e0a17e8d6afda0c55b5962">with_capacity</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a4b9cffc16ebebe17e183311de0119d55">capacity</a>)</td></tr>
<tr class="memdesc:a214dd0c738e0a17e8d6afda0c55b5962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct an empty bit-vector with at least the specified capacity.  <br /></td></tr>
<tr class="memitem:a66ff1e24db7bf631af2d638dd0b620c1" id="r_a66ff1e24db7bf631af2d638dd0b620c1"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ff1e24db7bf631af2d638dd0b620c1">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a66ff1e24db7bf631af2d638dd0b620c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 0.  <br /></td></tr>
<tr class="memitem:abcfb7a88f30c8faa177519571a76ba8d" id="r_abcfb7a88f30c8faa177519571a76ba8d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfb7a88f30c8faa177519571a76ba8d">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:abcfb7a88f30c8faa177519571a76ba8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 1.  <br /></td></tr>
<tr class="memitem:a6772a3f88ec78ec6d26ee559d2e20e7f" id="r_a6772a3f88ec78ec6d26ee559d2e20e7f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6772a3f88ec78ec6d26ee559d2e20e7f">constant</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, bool value)</td></tr>
<tr class="memdesc:a6772a3f88ec78ec6d26ee559d2e20e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are set to <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a3be06c38681e26a2e4695c90f2edf9c7" id="r_a3be06c38681e26a2e4695c90f2edf9c7"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be06c38681e26a2e4695c90f2edf9c7">unit</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a3be06c38681e26a2e4695c90f2edf9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a "unit" bit-vector of length <span class="tt">n</span> where only element <span class="tt">i</span> is set.  <br /></td></tr>
<tr class="memitem:aeed3a5c646dbc7c38b4298574734ae4a" id="r_aeed3a5c646dbc7c38b4298574734ae4a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeed3a5c646dbc7c38b4298574734ae4a">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:aeed3a5c646dbc7c38b4298574734ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> looking like <span class="tt">101010...</span>.  <br /></td></tr>
<tr class="memitem:a3f33e12942bab8d475697297db924cb0" id="r_a3f33e12942bab8d475697297db924cb0"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:a3f33e12942bab8d475697297db924cb0 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f33e12942bab8d475697297db924cb0">from</a> (Src src)</td></tr>
<tr class="memdesc:a3f33e12942bab8d475697297db924cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance. The resulting bit-vector will have the same size as the number of bits in the <span class="tt">src</span> unsigned integer.  <br /></td></tr>
<tr class="memitem:ae8fa389c41966681f7208c58ed8efde7" id="r_ae8fa389c41966681f7208c58ed8efde7"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:ae8fa389c41966681f7208c58ed8efde7 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8fa389c41966681f7208c58ed8efde7">from</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:ae8fa389c41966681f7208c58ed8efde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> other bit-store instance.  <br /></td></tr>
<tr class="memitem:ac7a041a322468b8465f0f5a66d93467e" id="r_ac7a041a322468b8465f0f5a66d93467e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:ac7a041a322468b8465f0f5a66d93467e template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a041a322468b8465f0f5a66d93467e">from</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:ac7a041a322468b8465f0f5a66d93467e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from the bits of a <span class="tt">std::bitset</span>.  <br /></td></tr>
<tr class="memitem:a146f71d85f944143c73ee666c66c878b" id="r_a146f71d85f944143c73ee666c66c878b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a146f71d85f944143c73ee666c66c878b">from</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>, std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a146f71d85f944143c73ee666c66c878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a>)</span>.  <br /></td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructor BitVectors with Random Fills:</div></td></tr>
<tr class="memitem:a4b7006134bcff1ddfc81bcc8133dd3cc" id="r_a4b7006134bcff1ddfc81bcc8133dd3cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7006134bcff1ddfc81bcc8133dd3cc">random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>, double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:a4b7006134bcff1ddfc81bcc8133dd3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are picked at random.  <br /></td></tr>
<tr class="memitem:adaced7a7dcdc71fa7ac67f2fefb5553c" id="r_adaced7a7dcdc71fa7ac67f2fefb5553c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaced7a7dcdc71fa7ac67f2fefb5553c">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed)</td></tr>
<tr class="memdesc:adaced7a7dcdc71fa7ac67f2fefb5553c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a1b2b8c3a489d9c5c88d51b90008bacf3" id="r_a1b2b8c3a489d9c5c88d51b90008bacf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b2b8c3a489d9c5c88d51b90008bacf3">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>, double p)</td></tr>
<tr class="memdesc:a1b2b8c3a489d9c5c88d51b90008bacf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr id="pub-static-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors from Strings:</div></td></tr>
<tr class="memitem:a17ba4f50de43f5e84ef3943ad77410ea" id="r_a17ba4f50de43f5e84ef3943ad77410ea"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17ba4f50de43f5e84ef3943ad77410ea">from_string</a> (std::string_view sv)</td></tr>
<tr class="memdesc:a17ba4f50de43f5e84ef3943ad77410ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a string <span class="tt">s</span>, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
<tr class="memitem:a193a2ffb36fa664bbdbfe057f4f491d2" id="r_a193a2ffb36fa664bbdbfe057f4f491d2"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193a2ffb36fa664bbdbfe057f4f491d2">from_binary_string</a> (std::string_view sv, bool no_punctuation=false)</td></tr>
<tr class="memdesc:a193a2ffb36fa664bbdbfe057f4f491d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a binary string, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
<tr class="memitem:a94bc956ed38b656c83518854999bc5f1" id="r_a94bc956ed38b656c83518854999bc5f1"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94bc956ed38b656c83518854999bc5f1">from_hex_string</a> (std::string_view sv, bool no_punctuation=false)</td></tr>
<tr class="memdesc:a94bc956ed38b656c83518854999bc5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a hex string, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3cbeeb0747083f5c6d9ce1a45233ab2b" id="r_a3cbeeb0747083f5c6d9ce1a45233ab2b"><td class="memItemLeft" align="right" valign="top"><a id="a3cbeeb0747083f5c6d9ce1a45233ab2b" name="a3cbeeb0747083f5c6d9ce1a45233ab2b"></a>
static constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bits_per_word</b> = <a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Word&gt;</td></tr>
<tr class="memdesc:a3cbeeb0747083f5c6d9ce1a45233ab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits per <span class="tt">Word</span>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word = usize&gt;<br />
class gf2::BitVector&lt; Word &gt;</div><p>A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. </p>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a></span> class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> concept. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a14c3dd77166009bede404d9de9f20b7f" name="a14c3dd77166009bede404d9de9f20b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c3dd77166009bede404d9de9f20b7f">&#9670;&#160;</a></span>BitVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::BitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-vector of length <span class="tt">n</span> with all the bit elements set to 0. </p>
<p><b>Note:</b> The default constructor returns the empty bit-vector with no elements.</p>
<h1 class="doxsection"><a class="anchor" id="example-382"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> u;</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a14c3dd77166009bede404d9de9f20b7f"><div class="ttname"><a href="#a14c3dd77166009bede404d9de9f20b7f">gf2::BitVector::BitVector</a></div><div class="ttdeci">constexpr BitVector(usize size=0)</div><div class="ttdoc">Constructs a bit-vector of length n with all the bit elements set to 0.</div><div class="ttdef"><b>Definition</b> BitVector.h:150</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad2b8ef3dc6d1ea250253135172bb48e7"><div class="ttname"><a href="#ad2b8ef3dc6d1ea250253135172bb48e7">gf2::BitVector::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1716</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8087d3c3ace15adb9f1167ac2c58cd4f" name="a8087d3c3ace15adb9f1167ac2c58cd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087d3c3ace15adb9f1167ac2c58cd4f">&#9670;&#160;</a></span>BitVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::BitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-vector with <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a94f28415157fbc4b4486555fe71b98bd" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span>. </p>
<p>You specify the <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> of the bit-vector which means the final copy of <span class="tt"><a class="el" href="#a94f28415157fbc4b4486555fe71b98bd" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span> may be truncated and padded with zeros (unused bit slots are always set to zero in this library).</p>
<h1 class="doxsection"><a class="anchor" id="example-383"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> v{10, <a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0101&#39;0101}};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>(), 10);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a8b10006eb120ea7fafdeecf68adb53cb"><div class="ttname"><a href="#a8b10006eb120ea7fafdeecf68adb53cb">gf2::BitVector::size</a></div><div class="ttdeci">constexpr usize size() const</div><div class="ttdoc">Returns the number of bit-elements in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:50</div></div>
<div class="ttc" id="anamespacegf2_html_a872a69469085fcdddf299ae4adc3c940"><div class="ttname"><a href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">gf2::u8</a></div><div class="ttdeci">std::uint8_t u8</div><div class="ttdoc">Word type alias for an 8-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:30</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae2e0b8b3f0dd29888976c9b8c8b92656" name="ae2e0b8b3f0dd29888976c9b8c8b92656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e0b8b3f0dd29888976c9b8c8b92656">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all bits in the bit-vector are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-vectors have no set bits (logical connective for <span class="tt"><a class="el" href="#ae2e0b8b3f0dd29888976c9b8c8b92656" title="Returns true if all bits in the bit-vector are set, false otherwise.">all</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-423"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{3};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ae2e0b8b3f0dd29888976c9b8c8b92656">all</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(1);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ae2e0b8b3f0dd29888976c9b8c8b92656">all</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a73c5c0d160af7ae95e495e1288f73440"><div class="ttname"><a href="#a73c5c0d160af7ae95e495e1288f73440">gf2::BitVector::set</a></div><div class="ttdeci">constexpr auto set(usize i, bool value=true)</div><div class="ttdoc">Sets the bit-element i to the specified boolean value &amp; returns this for chaining....</div><div class="ttdef"><b>Definition</b> BitVector.h:984</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ae2e0b8b3f0dd29888976c9b8c8b92656"><div class="ttname"><a href="#ae2e0b8b3f0dd29888976c9b8c8b92656">gf2::BitVector::all</a></div><div class="ttdeci">constexpr bool all() const</div><div class="ttdoc">Returns true if all bits in the bit-vector are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVector.h:1097</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeed3a5c646dbc7c38b4298574734ae4a" name="aeed3a5c646dbc7c38b4298574734ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed3a5c646dbc7c38b4298574734ae4a">&#9670;&#160;</a></span>alternating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> looking like <span class="tt">101010...</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-389"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10).<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aeed3a5c646dbc7c38b4298574734ae4a"><div class="ttname"><a href="#aeed3a5c646dbc7c38b4298574734ae4a">gf2::BitVector::alternating</a></div><div class="ttdeci">static constexpr BitVector alternating(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n looking like 101010....</div><div class="ttdef"><b>Definition</b> BitVector.h:239</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac47715a1879d7e80066ca121f21d381c" name="ac47715a1879d7e80066ca121f21d381c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47715a1879d7e80066ca121f21d381c">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if at least one bit in the bit-vector is set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-vectors have no set bits (logical connective for <span class="tt"><a class="el" href="#ac47715a1879d7e80066ca121f21d381c" title="Returns true if at least one bit in the bit-vector is set, false otherwise.">any</a></span> is <span class="tt">OR</span> with identity <span class="tt">false</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-422"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac47715a1879d7e80066ca121f21d381c">any</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac47715a1879d7e80066ca121f21d381c">any</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ac47715a1879d7e80066ca121f21d381c"><div class="ttname"><a href="#ac47715a1879d7e80066ca121f21d381c">gf2::BitVector::any</a></div><div class="ttdeci">constexpr bool any() const</div><div class="ttdoc">Returns true if at least one bit in the bit-vector is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVector.h:1082</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a64765cc2f7743ebfb79a838462b673fc" name="a64765cc2f7743ebfb79a838462b673fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64765cc2f7743ebfb79a838462b673fc">&#9670;&#160;</a></span>append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> <span class="tt">src</span> onto the end of the bit-vector and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-31"></a>
Note</h1>
<p>Generally, we do not support interactions between bit-stores that use different underlying unsigned word types. This method is an exception, and the <span class="tt">src</span> bit-store may use a different unsigned type from the one used here.</p>
<h1 class="doxsection"><a class="anchor" id="example-407"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u16&gt;::ones</a>(10);</div>
<div class="line">v.append(w);</div>
<div class="line">assert_eq(v.size(), 20);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;00000000001111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a66ff1e24db7bf631af2d638dd0b620c1"><div class="ttname"><a href="#a66ff1e24db7bf631af2d638dd0b620c1">gf2::BitVector::zeros</a></div><div class="ttdeci">static constexpr BitVector zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVector.h:196</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_abcfb7a88f30c8faa177519571a76ba8d"><div class="ttname"><a href="#abcfb7a88f30c8faa177519571a76ba8d">gf2::BitVector::ones</a></div><div class="ttdeci">static constexpr BitVector ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVector.h:204</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9116014ea3e714e7c5017a90a5d7ace" name="aa9116014ea3e714e7c5017a90a5d7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9116014ea3e714e7c5017a90a5d7ace">&#9670;&#160;</a></span>append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from any unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining. </p>
<p><b>Note:</b> We allow <em>any</em> unsigned integral source, e.g. appending a single <span class="tt"><a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-406"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(4);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">v.append(src);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;11110101010101010101&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u32&gt;::ones</a>(4);</div>
<div class="line">w.append(src);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;11110101010101010101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ae858164ae3b877b1f9ea2606fae215a0"><div class="ttname"><a href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">gf2::u16</a></div><div class="ttdeci">std::uint16_t u16</div><div class="ttdoc">Word type alias for a 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeece6f105e8885d642f5e02355d87766" name="aeece6f105e8885d642f5e02355d87766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeece6f105e8885d642f5e02355d87766">&#9670;&#160;</a></span>append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from a <span class="tt">std::bitset</span> onto the end of the bit-vector and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-408"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#aa9116014ea3e714e7c5017a90a5d7ace">append</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html"><div class="ttname"><a href="classgf2_1_1BitVector.html">gf2::BitVector</a></div><div class="ttdoc">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...</div><div class="ttdef"><b>Definition</b> BitVector.h:23</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aa9116014ea3e714e7c5017a90a5d7ace"><div class="ttname"><a href="#aa9116014ea3e714e7c5017a90a5d7ace">gf2::BitVector::append</a></div><div class="ttdeci">auto append(Src src)</div><div class="ttdoc">Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...</div><div class="ttdef"><b>Definition</b> BitVector.h:680</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7b73a1d27f306f5b7fc3909f46ab6809" name="a7b73a1d27f306f5b7fc3909f46ab6809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b73a1d27f306f5b7fc3909f46ab6809">&#9670;&#160;</a></span>append_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::append_digit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining. </p>
<p>The character is interpreted as a base <span class="tt">base</span> number where<span class="tt">base</span> must be one of 2, 4, 8, 16.</p>
<p><b>Note:</b> This method does nothing if the base or character is not recognized.</p>
<h1 class="doxsection"><a class="anchor" id="example-409"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a>(<span class="charliteral">&#39;A&#39;</span>, 16);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a>(<span class="charliteral">&#39;X&#39;</span>, 16);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 8);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010001&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 4);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;101000101&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a7b73a1d27f306f5b7fc3909f46ab6809">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010001011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a7b73a1d27f306f5b7fc3909f46ab6809"><div class="ttname"><a href="#a7b73a1d27f306f5b7fc3909f46ab6809">gf2::BitVector::append_digit</a></div><div class="ttdeci">constexpr BitVector &amp; append_digit(char c, int base)</div><div class="ttdoc">Appends a single character c onto the end of bit-vector and returns this for chaining.</div><div class="ttdef"><b>Definition</b> BitVector.h:746</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a95ad154ae65e3999bb24c7ad0e03db50" name="a95ad154ae65e3999bb24c7ad0e03db50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ad154ae65e3999bb24c7ad0e03db50">&#9670;&#160;</a></span>append_hex_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::append_hex_digit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single hex digit character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining. </p>
<p><b>Note:</b> This method does nothing if the character is not a hex digit.</p>
<p>This is the same as <span class="tt">append_digit(c, 16)</span> but we push hex digits more often than other bases and want to skip some checks for efficiency.</p>
<h1 class="doxsection"><a class="anchor" id="example-410"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a95ad154ae65e3999bb24c7ad0e03db50">append_hex_digit</a>(<span class="charliteral">&#39;F&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a95ad154ae65e3999bb24c7ad0e03db50">append_hex_digit</a>(<span class="charliteral">&#39;X&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a95ad154ae65e3999bb24c7ad0e03db50">append_hex_digit</a>(<span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;11110001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a95ad154ae65e3999bb24c7ad0e03db50"><div class="ttname"><a href="#a95ad154ae65e3999bb24c7ad0e03db50">gf2::BitVector::append_hex_digit</a></div><div class="ttdeci">constexpr BitVector &amp; append_hex_digit(char c)</div><div class="ttdoc">Appends a single hex digit character c onto the end of bit-vector and returns this for chaining.</div><div class="ttdef"><b>Definition</b> BitVector.h:780</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae5e06517a282d17f1e2b914e66322538" name="ae5e06517a282d17f1e2b914e66322538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e06517a282d17f1e2b914e66322538">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-123"></a>
Panics</h1>
<p>In debug mode the method panics of the store is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-416"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.back(), <span class="keyword">true</span>);</div>
<div class="line">v.set_all(<span class="keyword">false</span>);</div>
<div class="line">assert_eq(v.back(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1b2b8c3a489d9c5c88d51b90008bacf3" name="a1b2b8c3a489d9c5c88d51b90008bacf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2b8c3a489d9c5c88d51b90008bacf3">&#9670;&#160;</a></span>biased_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-396"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a1b2b8c3a489d9c5c88d51b90008bacf3">BitVector&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a1b2b8c3a489d9c5c88d51b90008bacf3">BitVector&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line">assert_eq(u.size(), v.size());</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a1b2b8c3a489d9c5c88d51b90008bacf3"><div class="ttname"><a href="#a1b2b8c3a489d9c5c88d51b90008bacf3">gf2::BitVector::biased_random</a></div><div class="ttdeci">static BitVector biased_random(usize size, double p)</div><div class="ttdoc">Factory method to generate a bit-vector of size size where the elements are from independent fair coi...</div><div class="ttdef"><b>Definition</b> BitVector.h:385</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05d4d7648a2190f143ecc316d83383b5" name="a05d4d7648a2190f143ecc316d83383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d4d7648a2190f143ecc316d83383b5">&#9670;&#160;</a></span>bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const iterator over the values of the bits in the mutable bit-vector. </p>
<p>You can use this iterator to iterate over the bits in the bit-vector to get <em>or</em> set the value of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="note-37"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-445"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : v.bits()) bit = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a899931f1989b4af7ee2ad2bdef3684b3" name="a899931f1989b4af7ee2ad2bdef3684b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899931f1989b4af7ee2ad2bdef3684b3">&#9670;&#160;</a></span>bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-vector. </p>
<p>You can use this iterator to iterate over the bits in the bit-vector and get the values of each bit as a <span class="tt">bool</span>.</p>
<h1 class="doxsection"><a class="anchor" id="note-36"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-444"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : u.bits()) assert_eq(bit, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4b9cffc16ebebe17e183311de0119d55" name="a4b9cffc16ebebe17e183311de0119d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9cffc16ebebe17e183311de0119d55">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the bit-vector. </p>
<p>This is the total number of bits that the bit-vector can hold without allocating more memory. The number <em>includes</em> the number of bits already in use.</p>
<h1 class="doxsection"><a class="anchor" id="example-400"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a4b9cffc16ebebe17e183311de0119d55">capacity</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u64&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.capacity(), 64);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a4b9cffc16ebebe17e183311de0119d55"><div class="ttname"><a href="#a4b9cffc16ebebe17e183311de0119d55">gf2::BitVector::capacity</a></div><div class="ttdeci">constexpr usize capacity() const</div><div class="ttdoc">Returns the current capacity of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:544</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7f30b7ca6335493a4ac73d5a54fa4038" name="a7f30b7ca6335493a4ac73d5a54fa4038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f30b7ca6335493a4ac73d5a54fa4038">&#9670;&#160;</a></span>clean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::clean </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets any unused bits in the <em>last</em> occupied word to 0. </p>
<p>This method can be used to enforce the guarantee that unused bits in the store are always set to 0. </p>

</div>
</div>
<a id="ad77aa9ce9b0abde4d43bd7062ce2e9b4" name="ad77aa9ce9b0abde4d43bd7062ce2e9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77aa9ce9b0abde4d43bd7062ce2e9b4">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the bit-vector so <code><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>==0</code>. </p>
<p>The capacity is not changed by this operation. </p>

</div>
</div>
<a id="a6772a3f88ec78ec6d26ee559d2e20e7f" name="a6772a3f88ec78ec6d26ee559d2e20e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6772a3f88ec78ec6d26ee559d2e20e7f">&#9670;&#160;</a></span>constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are set to <span class="tt">value</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-387"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a6772a3f88ec78ec6d26ee559d2e20e7f">BitVector&lt;&gt;::constant</a>(10, <span class="keyword">true</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a6772a3f88ec78ec6d26ee559d2e20e7f">BitVector&lt;&gt;::constant</a>(10, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a6772a3f88ec78ec6d26ee559d2e20e7f"><div class="ttname"><a href="#a6772a3f88ec78ec6d26ee559d2e20e7f">gf2::BitVector::constant</a></div><div class="ttdeci">static constexpr BitVector constant(usize n, bool value)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are set to value.</div><div class="ttdef"><b>Definition</b> BitVector.h:215</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17d49ceb92c3f0693361beeb9ade123e" name="a17d49ceb92c3f0693361beeb9ade123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d49ceb92c3f0693361beeb9ade123e">&#9670;&#160;</a></span>copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to this <em>equal-sized</em> bit-vector and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-34"></a>
Note</h1>
<p>This is one of the few methods in the library that <em>doesn't</em> require the two stores to have the same <span class="tt"><a class="el" href="#aca1c8345774c71accac5a29b6d79e166" title="The underlying unsigned word type used to store the bits.">word_type</a></span>. You can use it to convert between different <span class="tt"><a class="el" href="#aca1c8345774c71accac5a29b6d79e166" title="The underlying unsigned word type used to store the bits.">word_type</a></span> stores (e.g., from <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#ad1e43953e374bea8222087e4aba6c74a" title="Word type alias for a 32-bit unsigned integer.">u32</a>&gt;</span> to <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>) as long as the sizes match.</p>
<h1 class="doxsection"><a class="anchor" id="panics-129"></a>
Panics</h1>
<p>Panics if the sizes of this bit-vector and the <span class="tt">src</span> bit-store do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-428"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u64&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">v.copy(<a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10));</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a85e93ce5352f5a87bc23e767cbe90fd7" name="a85e93ce5352f5a87bc23e767cbe90fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e93ce5352f5a87bc23e767cbe90fd7">&#9670;&#160;</a></span>copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to this <em>equal-sized</em> bit-vector. Returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="notes-1"></a>
Notes:</h1>
<ol type="1">
<li>We allow <em>any</em> unsigned integral source, e.g. copying a single <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of size 64.</li>
<li>The least-significant bit of the source becomes the bit at index 0 in the bit-vector.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="panics-128"></a>
Panics</h1>
<p>Panics if the size of the bit-vector does not match the number of bits in the source integer type.</p>
<h1 class="doxsection"><a class="anchor" id="example-427"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> v{16};</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">v.<a class="code hl_function" href="#a85e93ce5352f5a87bc23e767cbe90fd7">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u32&gt;</a> w{16};</div>
<div class="line">w.<a class="code hl_function" href="#a85e93ce5352f5a87bc23e767cbe90fd7">copy</a>(src);</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a85e93ce5352f5a87bc23e767cbe90fd7"><div class="ttname"><a href="#a85e93ce5352f5a87bc23e767cbe90fd7">gf2::BitVector::copy</a></div><div class="ttdeci">constexpr auto copy(Src src)</div><div class="ttdoc">Copies all the bits from any unsigned integral src value to this equal-sized bit-vector....</div><div class="ttdef"><b>Definition</b> BitVector.h:1170</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1eaf930a97194cd69fbdaf750395a4ca" name="a1eaf930a97194cd69fbdaf750395a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaf930a97194cd69fbdaf750395a4ca">&#9670;&#160;</a></span>copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from a <span class="tt">std::bitset</span> to this <em>equal-sized</em> bit-vector and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="note-35"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> which is the reverse of our convention.</p>
<h1 class="doxsection"><a class="anchor" id="panics-130"></a>
Panics</h1>
<p>Panics if the size of the bit-vectors does not match the number of bits in the source <span class="tt">std::bitset</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-429"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">v.<a class="code hl_function" href="#a85e93ce5352f5a87bc23e767cbe90fd7">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a572e1db2772a17233392d8329dbf29b5" name="a572e1db2772a17233392d8329dbf29b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572e1db2772a17233392d8329dbf29b5">&#9670;&#160;</a></span>copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the bit-vector by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-430"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">v.<a class="code hl_function" href="#a85e93ce5352f5a87bc23e767cbe90fd7">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>(), 10);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac2d2d233519d4c7531ceb2be692eae3d" name="ac2d2d233519d4c7531ceb2be692eae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d2d233519d4c7531ceb2be692eae3d">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-432"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac2d2d233519d4c7531ceb2be692eae3d">count_ones</a>(), 0);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac2d2d233519d4c7531ceb2be692eae3d">count_ones</a>(), 1);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ac2d2d233519d4c7531ceb2be692eae3d"><div class="ttname"><a href="#ac2d2d233519d4c7531ceb2be692eae3d">gf2::BitVector::count_ones</a></div><div class="ttdeci">constexpr usize count_ones() const</div><div class="ttdoc">Returns the number of set bits in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1275</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acdc8cf20785c6091f60dfb2498a69316" name="acdc8cf20785c6091f60dfb2498a69316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8cf20785c6091f60dfb2498a69316">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-433"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#acdc8cf20785c6091f60dfb2498a69316">count_zeros</a>(), 10);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#acdc8cf20785c6091f60dfb2498a69316">count_zeros</a>(), 9);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_acdc8cf20785c6091f60dfb2498a69316"><div class="ttname"><a href="#acdc8cf20785c6091f60dfb2498a69316">gf2::BitVector::count_zeros</a></div><div class="ttdeci">constexpr usize count_zeros() const</div><div class="ttdoc">Returns the number of unset bits in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1286</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a97a032fc7468f702c0a428c1eddad8dd" name="a97a032fc7468f702c0a428c1eddad8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a032fc7468f702c0a428c1eddad8dd">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::describe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a multi-line string describing the bit-vector in some detail. </p>
<p>This method is useful for debugging but you should not rely on the output format which may change. </p>

</div>
</div>
<a id="aa04714ab255021c1a38adbe375099f26" name="aa04714ab255021c1a38adbe375099f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04714ab255021c1a38adbe375099f26">&#9670;&#160;</a></span>fill_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::fill_random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the bit-vector with random bits and returns a reference to this for chaining. </p>
<p>The default call <span class="tt"><a class="el" href="#aa04714ab255021c1a38adbe375099f26" title="Fill the bit-vector with random bits and returns a reference to this for chaining.">fill_random()</a></span> sets each bit to 1 with probability 0.5 (fair coin).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the fill is all zeros, if <span class="tt">p &gt; 1</span> then the fill is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-431"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> u{10}, v{10};</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line">u.<a class="code hl_function" href="#aa04714ab255021c1a38adbe375099f26">fill_random</a>(0.5, seed);</div>
<div class="line">v.fill_random(0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aa04714ab255021c1a38adbe375099f26"><div class="ttname"><a href="#aa04714ab255021c1a38adbe375099f26">gf2::BitVector::fill_random</a></div><div class="ttdeci">constexpr auto fill_random(double p=0.5, u64 seed=0)</div><div class="ttdoc">Fill the bit-vector with random bits and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitVector.h:1257</div></div>
<div class="ttc" id="anamespacegf2_html_a770302128133591da0ca93ded6abf8aa"><div class="ttname"><a href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">gf2::u64</a></div><div class="ttdeci">std::uint64_t u64</div><div class="ttdoc">Word type alias for a 64-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7880bbbf06f4ee31d9baf2d6bfa61d03" name="a7880bbbf06f4ee31d9baf2d6bfa61d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7880bbbf06f4ee31d9baf2d6bfa61d03">&#9670;&#160;</a></span>first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::first_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first set bit in the bit-vector or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-436"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a7880bbbf06f4ee31d9baf2d6bfa61d03">first_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a7880bbbf06f4ee31d9baf2d6bfa61d03"><div class="ttname"><a href="#a7880bbbf06f4ee31d9baf2d6bfa61d03">gf2::BitVector::first_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_set() const</div><div class="ttdoc">Returns the index of the first set bit in the bit-vector or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitVector.h:1331</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad5801c5e4bad14d86cfa9276e0e1229c" name="ad5801c5e4bad14d86cfa9276e0e1229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5801c5e4bad14d86cfa9276e0e1229c">&#9670;&#160;</a></span>first_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::first_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first unset bit in the bit-vector or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-440"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#ad5801c5e4bad14d86cfa9276e0e1229c">first_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad5801c5e4bad14d86cfa9276e0e1229c"><div class="ttname"><a href="#ad5801c5e4bad14d86cfa9276e0e1229c">gf2::BitVector::first_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_unset() const</div><div class="ttdoc">Returns the index of the first unset bit in the bit-vector or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitVector.h:1395</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad5425d23c332a0170eb24b8242373ad0" name="ad5425d23c332a0170eb24b8242373ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5425d23c332a0170eb24b8242373ad0">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-126"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-419"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">v.flip(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0111111111&quot;</span>);</div>
<div class="line">v.flip(1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111111&quot;</span>);</div>
<div class="line">v.flip(9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aff3b6b072f9c5c15a05fc994a178edaa" name="aff3b6b072f9c5c15a05fc994a178edaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3b6b072f9c5c15a05fc994a178edaa">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bits in the bit-vector and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-426"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">v.flip_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8fa389c41966681f7208c58ed8efde7" name="ae8fa389c41966681f7208c58ed8efde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fa389c41966681f7208c58ed8efde7">&#9670;&#160;</a></span>from() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> other bit-store instance. </p>
<h1 class="doxsection"><a class="anchor" id="note-29"></a>
Note</h1>
<p>Generally, we do not support interactions between bit-stores that use different underlying unsigned word types. This method is an exception &ndash; the <span class="tt">src</span> bit-store may use a different unsigned type from the one used here. It makes it possible to convert between bit-vector types which is occasionally useful.</p>
<h1 class="doxsection"><a class="anchor" id="example-391"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(<a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10));</div>
<div class="line">assert_eq(v.size(), 10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(<a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u16&gt;::ones</a>(20));</div>
<div class="line">assert_eq(w.size(), 20);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;11111111111111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> x = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(<a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u32&gt;::zeros</a>(10));</div>
<div class="line">assert_eq(x.size(), 10);</div>
<div class="line">assert_eq(x.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a3f33e12942bab8d475697297db924cb0"><div class="ttname"><a href="#a3f33e12942bab8d475697297db924cb0">gf2::BitVector::from</a></div><div class="ttdeci">static constexpr BitVector from(Src src)</div><div class="ttdoc">Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....</div><div class="ttdef"><b>Definition</b> BitVector.h:259</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3f33e12942bab8d475697297db924cb0" name="a3f33e12942bab8d475697297db924cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f33e12942bab8d475697297db924cb0">&#9670;&#160;</a></span>from() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance. The resulting bit-vector will have the same size as the number of bits in the <span class="tt">src</span> unsigned integer. </p>
<h1 class="doxsection"><a class="anchor" id="example-390"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> s8 = 0b01010101;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(s8);</div>
<div class="line">assert_eq(u.size(), 8);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> s16 = 0b0101010101010101;</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(s16);</div>
<div class="line">assert_eq(v.size(), 16);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u32&gt;::from</a>(s8);</div>
<div class="line">assert_eq(w.size(), 8);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac7a041a322468b8465f0f5a66d93467e" name="ac7a041a322468b8465f0f5a66d93467e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a041a322468b8465f0f5a66d93467e">&#9670;&#160;</a></span>from() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from the bits of a <span class="tt">std::bitset</span>. </p>
<h1 class="doxsection"><a class="anchor" id="note-30"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> ...b2b1b0., we print in <em>vector-order</em> b0b1b2...</p>
<h1 class="doxsection"><a class="anchor" id="example-392"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;&gt;::from</a>(src);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a146f71d85f944143c73ee666c66c878b" name="a146f71d85f944143c73ee666c66c878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146f71d85f944143c73ee666c66c878b">&#9670;&#160;</a></span>from() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a>)</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">f</td><td>The function to call for each index <span class="tt">i</span> in <span class="tt">[0, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a>)</span>.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-393"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a3f33e12942bab8d475697297db924cb0">BitVector&lt;u8&gt;::from</a>(10, [](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.size(), 10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a193a2ffb36fa664bbdbfe057f4f491d2" name="a193a2ffb36fa664bbdbfe057f4f491d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193a2ffb36fa664bbdbfe057f4f491d2">&#9670;&#160;</a></span>from_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_punctuation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a binary string, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The string can contain whitespace, commas, single quotes, and underscores. If the second argument is true, then the string is assumed to have none of the above characters. There can always be a "0b" prefix.</p>
<h1 class="doxsection"><a class="anchor" id="example-398"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a193a2ffb36fa664bbdbfe057f4f491d2">BitVector&lt;u8&gt;::from_binary_string</a>(<span class="stringliteral">&quot;0b1010&#39;1010&#39;10&quot;</span>).value();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a193a2ffb36fa664bbdbfe057f4f491d2">BitVector&lt;u8&gt;::from_binary_string</a>(<span class="stringliteral">&quot;&quot;</span>).value();</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a193a2ffb36fa664bbdbfe057f4f491d2"><div class="ttname"><a href="#a193a2ffb36fa664bbdbfe057f4f491d2">gf2::BitVector::from_binary_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_binary_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:448</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94bc956ed38b656c83518854999bc5f1" name="a94bc956ed38b656c83518854999bc5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bc956ed38b656c83518854999bc5f1">&#9670;&#160;</a></span>from_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from_hex_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_punctuation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a hex string, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The hex string should consist of the characters 0-9, A-F, a-f, with an optional prefix "0x" or "0X". The string may also have a suffix of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8 which indicates that the last digit should be interpreted as a base <span class="tt">base</span> number. This allows for bit-vectors whose length is not a multiple of 4.</p>
<h1 class="doxsection"><a class="anchor" id="example-399"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0xAA&quot;</span>).value();</div>
<div class="line">assert_eq(v1.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1&quot;</span>).value();</div>
<div class="line">assert_eq(v2.to_string(), <span class="stringliteral">&quot;0001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.8&quot;</span>).value();</div>
<div class="line">assert_eq(v3.to_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v4 = <a class="code hl_function" href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.4&quot;</span>).value();</div>
<div class="line">assert_eq(v4.to_string(), <span class="stringliteral">&quot;01&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v5 = <a class="code hl_function" href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.2&quot;</span>).value();</div>
<div class="line">assert_eq(v5.to_string(), <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a94bc956ed38b656c83518854999bc5f1"><div class="ttname"><a href="#a94bc956ed38b656c83518854999bc5f1">gf2::BitVector::from_hex_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_hex_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a hex string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:489</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17ba4f50de43f5e84ef3943ad77410ea" name="a17ba4f50de43f5e84ef3943ad77410ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ba4f50de43f5e84ef3943ad77410ea">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::from_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a string <span class="tt">s</span>, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The string can contain whitespace, commas, single quotes, and underscores and optionally a "0b", "0x", or "0X" prefix. If there is no prefix, and the string only contains '0' and '1' characters, we assume the string is binary. To force getting it interpreted as a hex string, add a prefix of "0x" or "0X".</p>
<p>A hex string can have a suffix of ".2", ".4", or ".8" to indicate the base of the last digit/character. This allows for bit-vectors of any length as opposed to just a multiple of 4.</p>
<h1 class="doxsection"><a class="anchor" id="example-397"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0b1010_1010_10&quot;</span>).value();</div>
<div class="line">assert_eq(v1.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;AA&quot;</span>).value();</div>
<div class="line">assert_eq(v2.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;1010&#39;1010&quot;</span>).value();</div>
<div class="line">assert_eq(v3.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v4 = <a class="code hl_function" href="#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0x1.8&quot;</span>).value();</div>
<div class="line">assert_eq(v4.to_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a17ba4f50de43f5e84ef3943ad77410ea"><div class="ttname"><a href="#a17ba4f50de43f5e84ef3943ad77410ea">gf2::BitVector::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:411</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abaed9cf3881b1064339ca246099cdce4" name="abaed9cf3881b1064339ca246099cdce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaed9cf3881b1064339ca246099cdce4">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-122"></a>
Panics</h1>
<p>In debug mode the method panics of the store is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-415"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.front(), <span class="keyword">true</span>);</div>
<div class="line">v.set_all(<span class="keyword">false</span>);</div>
<div class="line">assert_eq(v.front(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4174ea457afc81234d769dcf75f1b4ac" name="a4174ea457afc81234d769dcf75f1b4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4174ea457afc81234d769dcf75f1b4ac">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-120"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-413"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a4174ea457afc81234d769dcf75f1b4ac">get</a>(0), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a4174ea457afc81234d769dcf75f1b4ac">get</a>(0), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a4174ea457afc81234d769dcf75f1b4ac"><div class="ttname"><a href="#a4174ea457afc81234d769dcf75f1b4ac">gf2::BitVector::get</a></div><div class="ttdeci">constexpr bool get(usize i) const</div><div class="ttdoc">Returns true if the bit at the given index i is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVector.h:922</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a26c48c7ba8dc5dacdfe886a081641e0e" name="a26c48c7ba8dc5dacdfe886a081641e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c48c7ba8dc5dacdfe886a081641e0e">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit-vector is empty, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="example-421"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a26c48c7ba8dc5dacdfe886a081641e0e">is_empty</a>(), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> u{10};</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#a26c48c7ba8dc5dacdfe886a081641e0e">is_empty</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a26c48c7ba8dc5dacdfe886a081641e0e"><div class="ttname"><a href="#a26c48c7ba8dc5dacdfe886a081641e0e">gf2::BitVector::is_empty</a></div><div class="ttdeci">constexpr bool is_empty() const</div><div class="ttdoc">Returns true if the bit-vector is empty, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVector.h:1069</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0623e155d7ddf9d08f64d3eee6e7aec3" name="a0623e155d7ddf9d08f64d3eee6e7aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0623e155d7ddf9d08f64d3eee6e7aec3">&#9670;&#160;</a></span>last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::last_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last set bit in the bit-vector or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-437"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a0623e155d7ddf9d08f64d3eee6e7aec3">last_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a0623e155d7ddf9d08f64d3eee6e7aec3"><div class="ttname"><a href="#a0623e155d7ddf9d08f64d3eee6e7aec3">gf2::BitVector::last_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_set() const</div><div class="ttdoc">Returns the index of the last set bit in the bit-vector or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitVector.h:1346</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad820bf33df2faff7cc700824b370d864" name="ad820bf33df2faff7cc700824b370d864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad820bf33df2faff7cc700824b370d864">&#9670;&#160;</a></span>last_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::last_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last unset bit in the bit-vector or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-441"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#ad820bf33df2faff7cc700824b370d864">last_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad820bf33df2faff7cc700824b370d864"><div class="ttname"><a href="#ad820bf33df2faff7cc700824b370d864">gf2::BitVector::last_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_unset() const</div><div class="ttdoc">Returns the index of the last unset bit in the bit-vector or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitVector.h:1412</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3c810f15c19034ff0fb20cc8bd038616" name="a3c810f15c19034ff0fb20cc8bd038616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c810f15c19034ff0fb20cc8bd038616">&#9670;&#160;</a></span>leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::leading_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-434"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{37};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a3c810f15c19034ff0fb20cc8bd038616">leading_zeros</a>(), 37);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(27);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a3c810f15c19034ff0fb20cc8bd038616">leading_zeros</a>(), 27);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(w.leading_zeros(), 0);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a3c810f15c19034ff0fb20cc8bd038616"><div class="ttname"><a href="#a3c810f15c19034ff0fb20cc8bd038616">gf2::BitVector::leading_zeros</a></div><div class="ttdeci">constexpr usize leading_zeros() const</div><div class="ttdoc">Returns the number of leading zeros in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1299</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6f8f81db958c9e0b6749b0e1c05a974" name="aa6f8f81db958c9e0b6749b0e1c05a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f8f81db958c9e0b6749b0e1c05a974">&#9670;&#160;</a></span>next_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::next_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next set bit after <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more set bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-438"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.next_set(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.next_set(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.next_set(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.next_set(27) == std::optional&lt;usize&gt;{});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6ec1590bad64a8ff835918eed8afb50" name="aa6ec1590bad64a8ff835918eed8afb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ec1590bad64a8ff835918eed8afb50">&#9670;&#160;</a></span>next_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::next_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next unset bit after <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-442"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.next_unset(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.next_unset(27) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#aa6ec1590bad64a8ff835918eed8afb50">next_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aa6ec1590bad64a8ff835918eed8afb50"><div class="ttname"><a href="#aa6ec1590bad64a8ff835918eed8afb50">gf2::BitVector::next_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_unset(usize index) const</div><div class="ttdoc">Returns the index of the next unset bit after index in the bit-vector or {} if no more unset bits exi...</div><div class="ttdef"><b>Definition</b> BitVector.h:1428</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad35a4ea3c7e58752695053c532f70104" name="ad35a4ea3c7e58752695053c532f70104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35a4ea3c7e58752695053c532f70104">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no bits in the bit-vector are set, <span class="tt">false</span> otherwise. </p>
<p><b>Note:</b> Empty bit-vectors have no set bits (logical connective for <span class="tt"><a class="el" href="#ad35a4ea3c7e58752695053c532f70104" title="Returns true if no bits in the bit-vector are set, false otherwise.">none</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-424"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad35a4ea3c7e58752695053c532f70104">none</a>(), <span class="keyword">true</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad35a4ea3c7e58752695053c532f70104">none</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ad35a4ea3c7e58752695053c532f70104"><div class="ttname"><a href="#ad35a4ea3c7e58752695053c532f70104">gf2::BitVector::none</a></div><div class="ttdeci">constexpr bool none() const</div><div class="ttdoc">Returns true if no bits in the bit-vector are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVector.h:1110</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70b5a50e5a357fda36b9faa81eb0d270" name="a70b5a50e5a357fda36b9faa81eb0d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5a50e5a357fda36b9faa81eb0d270">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::offset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset (in bits) of the first bit in the bit-vector within the first word. </p>
<p>This is always zero for <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a></span>. </p>

</div>
</div>
<a id="abcfb7a88f30c8faa177519571a76ba8d" name="abcfb7a88f30c8faa177519571a76ba8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfb7a88f30c8faa177519571a76ba8d">&#9670;&#160;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-386"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10).<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3db3b1c6d620553dc2d0084f81966cf2" name="a3db3b1c6d620553dc2d0084f81966cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db3b1c6d620553dc2d0084f81966cf2">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "reference" to the bit element <span class="tt">i</span>. </p>
<p>The returned object is a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference for the bit element at <span class="tt">index</span> rather than a true reference.</p>
<h1 class="doxsection"><a class="anchor" id="note-33"></a>
Note</h1>
<p>The referenced bit-store must continue to exist while the <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="panics-125"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-418"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">v[3] = w[3];</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;0011000000&quot;</span>);</div>
<div class="line">v[4] |= w[4];</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;0011100000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a46aaf33f13e4b6d79467bdb33bc36db8" name="a46aaf33f13e4b6d79467bdb33bc36db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aaf33f13e4b6d79467bdb33bc36db8">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boolean value of the bit element <span class="tt">i</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-121"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-414"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert(v[2] == <span class="keyword">false</span>);</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v[2] == <span class="keyword">true</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7cab0bece6d69e0d89ae7a4b866ed12b" name="a7cab0bece6d69e0d89ae7a4b866ed12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cab0bece6d69e0d89ae7a4b866ed12b">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; bool &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::pop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last bit from the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-405"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#ab1ec353b0b28d8f85f402b368883405e">push</a>(1);</div>
<div class="line">v.<a class="code hl_function" href="#ab1ec353b0b28d8f85f402b368883405e">push</a>(0);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;10&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b1 = v.<a class="code hl_function" href="#a7cab0bece6d69e0d89ae7a4b866ed12b">pop</a>();</div>
<div class="line">assert_eq(*b1, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b2 = v.<a class="code hl_function" href="#a7cab0bece6d69e0d89ae7a4b866ed12b">pop</a>();</div>
<div class="line">assert_eq(*b2, <span class="keyword">true</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b3 = v.<a class="code hl_function" href="#a7cab0bece6d69e0d89ae7a4b866ed12b">pop</a>();</div>
<div class="line">assert(b3 == std::nullopt);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a7cab0bece6d69e0d89ae7a4b866ed12b"><div class="ttname"><a href="#a7cab0bece6d69e0d89ae7a4b866ed12b">gf2::BitVector::pop</a></div><div class="ttdeci">constexpr std::optional&lt; bool &gt; pop()</div><div class="ttdoc">Removes the last bit from the bit-vector and returns it or std::nullopt if the bit-vector is empty.</div><div class="ttdef"><b>Definition</b> BitVector.h:654</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_ab1ec353b0b28d8f85f402b368883405e"><div class="ttname"><a href="#ab1ec353b0b28d8f85f402b368883405e">gf2::BitVector::push</a></div><div class="ttdeci">constexpr BitVector &amp; push(bool b)</div><div class="ttdoc">Pushes a single bit b onto the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:631</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8a1df02604e2457c56c4de2a9d00c5c3" name="a8a1df02604e2457c56c4de2a9d00c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1df02604e2457c56c4de2a9d00c5c3">&#9670;&#160;</a></span>previous_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::previous_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous set bit before <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-439"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.previous_set(36) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.previous_set(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.previous_set(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.previous_set(2)  == std::optional&lt;usize&gt;{});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9000a2348948286e3d12eacaa5948ff6" name="a9000a2348948286e3d12eacaa5948ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9000a2348948286e3d12eacaa5948ff6">&#9670;&#160;</a></span>previous_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::previous_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous unset bit before <span class="tt">index</span> in the bit-vector or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-443"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.previous_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.previous_unset(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.previous_unset(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.previous_unset(2) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a9000a2348948286e3d12eacaa5948ff6">previous_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a9000a2348948286e3d12eacaa5948ff6"><div class="ttname"><a href="#a9000a2348948286e3d12eacaa5948ff6">gf2::BitVector::previous_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_unset(usize index) const</div><div class="ttdoc">Returns the index of the previous unset bit before index in the bit-vector or {} if no more unset bit...</div><div class="ttdef"><b>Definition</b> BitVector.h:1445</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab1ec353b0b28d8f85f402b368883405e" name="ab1ec353b0b28d8f85f402b368883405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec353b0b28d8f85f402b368883405e">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::push </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a single bit <span class="tt">b</span> onto the bit-vector. </p>
<p>Returns a reference to the current object for chaining.</p>
<h1 class="doxsection"><a class="anchor" id="example-404"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#ab1ec353b0b28d8f85f402b368883405e">push</a>(1);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#ab1ec353b0b28d8f85f402b368883405e">push</a>(0);</div>
<div class="line">assert(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>() == <span class="stringliteral">&quot;10&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4b7006134bcff1ddfc81bcc8133dd3cc" name="a4b7006134bcff1ddfc81bcc8133dd3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7006134bcff1ddfc81bcc8133dd3cc">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are picked at random. </p>
<p>The default call <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;&gt;::random(size)</span> produces a random bit-vector with each bit being 1 with probability 0.5 and where the RNG is seeded from entropy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-vector is all zeros, if <span class="tt">p &gt; 1</span> then the bit-vector is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-394"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a4b7006134bcff1ddfc81bcc8133dd3cc">BitVector&lt;&gt;::random</a>(10, 0.5, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a4b7006134bcff1ddfc81bcc8133dd3cc">BitVector&lt;&gt;::random</a>(10, 0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a4b7006134bcff1ddfc81bcc8133dd3cc"><div class="ttname"><a href="#a4b7006134bcff1ddfc81bcc8133dd3cc">gf2::BitVector::random</a></div><div class="ttdeci">static BitVector random(usize size, double p=0.5, u64 seed=0)</div><div class="ttdoc">Factory method to generate a bit-vector of size size where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitVector.h:348</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3c460bba89b8c439f20f0b4d5330932a" name="a3c460bba89b8c439f20f0b4d5330932a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c460bba89b8c439f20f0b4d5330932a">&#9670;&#160;</a></span>remaining_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::remaining_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating. </p>
<h1 class="doxsection"><a class="anchor" id="example-401"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u64&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.remaining_capacity(), 54);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9e43be056727a9fe0b684a54e5a796d3" name="a9e43be056727a9fe0b684a54e5a796d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e43be056727a9fe0b684a54e5a796d3">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the bit-vector so that its <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a></span> is <span class="tt">n</span>. </p>
<ul>
<li>If <span class="tt">n</span> is greater than the bit-vector's current size, then the new elements are set to 0.</li>
<li>If <span class="tt">n</span> is less than the bit-vector's current size, then the bit-vector is truncated.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-403"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(1000);</div>
<div class="line">v.resize(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">v.resize(15);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;111111111100000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a63d0494abd47378b45d9d4a6e8ff01ff" name="a63d0494abd47378b45d9d4a6e8ff01ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d0494abd47378b45d9d4a6e8ff01ff">&#9670;&#160;</a></span>riffled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the result of riffling the bits in this bit-vector with zeros. </p>
<p>If this bit-vector has the bits <span class="tt">abcde</span> then the output bit-vector will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-456"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> dst = v.riffled();</div>
<div class="line">assert_eq(dst.to_string(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad33314f6e953a6808a2303bc9a755a3b" name="ad33314f6e953a6808a2303bc9a755a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33314f6e953a6808a2303bc9a755a3b">&#9670;&#160;</a></span>riffled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the bits of this bit-vector with zeros storing the result into the bit-vector <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> will have the bits of this bit-vector interleaved with zeros. For example, if this bit-vector has the bits <span class="tt">abcde</span> then <span class="tt">dst</span> will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-455"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> dst;</div>
<div class="line">v.riffled(dst);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adaced7a7dcdc71fa7ac67f2fefb5553c" name="adaced7a7dcdc71fa7ac67f2fefb5553c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaced7a7dcdc71fa7ac67f2fefb5553c">&#9670;&#160;</a></span>seeded_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt"><a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size</a></span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random bit-vectors, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-vector is all zeros, if <span class="tt">p &gt; 1</span> then the bit-vector is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-395"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#adaced7a7dcdc71fa7ac67f2fefb5553c">BitVector&lt;&gt;::seeded_random</a>(10, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#adaced7a7dcdc71fa7ac67f2fefb5553c">BitVector&lt;&gt;::seeded_random</a>(10, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_adaced7a7dcdc71fa7ac67f2fefb5553c"><div class="ttname"><a href="#adaced7a7dcdc71fa7ac67f2fefb5553c">gf2::BitVector::seeded_random</a></div><div class="ttdeci">static BitVector seeded_random(usize size, u64 seed)</div><div class="ttdoc">Factory method to generate a bit-vector of size size where the elements are from independent fair coi...</div><div class="ttdef"><b>Definition</b> BitVector.h:371</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73c5c0d160af7ae95e495e1288f73440" name="a73c5c0d160af7ae95e495e1288f73440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c5c0d160af7ae95e495e1288f73440">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-124"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-417"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a4174ea457afc81234d769dcf75f1b4ac">get</a>(0), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a4174ea457afc81234d769dcf75f1b4ac">get</a>(0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a930b70847fba4092fa8be14a40dce295" name="a930b70847fba4092fa8be14a40dce295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930b70847fba4092fa8be14a40dce295">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits in the bit-vector to the boolean <span class="tt">value</span> and returns a reference to this for chaining. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-425"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">v.set_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4679323bfd87481db46124b8533d7bf4" name="a4679323bfd87481db46124b8533d7bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4679323bfd87481db46124b8533d7bf4">&#9670;&#160;</a></span>set_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::set_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-vector. </p>
<p>You can use this iterator to iterate over the set bits in the bit-vector and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-446"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.set_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{0, 2, 4, 6, 8}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab3edaa3f54306e82e8190372e6e4d8f6" name="ab3edaa3f54306e82e8190372e6e4d8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3edaa3f54306e82e8190372e6e4d8f6">&#9670;&#160;</a></span>set_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::set_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets word <span class="tt">i</span> in the bit-vector's underlying word store to <span class="tt">value</span> (masked if necessary). </p>
<p>The final word in the store may not be fully occupied but we ensure that unused bits remain set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="panics-117"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-379"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.set_word(1, 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000011&quot;</span>);</div>
<div class="line">assert_eq(v.count_ones(), 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5bf1540020eb0b155578832dcd535513" name="a5bf1540020eb0b155578832dcd535513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf1540020eb0b155578832dcd535513">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> &amp; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks the bit-vector's capacity as much as possible. </p>
<p>This method may do nothing.</p>
<h1 class="doxsection"><a class="anchor" id="example-402"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(1000);</div>
<div class="line">v.resize(15);</div>
<div class="line">v.shrink_to_fit();</div>
<div class="line">assert_eq(v.capacity(), 16);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b10006eb120ea7fafdeecf68adb53cb" name="a8b10006eb120ea7fafdeecf68adb53cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b10006eb120ea7fafdeecf68adb53cb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bit-elements in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-376"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a8b10006eb120ea7fafdeecf68adb53cb">size</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.size(), 10);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afec09f80547d2a38c78beddb574159bc" name="afec09f80547d2a38c78beddb574159bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec09f80547d2a38c78beddb574159bc">&#9670;&#160;</a></span>span() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable bit-span encompassing the bit-vector's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Mutability here is deep &ndash; the interior pointer in the returned span is to <em>non-const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-132"></a>
Panics</h1>
<p>This method panics if the range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-451"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0afbe86b05c12a2a7a7d69ac519035ea" name="a0afbe86b05c12a2a7a7d69ac519035ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afbe86b05c12a2a7a7d69ac519035ea">&#9670;&#160;</a></span>span() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <em>immutable</em> bit-span encompassing the bit-vector's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Immutability here is deep &ndash; the interior pointer in the returned span is to <em>const</em> words.</p>
<h1 class="doxsection"><a class="anchor" id="panics-131"></a>
Panics</h1>
<p>This method panics if the range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-450"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8d1a537cc0ee85444e008ce3aec4c318" name="a8d1a537cc0ee85444e008ce3aec4c318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a537cc0ee85444e008ce3aec4c318">&#9670;&#160;</a></span>split_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views the bit-vector as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are returned as a pair of bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>].</p>
<p>On return, <span class="tt">left</span> is a clone of the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<h1 class="doxsection"><a class="anchor" id="panics-135"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-454"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> [left, right] = v.split_at(5);</div>
<div class="line">assert_eq(left.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.to_string(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6e2078e3f40d295f483d87a09d26a92f" name="a6e2078e3f40d295f483d87a09d26a92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2078e3f40d295f483d87a09d26a92f">&#9670;&#160;</a></span>split_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; <a class="el" href="#aca1c8345774c71accac5a29b6d79e166">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views the bit-vector as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>.</p>
<p>On return, <span class="tt">left</span> contains the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<p>This lets one reuse the <span class="tt">left</span> and <span class="tt">right</span> destinations without having to allocate new bit-vectors. This is useful when implementing iterative algorithms that need to split a bit-vector into two parts repeatedly.</p>
<h1 class="doxsection"><a class="anchor" id="panics-134"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-453"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> left, right;</div>
<div class="line">v.split_at(5, left, right);</div>
<div class="line">assert_eq(left.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1dbeafd75d30e211d688822448a5da03" name="a1dbeafd75d30e211d688822448a5da03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbeafd75d30e211d688822448a5da03">&#9670;&#160;</a></span>split_off() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::split_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a bit-vector into two at the given index, returning a new <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a></span>. </p>
<p>The returned bit-vector contains the bits from <span class="tt">at</span> to the end of the bit-vector. The bit-vector is resized to only contain the bits in the half-open range <span class="tt">[0, at)</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-118"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-411"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> w = v.split_off(5);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7f68ece23b962b527abf8adffb9eb8fd" name="a7f68ece23b962b527abf8adffb9eb8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f68ece23b962b527abf8adffb9eb8fd">&#9670;&#160;</a></span>split_off() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::split_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a bit-vector into two at the given index, returning the second part in <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. The bit-vector is resized to only contain the bits in the half-open range <span class="tt">[0, at)</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-119"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-412"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> dst;</div>
<div class="line">v.split_off(5, dst);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9908f2bf308fd4371d920aeea320a489" name="a9908f2bf308fd4371d920aeea320a489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9908f2bf308fd4371d920aeea320a489">&#9670;&#160;</a></span>split_off_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Dst = Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Dst &gt; <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::split_off_unsigned </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty. </p>
<h1 class="doxsection"><a class="anchor" id="note-32"></a>
Note</h1>
<p>You can split off a primitive unsigned integer type of <em>any</em> size from the end of a non-empty bit-vector. For example, if <span class="tt">v</span> is a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>with 22 elements, then you can split off a <span class="tt"><a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a></span> value from the end of <span class="tt">v</span> by calling <span class="tt">v.split_off_unsigned&lt;<a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a>&gt;()</span>. This leaves the bit-vector with 6 elements.</p>
<h1 class="doxsection"><a class="anchor" id="examples"></a>
Examples</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(22);</div>
<div class="line"><span class="keyword">auto</span> x16 = v.split_off_unsigned&lt;<a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a>&gt;();</div>
<div class="line">assert_eq(*x16, 0b1111&#39;1111&#39;1111&#39;1111);</div>
<div class="line">assert_eq(v.size(), 6);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(24);</div>
<div class="line"><span class="keyword">auto</span> x8 = w.split_off_unsigned&lt;<a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&gt;();</div>
<div class="line">assert_eq(*x8, 0b0101&#39;0101);</div>
<div class="line">assert_eq(w.size(), 16);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;1010101010101010&quot;</span>);</div>
<div class="line">w.append(*x8);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;101010101010101010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a154c64cdbc79b290bf1eef9bc45ee945" name="a154c64cdbc79b290bf1eef9bc45ee945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154c64cdbc79b290bf1eef9bc45ee945">&#9670;&#160;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word * <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying store of words. </p>
<p><b>Note:</b> The pointer is non-const but you should be careful about using it to modify the words in the store.</p>
<h1 class="doxsection"><a class="anchor" id="example-381"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> ptr = v.store();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05813fe7456c3b44322f29f3a34cf7af" name="a05813fe7456c3b44322f29f3a34cf7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05813fe7456c3b44322f29f3a34cf7af">&#9670;&#160;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Word * <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the underlying store of words . </p>
<h1 class="doxsection"><a class="anchor" id="example-380"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> ptr = v.store();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aedb09244ec466632c6e1d0d2a5e877b0" name="aedb09244ec466632c6e1d0d2a5e877b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb09244ec466632c6e1d0d2a5e877b0">&#9670;&#160;</a></span>store_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::store_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over all the <em>words</em> underlying the bit-vector. </p>
<p>You can use this iterator to iterate over the words in the bit-vector and read the <span class="tt">Word</span> value of each word. You <b>cannot</b> use this iterator to modify the words in the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-448"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a> = std::ranges::to&lt;std::vector&gt;(v.store_words());</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a916cdd15c618a1a2eb2d58d47be5eaba"><div class="ttname"><a href="#a916cdd15c618a1a2eb2d58d47be5eaba">gf2::BitVector::words</a></div><div class="ttdeci">constexpr usize words() const</div><div class="ttdoc">Returns the number of words in the bit-vector&#39;s underlying word store.</div><div class="ttdef"><b>Definition</b> BitVector.h:63</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a07fe4a8c5bf228f595f7612c23911970" name="a07fe4a8c5bf228f595f7612c23911970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fe4a8c5bf228f595f7612c23911970">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-133"></a>
Panics</h1>
<p>This method panics if the range is not valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-452"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.sub(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abc6a83f3db17bdad733a606ec0c04f7e" name="abc6a83f3db17bdad733a606ec0c04f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6a83f3db17bdad733a606ec0c04f7e">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bits in the bit-vector at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-127"></a>
Panics</h1>
<p>In debug mode the indices are bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-420"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.swap(0, 1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0100000000&quot;</span>);</div>
<div class="line">v.swap(0, 1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.swap(0, 9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="line">v.swap(0, 9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7cc78c5e7773c30d8da8916af258d081" name="a7cc78c5e7773c30d8da8916af258d081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc78c5e7773c30d8da8916af258d081">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-vector. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-457"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a7cc78c5e7773c30d8da8916af258d081">to_binary_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a7cc78c5e7773c30d8da8916af258d081"><div class="ttname"><a href="#a7cc78c5e7773c30d8da8916af258d081">gf2::BitVector::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1695</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afec1640c73d1be249030207fcd061ab1" name="afec1640c73d1be249030207fcd061ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec1640c73d1be249030207fcd061ab1">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "hex" string representation of the bits in the bit-vector. </p>
<p>The output is a string of hex characters without any spaces, commas, or other formatting.</p>
<p>The string may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
 Empty bit-vectors are represented as the empty string.</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<p>The output is in <em>vector-order</em>. If "h0" is the first hex digit in the output string, you can print it as four binary digits <span class="tt">v_0v_1v_2v_3</span>. For example, if h0 = "A" which is <span class="tt">1010</span> in binary, then v = 1010.</p>
<h1 class="doxsection"><a class="anchor" id="example-460"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#afec1640c73d1be249030207fcd061ab1">to_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(4);</div>
<div class="line">assert_eq(v1.to_hex_string(), <span class="stringliteral">&quot;F&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(v2.to_hex_string(), <span class="stringliteral">&quot;F1.2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(8);</div>
<div class="line">assert_eq(v3.to_binary_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line">assert_eq(v3.to_hex_string(), <span class="stringliteral">&quot;AA&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_afec1640c73d1be249030207fcd061ab1"><div class="ttname"><a href="#afec1640c73d1be249030207fcd061ab1">gf2::BitVector::to_hex_string</a></div><div class="ttdeci">std::string to_hex_string() const</div><div class="ttdoc">Returns the &quot;hex&quot; string representation of the bits in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1764</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aebf24ce533ec44f83c83105b55a3b5e3" name="aebf24ce533ec44f83c83105b55a3b5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf24ce533ec44f83c83105b55a3b5e3">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "pretty" string representation of the bit-vector. </p>
<p>The output is a string of 0's and 1's with spaces between each bit, and the whole thing enclosed in square brackets.</p>
<h1 class="doxsection"><a class="anchor" id="example-459"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_pretty_string(), <span class="stringliteral">&quot;[1,0,1,0,1,0,1,0,1,0]&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> empty;</div>
<div class="line">assert_eq(empty.<a class="code hl_function" href="#aebf24ce533ec44f83c83105b55a3b5e3">to_pretty_string</a>(), <span class="stringliteral">&quot;[]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aebf24ce533ec44f83c83105b55a3b5e3"><div class="ttname"><a href="#aebf24ce533ec44f83c83105b55a3b5e3">gf2::BitVector::to_pretty_string</a></div><div class="ttdeci">std::string to_pretty_string() const</div><div class="ttdoc">Returns a &quot;pretty&quot; string representation of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:1732</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad2b8ef3dc6d1ea250253135172bb48e7" name="ad2b8ef3dc6d1ea250253135172bb48e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8ef3dc6d1ea250253135172bb48e7">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the bit-vector. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-458"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a73c5c0d160af7ae95e495e1288f73440">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac1d9fee2e247cb1792314cb96a811c90" name="ac1d9fee2e247cb1792314cb96a811c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d9fee2e247cb1792314cb96a811c90">&#9670;&#160;</a></span>to_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-vector. </p>
<p><b>Note:</b> The last word in the vector may not be fully occupied but unused slots will be all zeros.</p>
<h1 class="doxsection"><a class="anchor" id="example-449"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a> = v.to_words();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1d68c1882ed92a0d9731f3c4990a9e56" name="a1d68c1882ed92a0d9731f3c4990a9e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68c1882ed92a0d9731f3c4990a9e56">&#9670;&#160;</a></span>trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::trailing_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-435"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(27);</div>
<div class="line">assert_eq(v.trailing_zeros(), 27);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.trailing_zeros(), 26);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3be06c38681e26a2e4695c90f2edf9c7" name="a3be06c38681e26a2e4695c90f2edf9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be06c38681e26a2e4695c90f2edf9c7">&#9670;&#160;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a "unit" bit-vector of length <span class="tt">n</span> where only element <span class="tt">i</span> is set. </p>
<p>This method panics if the condition <span class="tt">i &lt; n</span> is not met.</p>
<h1 class="doxsection"><a class="anchor" id="example-388"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a3be06c38681e26a2e4695c90f2edf9c7">BitVector&lt;&gt;::unit</a>(10, 0).<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a3be06c38681e26a2e4695c90f2edf9c7">BitVector&lt;&gt;::unit</a>(10, 9).<a class="code hl_function" href="#ad2b8ef3dc6d1ea250253135172bb48e7">to_string</a>(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a3be06c38681e26a2e4695c90f2edf9c7"><div class="ttname"><a href="#a3be06c38681e26a2e4695c90f2edf9c7">gf2::BitVector::unit</a></div><div class="ttdeci">static constexpr BitVector unit(usize n, usize i)</div><div class="ttdoc">Factory method to generate a &quot;unit&quot; bit-vector of length n where only element i is set.</div><div class="ttdef"><b>Definition</b> BitVector.h:226</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a15d5236d2ad3e82c208ee262e67ef893" name="a15d5236d2ad3e82c208ee262e67ef893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d5236d2ad3e82c208ee262e67ef893">&#9670;&#160;</a></span>unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::unset_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-vector. </p>
<p>You can use this iterator to iterate over the unset bits in the bit-vector and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-447"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.unset_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{1, 3, 5, 7, 9}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a214dd0c738e0a17e8d6afda0c55b5962" name="a214dd0c738e0a17e8d6afda0c55b5962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214dd0c738e0a17e8d6afda0c55b5962">&#9670;&#160;</a></span>with_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::with_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct an empty bit-vector with at least the specified capacity. </p>
<h1 class="doxsection"><a class="anchor" id="example-384"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a214dd0c738e0a17e8d6afda0c55b5962">BitVector&lt;&gt;::with_capacity</a>(10);</div>
<div class="line">assert_eq(v.size(), 0);</div>
<div class="line">assert(v.capacity() &gt;=10);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a214dd0c738e0a17e8d6afda0c55b5962"><div class="ttname"><a href="#a214dd0c738e0a17e8d6afda0c55b5962">gf2::BitVector::with_capacity</a></div><div class="ttdeci">static constexpr BitVector with_capacity(usize capacity)</div><div class="ttdoc">Factory method to construct an empty bit-vector with at least the specified capacity.</div><div class="ttdef"><b>Definition</b> BitVector.h:183</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94f28415157fbc4b4486555fe71b98bd" name="a94f28415157fbc4b4486555fe71b98bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f28415157fbc4b4486555fe71b98bd">&#9670;&#160;</a></span>word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns word <span class="tt">i</span> from the bit-vector's underlying word store. </p>
<p>The final word in the store may not be fully occupied but we guarantee that unused bits are set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="panics-116"></a>
Panics</h1>
<p>In debug mode the index is bounds checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-378"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">assert_eq(v.words(), 2);</div>
<div class="line">assert_eq(v.word(0), 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.word(1), 0b0000&#39;0011);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a916cdd15c618a1a2eb2d58d47be5eaba" name="a916cdd15c618a1a2eb2d58d47be5eaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916cdd15c618a1a2eb2d58d47be5eaba">&#9670;&#160;</a></span>words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words in the bit-vector's underlying word store. </p>
<p>The bit-elements are packed into a standard vector with this number of words.</p>
<h1 class="doxsection"><a class="anchor" id="example-377"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a916cdd15c618a1a2eb2d58d47be5eaba">words</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector&lt;u8&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.words(), 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a66ff1e24db7bf631af2d638dd0b620c1" name="a66ff1e24db7bf631af2d638dd0b620c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ff1e24db7bf631af2d638dd0b620c1">&#9670;&#160;</a></span>zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a14c3dd77166009bede404d9de9f20b7f">BitVector</a> <a class="el" href="classgf2_1_1BitVector.html">gf2::BitVector</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-385"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitVector.html">BitVector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
