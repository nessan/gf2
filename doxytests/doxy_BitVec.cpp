// This file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `BitVec.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-21 15:52:45

#include "../include/gf2/BitVec.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    // Trace the source for the tests.
    auto header_file = "BitVec.h";
    std::size_t test_count = 86;
    std::println(stderr, "Running {} tests extracted from: `{}`", test_count, header_file);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for `{}`:", doxy::max_fails, header_file);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    // Run the tests ...
    header_line = 44;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v0;
        assert_eq(v0.size(), 0);
        BitVec<u8> v1(10);
        assert_eq(v1.size(), 10);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 57;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v0;
        assert_eq(v0.words(), 0);
        BitVec<u8> v1(10);
        assert_eq(v1.words(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 72;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        assert_eq(v.words(), 2);
        assert_eq(v.word(0), 0b1111'1111);
        assert_eq(v.word(1), 0b0000'0011);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 91;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(10);
        assert_eq(v.to_string(), "0000000000");
        v.set_word(1, 0b1111'1111);
        assert_eq(v.to_string(), "0000000011");
        assert_eq(v.count_ones(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 109;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 121;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 142;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec u;
        assert_eq(u.to_string(), "");
        BitVec<u8> v{10};
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 159;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec<u8> v{10, u8{0b0101'0101}};
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 176;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::with_capacity(10);
        assert_eq(v.size(), 0);
        assert(v.capacity() >=10);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 190;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::zeros(10);
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 199;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVec<>::ones(10).to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 207;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::constant(10, true);
        assert_eq(v.to_string(), "1111111111");
        auto w = BitVec<>::constant(10, false);
        assert_eq(w.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 220;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVec<>::unit(10, 0).to_string(), "1000000000");
        assert_eq(BitVec<>::unit(10, 9).to_string(), "0000000001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 234;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVec<u8>::alternating(10).to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 243;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 s8 = 0b01010101;
        auto u = BitVec<u8>::from(s8);
        assert_eq(u.size(), 8);
        assert_eq(u.to_string(), "10101010");
        u16 s16 = 0b0101010101010101;
        auto v = BitVec<u8>::from(s16);
        assert_eq(v.size(), 16);
        assert_eq(v.to_string(), "1010101010101010");
        auto w = BitVec<u32>::from(s8);
        assert_eq(w.size(), 8);
        assert_eq(w.to_string(), "10101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 271;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::from(BitVec<u8>::ones(10));
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1111111111");
        auto w = BitVec<u8>::from(BitVec<u16>::ones(20));
        assert_eq(w.size(), 20);
        assert_eq(w.to_string(), "11111111111111111111");
        auto x = BitVec<u8>::from(BitVec<u32>::zeros(10));
        assert_eq(x.size(), 10);
        assert_eq(x.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 294;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        auto v = BitVec<>::from(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 312;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::from(10, [](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 339;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitVec<>::random(10, 0.5, seed);
        auto v = BitVec<>::random(10, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 362;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitVec<>::seeded_random(10, seed);
        auto v = BitVec<>::seeded_random(10, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 377;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVec<>::biased_random(10, 0.3);
        auto v = BitVec<>::biased_random(10, 0.3);
        assert_eq(u.size(), v.size());
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 398;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVec<>::from_string("0b1010_1010_10").value();
        assert_eq(v1.to_string(), "1010101010");
        auto v2 = BitVec<>::from_string("AA").value();
        assert_eq(v2.to_string(), "10101010");
        auto v3 = BitVec<>::from_string("1010'1010").value();
        assert_eq(v3.to_string(), "10101010");
        auto v4 = BitVec<>::from_string("0x1.8").value();
        assert_eq(v4.to_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 439;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::from_binary_string("0b1010'1010'10").value();
        assert_eq(v.to_string(), "1010101010");
        auto u = BitVec<u8>::from_binary_string("").value();
        assert_eq(u.to_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 474;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = gf2::BitVec<>::from_hex_string("0xAA").value();
        assert_eq(v1.to_string(), "10101010");
        auto v2 = gf2::BitVec<>::from_hex_string("0x1").value();
        assert_eq(v2.to_string(), "0001");
        auto v3 = gf2::BitVec<>::from_hex_string("0x1.8").value();
        assert_eq(v3.to_string(), "001");
        auto v4 = gf2::BitVec<>::from_hex_string("0x1.4").value();
        assert_eq(v4.to_string(), "01");
        auto v5 = gf2::BitVec<>::from_hex_string("0x1.2").value();
        assert_eq(v5.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 535;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v0;
        assert_eq(v0.capacity(), 0);
        BitVec<u64> v1(10);
        assert_eq(v1.capacity(), 64);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 546;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec<u64> v1(10);
        assert_eq(v1.remaining_capacity(), 54);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 557;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(1000);
        v.resize(15);
        v.shrink_to_fit();
        assert_eq(v.capacity(), 16);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 584;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(1000);
        v.resize(10);
        assert_eq(v.to_string(), "1111111111");
        v.resize(15);
        assert_eq(v.to_string(), "111111111100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 621;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v;
        v.push(1);
        assert(v.to_string() == "1");
        v.push(0);
        assert(v.to_string() == "10");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 637;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v;
        v.push(1);
        v.push(0);
        assert(v.to_string() == "10");
        auto b1 = v.pop();
        assert_eq(*b1, false);
        assert(v.to_string() == "1");
        auto b2 = v.pop();
        assert_eq(*b2, true);
        assert(v.to_string() == "");
        auto b3 = v.pop();
        assert(b3 == std::nullopt);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 667;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(4);
        u16 src = 0b1010101010101010;
        v.append(src);
        assert_eq(v.to_string(), "11110101010101010101");
        auto w = BitVec<u32>::ones(4);
        w.append(src);
        assert_eq(w.to_string(), "11110101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 691;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(10);
        auto w = BitVec<u16>::ones(10);
        v.append(w);
        assert_eq(v.size(), 20);
        assert_eq(v.to_string(), "00000000001111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 709;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVec v;
        v.append(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 730;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v;
        v.append_digit('A', 16);
        assert_eq(v.to_string(), "1010");
        v.append_digit('X', 16);
        assert_eq(v.to_string(), "1010");
        v.append_digit('1', 8);
        assert_eq(v.to_string(), "1010001");
        v.append_digit('1', 4);
        assert_eq(v.to_string(), "101000101");
        v.append_digit('1', 2);
        assert_eq(v.to_string(), "1010001011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 768;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v;
        v.append_hex_digit('F');
        assert_eq(v.to_string(), "1111");
        v.append_hex_digit('X');
        assert_eq(v.to_string(), "1111");
        v.append_hex_digit('1');
        assert_eq(v.to_string(), "11110001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 801;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        auto w = v.split_off(5);
        assert_eq(v.to_string(), "10101");
        assert_eq(w.to_string(), "01010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 821;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        BitVec dst;
        v.split_off(5, dst);
        assert_eq(v.to_string(), "10101");
        assert_eq(dst.to_string(), "01010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 844;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(22);
        auto x16 = v.split_off_unsigned<u16>();
        assert_eq(*x16, 0b1111'1111'1111'1111);
        assert_eq(v.size(), 6);
        assert_eq(v.to_string(), "111111");
        auto w = BitVec<u8>::alternating(24);
        auto x8 = w.split_off_unsigned<u8>();
        assert_eq(*x8, 0b0101'0101);
        assert_eq(w.size(), 16);
        assert_eq(w.to_string(), "1010101010101010");
        w.append(*x8);
        assert_eq(w.to_string(), "101010101010101010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 910;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 923;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert(v[2] == false);
        v[2] = true;
        assert(v[2] == true);
        assert(v.to_string() == "0010000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 937;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::ones(10);
        assert_eq(v.front(), true);
        v.set_all(false);
        assert_eq(v.front(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 950;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::ones(10);
        assert_eq(v.back(), true);
        v.set_all(false);
        assert_eq(v.back(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 968;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 984;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        v[2] = true;
        assert(v.to_string() == "0010000000");
        auto w = BitVec<>::ones(10);
        v[3] = w[3];
        assert(v.to_string() == "0011000000");
        v[4] |= w[4];
        assert(v.to_string() == "0011100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1001;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        v.flip(0);
        assert_eq(v.to_string(), "0111111111");
        v.flip(1);
        assert_eq(v.to_string(), "0011111111");
        v.flip(9);
        assert_eq(v.to_string(), "0011111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1017;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::zeros(10);
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "0100000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 9);
        assert_eq(v.to_string(), "0000000001");
        v.swap(0, 9);
        assert_eq(v.to_string(), "1000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1039;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v;
        assert_eq(v.is_empty(), true);
        BitVec u{10};
        assert_eq(u.is_empty(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1052;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.any(), false);
        v.set(0);
        assert_eq(v.any(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1065;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{3};
        assert_eq(v.all(), false);
        v.set(0);
        v.set(1);
        v.set(2);
        assert_eq(v.all(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1080;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.none(), true);
        v.set(0);
        assert_eq(v.none(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1097;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(10);
        v.set_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1107;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(10);
        v.flip_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1126;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec<u8> v{16};
        u16 src = 0b1010101010101010;
        v.copy(src);
        assert_eq(v.to_string(), "0101010101010101");
        BitVec<u32> w{16};
        w.copy(src);
        assert_eq(w.to_string(), "0101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1147;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u64>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        v.copy(BitVec<u8>::alternating(10));
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1163;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVec v{10};
        v.copy(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1181;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1199;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec u{10}, v{10};
        u64 seed = 1234567890;
        u.fill_random(0.5, seed);
        v.fill_random(0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1215;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.count_ones(), 0);
        v.set(0);
        assert_eq(v.count_ones(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1226;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.count_zeros(), 10);
        v.set(0);
        assert_eq(v.count_zeros(), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1237;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{37};
        assert_eq(v.leading_zeros(), 37);
        v.set(27);
        assert_eq(v.leading_zeros(), 27);
        auto w = BitVec<u8>::ones(10);
        assert_eq(w.leading_zeros(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1250;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(27);
        assert_eq(v.trailing_zeros(), 27);
        v.set(0);
        assert_eq(v.trailing_zeros(), 26);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1265;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(37);
        assert(v.first_set() == std::optional<usize>{});
        v.set(2);
        assert(v.first_set() == std::optional<usize>{2});
        v.set(2, false);
        assert(v.first_set() == std::optional<usize>{});
        v.set(27);
        assert(v.first_set() == std::optional<usize>{27});
        BitVec empty;
        assert(empty.first_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1282;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(37);
        assert(v.last_set() == std::optional<usize>{});
        v.set(2);
        assert(v.last_set() == std::optional<usize>{2});
        v.set(27);
        assert(v.last_set() == std::optional<usize>{27});
        BitVec empty;
        assert(empty.last_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1297;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(37);
        assert(v.next_set(0) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.next_set(0) == std::optional<usize>{2});
        assert(v.next_set(2) == std::optional<usize>{27});
        assert(v.next_set(27) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1311;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(37);
        assert(v.previous_set(36) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.previous_set(36) == std::optional<usize>{27});
        assert(v.previous_set(27) == std::optional<usize>{2});
        assert(v.previous_set(2)  == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1329;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(37);
        assert(v.first_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.first_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.first_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.first_unset() == std::optional<usize>{27});
        BitVec empty;
        assert(empty.first_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1346;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(37);
        assert(v.last_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.last_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.last_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.last_unset() == std::optional<usize>{27});
        BitVec empty;
        assert(empty.last_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1363;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(37);
        assert(v.next_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.next_unset(0) == std::optional<usize>{2});
        assert(v.next_unset(2) == std::optional<usize>{27});
        assert(v.next_unset(27) == std::optional<usize>{});
        BitVec empty;
        assert(empty.next_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1379;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(37);
        assert(v.previous_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.previous_unset(36) == std::optional<usize>{27});
        assert(v.previous_unset(27) == std::optional<usize>{2});
        assert(v.previous_unset(2) == std::optional<usize>{});
        BitVec empty;
        assert(empty.previous_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1404;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVec<u8>::ones(10);
        for (auto&& bit : u.bits()) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1418;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::zeros(10);
        for (auto&& bit : v.bits()) bit = true;
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1430;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.set_bits());
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1443;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.unset_bits());
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1462;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        auto words = std::ranges::to<std::vector>(v.store_words());
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1475;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        auto words = v.to_words();
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1493;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1507;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1111101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1526;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        auto s = v.sub(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1553;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        BitVec left, right;
        v.split_at(5, left, right);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1575;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        auto [left, right] = v.split_at(5);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1596;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        BitVec<u8> dst;
        v.riffled(dst);
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1611;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<u8>::ones(10);
        auto dst = v.riffled();
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1631;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.to_binary_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_binary_string(), "1000000000");
        assert_eq(v.to_binary_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1652;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v{10};
        assert_eq(v.to_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        assert_eq(v.to_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1669;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVec<>::alternating(10);
        assert_eq(v.to_pretty_string(), "[1,0,1,0,1,0,1,0,1,0]");
        BitVec empty;
        assert_eq(empty.to_pretty_string(), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1696;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVec v0;
        assert_eq(v0.to_hex_string(), "");
        auto v1 = BitVec<>::ones(4);
        assert_eq(v1.to_hex_string(), "F");
        auto v2 = BitVec<>::ones(5);
        assert_eq(v2.to_hex_string(), "F1.2");
        auto v3 = BitVec<>::alternating(8);
        assert_eq(v3.to_binary_string(), "10101010");
        assert_eq(v3.to_hex_string(), "AA");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    // Print a summary of the tests results.
    if (fails == 0) {
        std::println(stderr, "[{}] All {} tests PASSED", header_file, test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Test FAIL summary for `{}`: Ran {} of a possible {} tests, PASSED: {}, FAILED: {}", header_file, test, test_count, test - fails, fails);
        std::print(stderr, "--------------------------------------------------------------------------------------");
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}