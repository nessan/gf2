<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: The &lt;tt&gt;BitStore&lt;/tt&gt; Concept</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2pages_2BitStore.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The <span class="tt">BitStore</span> Concept </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="the-bitstore-concept"></a></p>
<h1 class="doxsection"><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>The library's vector-like types satisfy the <span class="tt">BitStore</span> [concept]:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">gf2::BitArray</a></span>  </td><td class="markdownTableBodyNone">A fixed-size array of bits packed into a <span class="tt">std::array</span> of unsigned words.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span>  </td><td class="markdownTableBodyNone">A dynamically sized vector of bits packed into a <span class="tt">std::vector</span> of unsigned words.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>  </td><td class="markdownTableBodyNone">A non-owning <em>view</em> of some span of bits held by one of the two previous types.  </td></tr>
</table>
<p>These types own or view individual bit elements packed into some underlying "store" of <span class="tt">Unsigned</span> words. The particular choice of <span class="tt">Word</span> is generic and user selectable from one of the primitive unsigned integer types. We refer to any type that implements the <span class="tt">BitStore</span> trait as a <em>bit-store</em>.</p>
<p>Bit-stores have <em>dozens</em> of methods in common. That <span class="tt">BitStore</span> concept defines the requirements for implementing the shared functionality <em>once</em> as associated methods of the trait. Each concrete bit-store type forwards many methods to the equivalent free function that operates on generic <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> arguments.</p>
<p>The functions include bit accessors, mutators, fills, queries, iterators, stringification methods, bit-wise operators, arithmetic operators, and more. Operations on and between bit-stores work on a whole-word basis, so are inherently parallel.</p>
<dl class="section note"><dt>Note</dt><dd>For convenience, the free functions that work on bit-stores are also pulled directly into the three vector-like classes as <em>member functions</em>. For example, if <span class="tt">v</span> is a bit-vector, you can call <span class="tt">v.count_ones()</span> to count the number of set bits in <span class="tt">v</span> instead of calling the free function <span class="tt">gf2::count_ones(v)</span> though both forms are valid.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="concept-requirements"></a>
Concept Requirements</h1>
<p>Bit-stores all own, or view, a store of bits packed into contiguous "words", where a word is some <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">gf2::Unsigned</a></span>. Operations on and between bit-stores work a whole word at a time, so are inherently parallel. The particular unsigned integer type used to hold the bits must be exposed as a class-level typename.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Required Type  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">word_type</span>  </td><td class="markdownTableBodyNone">The bit-store holds or views bits in contiguous words of this <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">gf2::Unsigned</a></span> type.  </td></tr>
</table>
<p>To satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, a class should also define the following seven methods:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Required Method  </th><th class="markdownTableHeadNone">Return Type  </th><th class="markdownTableHeadNone">Expected Return Value/Method Functionality  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">size</span>  </td><td class="markdownTableBodyNone"><span class="tt">usize</span>  </td><td class="markdownTableBodyNone">The number of accessible bits in the object.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">store const</span>  </td><td class="markdownTableBodyNone"><span class="tt">word_type const*</span>  </td><td class="markdownTableBodyNone">A const pointer to the first real underlying word.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">store</span>  </td><td class="markdownTableBodyNone"><span class="tt">word_type*</span>  </td><td class="markdownTableBodyNone">A non-const pointer to the first real underlying word.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">offset</span>  </td><td class="markdownTableBodyNone"><span class="tt">u8</span>  </td><td class="markdownTableBodyNone">The offset in bits to the first element in <span class="tt">store()[0]</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">words</span>  </td><td class="markdownTableBodyNone"><span class="tt">usize</span>  </td><td class="markdownTableBodyNone">The <em>minimum</em> number of words needed to store those bits.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">word(i)</span>  </td><td class="markdownTableBodyNone"><span class="tt">word_type</span>  </td><td class="markdownTableBodyNone">A copy of "word" number <span class="tt">i</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">set_word(i,v)</span>  </td><td class="markdownTableBodyNone"><span class="tt">void</span>  </td><td class="markdownTableBodyNone">Set the accessible bits in "word" <span class="tt">i</span> to those from <span class="tt">v</span>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>We could implement the last three methods above using the first four. For example, the <span class="tt">words</span> method is a trivial computation based on <span class="tt">size</span> and the number of bits per underlying word. However, all the concrete bit-store types already cache the required value, so we use that instead. Every hot loop in the library calls <span class="tt">words()</span>, and benchmarking shows that precomputing the value <em>significantly</em> improves performance. Having optimised versions of the <span class="tt">word(i)</span> and <span class="tt">set_word(i,v)</span> methods has an even larger impact on performance.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="other-notes"></a>
Other Notes</h2>
<ul>
<li>The underlying store must contain enough words of storage to accommodate <span class="tt">size</span> bits.</li>
<li>The <span class="tt">words</span> method always returns the same number as <span class="tt">words_needed&lt;Word&gt;(size())</span> but cached as this value is in constant use.</li>
<li>The store's final word can have extra unused bits, but the <span class="tt">word</span> method should always set those unused bits to zero.</li>
<li>The <span class="tt">set_word</span> method sets a "word" to a passed value, being careful to only have an effect on <em>accessible</em> bits in the store.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="example"></a>
Example</h2>
<p>The methods are trivial to implement for <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">gf2::BitArray</a></span> and <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span>.</p>
<p>Here is a sketch of how they might work for the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> class which stores <span class="tt">m_size</span> bits in a <span class="tt">std::vector&lt;Word&gt;</span> called <span class="tt">m_store</span>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;Un<span class="keywordtype">signed</span> Word = usize&gt;                                    <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">class </span>BitVector {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    usize m_size;</div>
<div class="line">    std::vector&lt;Word&gt; m_store;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>word_type = Word;                                         <span class="comment">// &lt;2&gt;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> usize size()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> m_size; }          <span class="comment">// &lt;3&gt;</span></div>
<div class="line">    <span class="keyword">constexpr</span> Word <span class="keyword">const</span>* store()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_store.data(); }</div>
<div class="line">    <span class="keyword">constexpr</span> Word* store()             { <span class="keywordflow">return</span> m_store.data(); }</div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> offset()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> 0; }</div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> words()<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> m_store.size(); }</div>
<div class="line">    <span class="keyword">constexpr</span> Word word(usize i)<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> m_store[i]; }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> set_word(usize i, Word v) { m_store[i] = v; }    <span class="comment">// &lt;4&gt;</span></div>
<div class="line">};</div>
<div class="ttc" id="anamespacegf2_html_a872a69469085fcdddf299ae4adc3c940"><div class="ttname"><a href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">gf2::u8</a></div><div class="ttdeci">std::uint8_t u8</div><div class="ttdoc">Word type alias for an 8-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:30</div></div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --><ol type="1">
<li>The template parameter <span class="tt">Word</span> is the unsigned integer type used to store the bits in the bit-vector. It defaults to <span class="tt">usize</span>, which is typically the most efficient type for the target platform.</li>
<li>The <span class="tt">BitStore</span> concept requires a <span class="tt">word_type</span> typename.</li>
<li>The required <span class="tt">BitStore</span> methods are all trivially implemented, though the real implementation allows for range checks if the compile-time <span class="tt">DEBUG</span> flag is present.</li>
<li>In this simple sketch, the <span class="tt">set_word</span> method directly sets the underlying word. The real implementation is careful to avoid touching unoccupied bits in the final word.</li>
</ol>
<p>A sketch of the <span class="tt">BitArray</span> class is similar, except that the underlying store is a <span class="tt">std::array</span> of words rather than a <span class="tt">std::vector</span>.</p>
<h2 class="doxsection"><a class="anchor" id="bit-spans"></a>
Bit-spans</h2>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> class is a bit different because it is a non-owning view into some contiguous subset of bits held by another bit-store, and that subset may not align with the underlying words.</p>
<p>However, all <span class="tt">BitStore</span> related functions operate <em>as if</em> bit element 0 in the store is the <b>lowest-order</b> bit of "word" <b>0</b>. This constraint means that the implementation of the <span class="tt">word(i)</span> and <span class="tt">set_word(i,v)</span> methods for <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> is more complex than for the other two bit-stores because they often have to synthesise words from two underlying words in the real store.</p>
<h3 class="doxsection"><a class="anchor" id="sample-layout"></a>
Sample Layout</h3>
<p>Consider a bit-store <span class="tt">store</span> with 20 elements, where the <span class="tt">Word</span> type used to store those bits is an unsigned 8-bit integer.</p>
<p>The <span class="tt">BitStore</span> functions all naturally expect that <span class="tt">store.size()</span> returns 20. Less obviously, they all expect <span class="tt">store.words()</span> to return 3, as it takes three 8-bit words to hold 20 bits with four bits to spare.</p>
<p>The functions expect that <span class="tt">store.word(0)</span> holds the first 8 bits in the bit-store, <span class="tt">store.word(1)</span> has the following 8 bits, and <span class="tt">store.word(2)</span> holds the final four elements in its four lowest order bits. It also expects that the four highest "unoccupied" bits in <span class="tt">store.word(2)</span> are set to 0.</p>
<p>If the store is a bit-array or a bit-vector, the implementation of these <span class="tt">BitStore</span> expectations is easy. Those classes just have to be careful to ensure that any unoccupied high-order bits in the final word remain zeros.</p>
<p>It is a different matter for a bit-span, which isn't usually zero-aligned with the real underlying array of unsigned words, <span class="tt">w[0]</span>, <span class="tt">w[1]</span>, ... The various bit-store functions still expect that <span class="tt">store.words()</span> returns three even though the span may touch bits in <em>four</em> underlying words!</p>
<p>For a bit-span, the return value for <span class="tt">store.word(i)</span> will often be synthesised from two contiguous "real" words <span class="tt">w[j]</span> and <span class="tt">w[j+1]</span> for some <span class="tt">j</span>. <span class="tt">store.word[i]</span> will use some high-order bits from <span class="tt">w[j]</span> and low-order bits from <span class="tt">w[j+1]</span>.</p>
<p>The following diagram shows how bits in a bit-slice lie within the underlying words, which are <span class="tt">u8</span>s in this example:</p>
<div class="image">
<object type="image/svg+xml" data="bit-span.svg" style="pointer-events: none;"></object>
<div class="caption">
A bit-span with 20 elements, where the `X` is always zero</div></div>
    <p>The <span class="tt">BitSpan</span> class must always behave <em>as if</em> bits from the real underlying store were copied and shuffled down so that element zero is bit 0 of word 0 in the bit-span. However, it never actually copies anything; instead, it synthesises "words" as needed.</p>
<p>The same principle applies to the <span class="tt">store.set_word(i, value)</span> method. The implementation of <span class="tt">set_word</span> for bit-vectors and bit-arrays is trivial, with the one caveat that we have to be careful not to inadvertently touch any unoccupied bits in the final underlying word, or at least be sure to leave them as zeros.</p>
<p>In the case of a bit-span, calls to <span class="tt">set_word(i, value)</span> will generally copy low-order bits from <span class="tt">value</span> into the high-order bits of some real underlying word <span class="tt">w[j]</span> and copy the rest of the high-order bits from <span class="tt">value</span> into the low-order bits of <span class="tt">w[j+1]</span>. The other bits in <span class="tt">w[j]</span> and <span class="tt">w[j+1]</span> will not be touched.</p>
<h1 class="doxsection"><a class="anchor" id="functions-overview"></a>
Functions Overview</h1>
<p>We provide dozens of useful free functions in the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> namespace that operate on any bit store.</p>
<p>The first argument to each function is a reference to a type that satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, for example, the following function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;BitStore Store&gt;</div>
<div class="line"><span class="keywordtype">void</span> set_all(Store&amp; store, <span class="keywordtype">bool</span> value = <span class="keyword">true</span>) { ... }</div>
</div><!-- fragment --><p>sets all the bits in the passed <span class="tt">store</span> to the given <span class="tt">value</span>.</p>
<p>The provided functions fall into categories:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-bit-access">Bit Access</a>  </td><td class="markdownTableBodyNone">Functions to access individual bit elements in a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#store-queries">Queries</a>  </td><td class="markdownTableBodyNone">Functions to query the overall state of a bit-store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-mutators">Mutators</a>  </td><td class="markdownTableBodyNone">Functions to mutate the overall state of a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#store-fills">Fills</a>  </td><td class="markdownTableBodyNone">Functions to fill a bit-store from various sources.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-exports">Exports</a>  </td><td class="markdownTableBodyNone">Functions to export the bits in a bit-store to various destinations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#store-spans">Spans</a>  </td><td class="markdownTableBodyNone">Functions to create non-owning views over a part of a bit-store &mdash; <em>bit-spans</em>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-sub-vectors">Sub-vectors</a>  </td><td class="markdownTableBodyNone">Functions to clone a piece of a bit-store as a new bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#store-riffling">Riffling</a>  </td><td class="markdownTableBodyNone">Functions to create vectors that copy a bit-store with interleaved zeros.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-indices">Set/Unset Indices</a>  </td><td class="markdownTableBodyNone">Functions to find the indices of set &amp; unset bits in a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#store-iterators">Iterators</a>  </td><td class="markdownTableBodyNone">Functions to create various iterators over a bit-store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#store-stringification">Stringification</a>  </td><td class="markdownTableBodyNone">Functions to create string representations of a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare two bit-stores for equality.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in a bit-store left or right.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine two bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract two bit-stores.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation, etc. for bit-stores.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="store-bit-access"></a>
Bit Access</h1>
<p>The following functions provide access to individual bit elements in the bit-store.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a690f9210e98f6a9615fc5b9cabd67cd3" title="Returns the bool value of the bit at index i in the given bit-store.">gf2::get</a></span>  </td><td class="markdownTableBodyNone">Returns the value of a single bit element as a read-only boolean.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a44a358ee6c3e8f2c57c85745d37f867f" title="Returns a &quot;reference&quot; to the bit element i in the given bit-store.">gf2::ref</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitRef</span> with read-write access to a single bit element.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#abd42e52e9163fa845d30cc5ff02d7a7c" title="Returns true if the first bit element is set, false otherwise.">gf2::front</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the first element in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a6ea9570ad5ef2845429ce2e5aa2faa52" title="Returns true if the final bit element is set, false otherwise.">gf2::back</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the last element in the store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a0185d340520fd8519443cff59ddbe8a2" title="Sets the bit-element at the given index to the specified boolean value (default value is true).">gf2::set</a></span>  </td><td class="markdownTableBodyNone">Sets a bit to the given boolean value, which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#aa424649d48359d85a30260dc0de4835a" title="Flips the value of the bit-element at the given index.">gf2::flip</a></span>  </td><td class="markdownTableBodyNone">Flips the value of the bit element at a given index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a23cbb1ad7a7a0ce5c2f8835564cc21ec" title="Swaps the bits in the bit-store at indices i0 and i1.">gf2::swap</a></span>  </td><td class="markdownTableBodyNone">Swaps the values of bit elements at locations <span class="tt">i</span> and <span class="tt">j</span>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You can set the <span class="tt">DEBUG</span> flag at compile time to enable bounds checks on the index arguments.</dd></dl>
<p>The <span class="tt">ref(store, i)</span> function returns a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">gf2::BitRef</a></span>, which is a "reference" to an individual bit in the store. It is automatically converted to a boolean on reads, but it also allows writes.</p>
<p>This is equivalent to calling <span class="tt">set(v, 12, true);</span>.</p>
<h1 class="doxsection"><a class="anchor" id="store-queries"></a>
Queries</h1>
<p>The following functions let you query the overall state of a bit-store.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a2008016cc135d5c4738ac1cfbcb411a4" title="Returns true if the store is empty, false otherwise.">gf2::is_empty</a></span>  </td><td class="markdownTableBodyNone">Returns true if the store is empty  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ad419c2360bc8c7b34615ecde32abc746" title="Returns true if at least one bit in the store is set, false otherwise.">gf2::any</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>any</em> bit in the store is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a887e28712d4d2013d795f9ee560ff793" title="Returns true if all bits in the store are set, false otherwise.">gf2::all</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>every</em> bit in the store is set.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ac257bfdd661157913f820bcd96ced815" title="Returns true if no bits in the store are set, false otherwise.">gf2::none</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>no</em> bit in the store is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#aa8fd09a196762464e1cffe2941779149" title="Returns the number of set bits in the store.">gf2::count_ones</a></span>  </td><td class="markdownTableBodyNone">Returns the number of set bits in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a52986a212b068f596f525deb963d8f59" title="Returns the number of unset bits in the store.">gf2::count_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of unset bits in the store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#aa9ee66f54ef560ada72c85ce60ebab33" title="Returns the number of leading zeros in the store.">gf2::leading_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of leading unset bits in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#abdf2434cc208bb1633add06c3619bf06" title="Returns the number of trailing zeros in the store.">gf2::trailing_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of trailing unset bits in the store.  </td></tr>
</table>
<p>These methods efficiently operate on words at a time, so they are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="store-mutators"></a>
Mutators</h1>
<p>The following functions let you mutate the entire store in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a03ce4352f6f0b4a759b7bb7d880928df" title="Sets the bits in the store to the boolean value.">gf2::set_all</a></span>  </td><td class="markdownTableBodyNone">Sets all the bits in the store to the passed value, which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a94314a30722546a006db2f38a2b8a054" title="Flips the value of the bits in the store.">gf2::flip_all</a></span>  </td><td class="markdownTableBodyNone">Flips the values of all the bits in the store.  </td></tr>
</table>
<p>They efficiently operate on words at a time, so they are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="store-fills"></a>
Copies &amp; Fills</h1>
<p>The following functions let you populate the entire store from multiple sources in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ab9a3ab2cfb7f67f6b195372d0e66e734" title="Copies all the bits from any unsigned integral src value to an equal-sized bit-store.">gf2::copy</a></span>  </td><td class="markdownTableBodyNone">Copies bit values from various sources to this store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ac6cf8bbef5f96104b2e770e54abdd08a" title="Fill the store with random bits based on an optional probability p and an optional seed for the RNG.">gf2::fill_random</a></span>  </td><td class="markdownTableBodyNone">Fills the store with random 0's and 1's.  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="copies"></a>
Copies</h2>
<p>The <span class="tt">copy</span> function is overloaded to copy bit values from various sources into a destination bit-store, where the size of destination bit-store <b>must</b> match the number of bits in the source:</p>
<ul>
<li>Another bit-store of the same size but possibly a different underlying word type.</li>
<li>A single unsigned integer value, which need not be the same type as the underlying <span class="tt">Word</span> used by the bit-store.</li>
<li>An iteration of unsigned integer values, which need not be the same type as the underlying <span class="tt">Word</span> used by the bit-store.</li>
<li>A function or callable object that takes a single <span class="tt">usize</span> index argument and returns a boolean value for that index.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> of the same size as the bit-store.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In each case, the <em>number of bits</em> in the source and destination must match exactly and that condition is always checked unless the <span class="tt">NDEBUG</span> flag is set at compile time. You can always use a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> to copy a subset of bits if needed. However, the underlying <em>word types</em> need <b>not</b> match, so you can copy between bit-stores that use different underlying word types. You can use the <span class="tt"><a class="el" href="namespacegf2.html#ab9a3ab2cfb7f67f6b195372d0e66e734" title="Copies all the bits from any unsigned integral src value to an equal-sized bit-store.">gf2::copy</a></span> method to convert between different <span class="tt">Word</span> type stores (e.g., from <span class="tt">BitVector&lt;u32&gt;</span> to <span class="tt">BitVector&lt;u8&gt;</span>) as long as the size of the source and destinations match.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="random-fills"></a>
Random Fills</h2>
<p>By default, the random fill method uses a random number generator seeded with system entropy, so the results change from run to run. You can set a specific seed to get reproducible fills.</p>
<p>The default probability that a bit is set is 50%, but you can pass a different probability in the range <span class="tt">[0.0, 1.0]</span> if desired.</p>
<h1 class="doxsection"><a class="anchor" id="store-exports"></a>
Exports</h1>
<p>The following overloaded function lets you export the bits in the bit-store to various destinations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#abda627169916e771d25c9a1af8dad123" title="Returns a copy of the words underlying this bit-store and puts them into the passed output iterator.">gf2::to_words</a></span>  </td><td class="markdownTableBodyNone">Exports the bits in the bit-store as unsigned words.  </td></tr>
</table>
<p>The `<span class="tt"><a class="el" href="namespacegf2.html#abda627169916e771d25c9a1af8dad123" title="Returns a copy of the words underlying this bit-store and puts them into the passed output iterator.">gf2::to_words</a></span> function can be passed an output iterator to fill where we assume:</p>
<ul>
<li>The output iterator points to a location that can accept values of the underlying word type.</li>
<li>There is enough space at the output location to hold all those words.</li>
</ul>
<p>If <span class="tt"><a class="el" href="namespacegf2.html#abda627169916e771d25c9a1af8dad123" title="Returns a copy of the words underlying this bit-store and puts them into the passed output iterator.">gf2::to_words</a></span> is called with no argument it returns a new <span class="tt">std::vector</span> of the bit-store's underlying word type.</p>
<p><b>Note:</b> The final word in the output may have unused high-order bits that are guaranteed to be set to zero.</p>
<h1 class="doxsection"><a class="anchor" id="store-spans"></a>
Spans</h1>
<p>The following functions let you create a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>, which is a non-owning view of some contiguous subset of bits in the store.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a91642aa97f8c3823b3630dde99574a8b" title="Constructs a read-only bit-span over the const bit-store store for its bits in the range [begin,...">gf2::span</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="namespacegf2.html#a91642aa97f8c3823b3630dde99574a8b" title="Constructs a read-only bit-span over the const bit-store store for its bits in the range [begin,...">gf2::span</a></span> function &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;BitStore Store&gt;</div>
<div class="line"><span class="keyword">auto</span> span(Store&amp; store, usize begin, usize end); <span class="comment">// &lt;1&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;BitStore Store&gt;</div>
<div class="line"><span class="keyword">auto</span> span(Store <span class="keyword">const</span>&amp; store, usize begin, usize end); <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that allows modification of the bits in the specified range.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that does not allow modification of the bits in the specified range.</li>
</ol>
<p>In both cases, the <span class="tt">begin</span> and <span class="tt">end</span> arguments define a half-open range of bits in the store.</p>
<p>Mutability/immutability of the returned <span class="tt">BitSpan</span> is <em>deep</em>. The span's mutability reflects that of the underlying store, so if the store is mutable, so is the span, and vice versa.</p>
<p>This is similar to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span.html"><span class="tt">std::span</span></a> class for regular data collection types.</p>
<dl class="section note"><dt>Note</dt><dd>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> also satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, so you can take a span of a span.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="store-sub-vectors"></a>
Sub-vectors</h1>
<p>The following functions create or fill <em>independent</em> bit-vectors with copies of some contiguous subset of the bits in the store.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a8fe2ab8650590f082f800d223fdd6422" title="Returns a clone of the elements in the half-open range [begin, end) as a new bit-vector.">gf2::sub</a></span>  </td><td class="markdownTableBodyNone">Returns a new <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a56284774b49c6d8b626c41eb23c285db" title="Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively....">gf2::split</a></span>  </td><td class="markdownTableBodyNone">Fills two bit-vectors with the bits in the ranges <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span>.  </td></tr>
</table>
<p>The <span class="tt">split_</span> method can optionally take two pre-existing bit-vectors to fill, thereby avoiding unnecessary allocations in some iterative algorithms that repeatedly use this method.</p>
<dl class="section note"><dt>Note</dt><dd>These methods do not alter the underlying store.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="store-riffling"></a>
Riffling</h1>
<p>We have functions that can interleave (<em>riffle</em>) the bits in a store with zeros.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ac462028756047a28bd47ba5134841371" title="Interleaves the bits of a bit-store with zeros storing the result into the passed bit-vector dst.">gf2::riffle</a></span>  </td><td class="markdownTableBodyNone">Fills a pre-existing bit-vector with the result of riffling this store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ac462028756047a28bd47ba5134841371" title="Interleaves the bits of a bit-store with zeros storing the result into the passed bit-vector dst.">gf2::riffle</a></span>  </td><td class="markdownTableBodyNone">Returns a new bit-vector that is this store with its bits interleaved with zeros.  </td></tr>
</table>
<p>If the store looks like \(v_0 v_1 v_2 \ldots v_n\), then the riffling operation produces the vector \(v_0 0 v_1 0 v_2 0 \ldots v_n\) where a zero is interleaved <em>between</em> every bit in the original store (there is no trailing zero at the end).</p>
<p>If you think of a bit-store as representing the coefficients of a polynomial over GF(2), then riffling corresponds to squaring that polynomial. See the documentation for <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html#a30309419a9ed46754fc450052ef19bfb" title="Fills dst with the square of this bit-polynomial.">gf2::BitPolynomial::squared</a></span> for more information.</p>
<h1 class="doxsection"><a class="anchor" id="store-indices"></a>
Set/Unset Bit Indices</h1>
<p>The following functions find the indices of set or unset bits in the store.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a1f962bf6ba97b31c476d19c37da8bd05" title="Returns the index of the first set bit in the bit-store or {} if no bits are set.">gf2::first_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first set bit in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#afa87a762ead610d0d0e20e54e3380d7d" title="Returns the index of the last set bit in the bit-store or {} if no bits are set.">gf2::last_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last set bit in the store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a84d33fc3ba98b78ab3ad44fba88df2c1" title="Returns the index of the next set bit after index in the store or {} if no more set bits exist.">gf2::next_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next set bit in the store <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a7acc8bbe9a3578c1d8b9e8659c2bd891" title="Returns the index of the previous set bit before index in the store or {} if there are none.">gf2::previous_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous set bit in the store <em>before</em> the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a044dac4df02b26e8d4713a39ce170e7d" title="Returns the index of the first unset bit in the bit-store or {} if no bits are unset.">gf2::first_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first unset bit in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ad8089c96553359e761a5916ce39c420c" title="Returns the index of the last unset bit in the bit-store or {} if no bits are unset.">gf2::last_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last unset bit in the store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a2253deaf8dec9af0a0b3e3f4af24f49d" title="Returns the index of the next unset bit after index in the store or {} if no more unset bits exist.">gf2::next_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next unset bit in the store <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#aaee9a90d260c8210b965a7b9aaf54570" title="Returns the index of the previous unset bit before index in the store or {} if no more unset bits exi...">gf2::previous_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous unset bit in the store <em>before</em> the passed index.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="store-iterators"></a>
Iterators</h1>
<p>The following functions create iterators for traversing the bits or underlying words in the store:</p>
<ul>
<li>Read-only iteration through the individual bits.</li>
<li>Read-write iteration through the individual bits.</li>
<li>Read-only iteration through the indices of the set bits.</li>
<li>Read-only iteration through the indices of the unset bits.</li>
<li>Read-write iteration through the underlying store words.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a9505618cfe91d94fb220381ca468058e" title="Returns a const iterator over the bool values of the bits in the const bit-store.">gf2::bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> iterator over the bits in the store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a6c46a7570efd21105aa42c7d14c997d1" title="Returns an iterator over the indices of any set bits in the bit-store.">gf2::set_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1SetBits.html" title="An iterator over the index locations of the set bits in a bit-store.   You get this iterator by calli...">gf2::SetBits</a></span> iterator to view the indices of all the set bits.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a976e9da1d5515af13d3d805fa2339b58" title="Returns an iterator over the indices of any unset bits in the bit-store.">gf2::unset_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1UnsetBits.html" title="An iterator over the index locations of the unset bits in a bit-store.  You get this iterator by call...">gf2::UnsetBits</a></span> iterator to view the indices of all the unset bits.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a832a9327ac2dac0ce3ebe50f6fed021d" title="Returns a const iterator over all the words underlying the bit-store.">gf2::store_words</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Words.html" title="An iterator over the &quot;words&quot; underlying a bit-store.  You get this iterator by calling the BitStore::...">gf2::Words</a></span> iterator to view the "words" underlying the store.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="namespacegf2.html#a9505618cfe91d94fb220381ca468058e" title="Returns a const iterator over the bool values of the bits in the const bit-store.">gf2::bits</a></span> function &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;BitStore Store&gt;</div>
<div class="line"><span class="keyword">auto</span> bits(Store&amp; store); <span class="comment">// &lt;1&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;BitStore Store&gt;</div>
<div class="line"><span class="keyword">auto</span> bits(Store <span class="keyword">const</span>&amp; store); <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that allows modification of the bits in the store.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that only allows one to view the bits in the store.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="store-stringification"></a>
Stringification</h1>
<p>The following functions returns a string representation of a bit store. The string can be in the obvious binary format or a more compact hex format.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a355af2e0599965ef8d4eada941eee8e3" title="Returns a binary string representation of a store.">gf2::to_string</a></span>  </td><td class="markdownTableBodyNone">Returns a default string representation for a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a75fa1cd092371f7093307f09dbd71c55" title="Returns a &quot;pretty&quot; string representation of a store.">gf2::to_pretty_string</a></span>  </td><td class="markdownTableBodyNone">Returns a "pretty" string representation for a bit-store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#af1900fd540d8f3670454d39b003d9667" title="Returns a binary string representation of a store.">gf2::to_binary_string</a></span>  </td><td class="markdownTableBodyNone">Returns a binary string representation for a bit-store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#aa8641a61d375c82684b921764e373cce" title="Returns the &quot;hex&quot; string representation of the bits in the bit-store.">gf2::to_hex_string</a></span>  </td><td class="markdownTableBodyNone">Returns a compact hex string representation for a bit-store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">operator&lt;&lt;(Store const&amp;,std::ostream&amp;)</span>  </td><td class="markdownTableBodyNone">The usual output stream output stream operator for bit-stores.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">struct std::formatter&lt;<a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a>&gt;</span>  </td><td class="markdownTableBodyNone">Specialisation of <a href="https://en.cppreference.com/w/cpp/utility/format/formatter.html"><span class="tt">std::formatter</span></a> for bit-stores.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="string-encodings"></a>
String Encodings</h1>
<p>A bit-store has two different string representations: as a binary string or as a compact hex string. The two encodings are:</p>
<h2 class="doxsection"><a class="anchor" id="binary-string-encoding"></a>
Binary String Encoding</h2>
<p>The straightforward character encoding for a bit-store is a <em>binary</em> string containing just 0's and 1's, for example, <span class="tt">"10101"</span>. Each character in a binary string represents a single element in the store. The <span class="tt">to_binary_string</span> method produces this string. The method allows for an optional prefix, suffix, and separator between each bit.</p>
<p>The <span class="tt">to_string</span> calls <span class="tt">to_binary_string</span> to produce the most compact output, e.g. <span class="tt">"10101"</span>. The <span class="tt">to_pretty_string</span> method produces a more human-friendly version, e.g., <span class="tt">"[1 0 1 0 1]"</span>.</p>
<p>The format used by the output stream operator is the same as that used by <span class="tt">to_string</span>. That is also the default format used by the <span class="tt">std::formatter</span> specialisation. However, you can use a <span class="tt">:p</span> format specifier to get the "pretty" version instead. For example, if <span class="tt">std::format("{}, v)</span> is <span class="tt">"1010101010"</span>, then <span class="tt">std::format("{:p}", v)</span> is <span class="tt">"[1 0 1 0 1 0 1 0 1 0]"</span>.</p>
<dl class="section note"><dt>Note</dt><dd>The output is in <em>vector order</em> <span class="tt">v[0] v[1] v[2] ...</span> with the first element in the vector on the left. This is in contrast to a <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> which puts its lowest indexed element on the right.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="hex-string-encoding"></a>
Hex String Encoding</h2>
<p>The other supported encoding for bit-stores is a compact hex-type string containing just the 16 hex characters <span class="tt">0123456789ABCDEF</span>. For example, the string <span class="tt">"3ED02"</span>. We allow for hex strings with an optional prefix <span class="tt">"0x"</span> or <span class="tt">"0X"</span>, for example <span class="tt">"0x3ED02"</span>.</p>
<p>Each hex character translates to <em>four</em> elements in a <span class="tt">BitStore</span>. The hex string <span class="tt">0x0</span> is equivalent to the binary string <span class="tt">0000</span>, and so on, up to the string <span class="tt">0xF</span>, which is equivalent to the binary string <span class="tt">1111</span>.</p>
<p>The hex pair <span class="tt">0x0F</span> will be interpreted in the store as the eight-bit value <span class="tt">00001111</span>. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.</p>
<p>However, what happens if you want to encode a vector whose size is <em>not</em> a multiple of 4? We handle that by allowing the final character in the string to have a base that is <em>not</em> 16. To accomplish that, we allow for an optional <em>suffix</em>, which must be one of <span class="tt">.2</span>, <span class="tt">.4</span>, or <span class="tt">.8</span>. If present, the suffix gives the base for just the <em>preceding</em> character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex-encoded, as with all the others.</p>
<p>Therefore, the string <span class="tt">0x1</span> (without a suffix, so the last character is the default hexadecimal base 16) is equivalent to <span class="tt">0001</span>. On the other hand, the string <span class="tt">0x1.8</span> (the last character is base 8) is equivalent to <span class="tt">001</span>. Similarly, the string <span class="tt">0x1.4</span> (the last character is base 4) is equivalent to <span class="tt">01,</span> and finally, the string <span class="tt">0x1.2</span> (the previous character is base 2) is comparable to <span class="tt">1</span></p>
<p>In the string <span class="tt">0x3ED01.8</span>, the first four characters, <span class="tt">3</span>, <span class="tt">E</span>, <span class="tt">D</span>, and <span class="tt">0</span>, are interpreted as hex values, and each will translate to four slots in the store. However, the final 1.8 is parsed as an octal 1, which takes up three slots (001). Therefore, this store has a size of 19 (i.e., 4  4 + 3).</p>
<p>The <span class="tt">std::formatter</span> specialisation recognises the <span class="tt">:x</span> format specifier as a request to produce a hex string representation of a bit-store. For example, if <span class="tt">std::format("{}, v)</span> is <span class="tt">"1010101010"</span>, then <span class="tt">std::format("{:x}", v)</span> is <span class="tt">"AA2.4"</span>.</p>
<h1 class="doxsection"><a class="anchor" id="equality-operator"></a>
Equality Operator</h1>
<p>As you'd expect, equality between two bit-stores tests whether they have identical content. It <b>also</b> requires that the two stores use the same underlying word type.</p>
<p>With a few well-documented exceptions, the library avoids interactions between bit-stores with different word types. While it is possible to implement cross-type interactions, such as comparing a <span class="tt">BitStore&lt;uint32_t&gt;</span> with a <span class="tt">BitStore&lt;uint64_t&gt;</span>, this is not a typical use case. Supporting such interactions would add complexity and bloat the compiled code with many more template instantiations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a13bccb650d933d19ec4c91bbfe7f0ef8" title="Checks that any pair of bit-stores are equal in content.">gf2::operator==</a></span>  </td><td class="markdownTableBodyNone">Checks that two stores are using the same underlying word type and have identical content.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="bit-shifts"></a>
Bit Shifts</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&lt;&lt;=</span>  </td><td class="markdownTableBodyNone">Left shifts in-place.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&gt;&gt;=</span>  </td><td class="markdownTableBodyNone">Right shifts in-place.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&lt;&lt; const</span>  </td><td class="markdownTableBodyNone">Copies the store to a new bit-vector and left shifts that vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&gt;&gt; const</span>  </td><td class="markdownTableBodyNone">Copies the store to a new bit-vector and right shifts that vector.  </td></tr>
</table>
<p>These operators act in vector space, so if the vector is \(v_0, v_1, \ldots, v_n\), then a right shift produces the vector \(0, v_0, v_1, \ldots, v_n-1\) where we have shifted out the last element and shifted in a zero at the start. Similarly, a left shift produces the vector \(v_1, v_2, \ldots, v_n, 0\) where we have shifted out the first element and shifted in a zero at the end.</p>
<p>Contrast this to shifts in bit space, where if a bit container is \(b_n, b_{n-1}, \ldots, b_0\), then a right shift produces \(0, b_n, b_{n-1}, \ldots, b_1\) and a left shift produces \(b_{n-1}, b_{n-2}, \ldots, b_0, 0\).</p>
<p>Essentially, right shifts in vector space correspond to left shifts in bit space, and vice versa.</p>
<dl class="section note"><dt>Note</dt><dd>Like every method in the library, the shift operators are implemented efficiently to operate on words at a time.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="bit-wise-operators"></a>
Bit-wise Operators</h1>
<p>We have methods that combine two bit-stores using the logical operations <span class="tt">XOR</span>, <span class="tt">AND</span>, and <span class="tt">OR</span>.</p>
<dl class="section important"><dt>Important</dt><dd>These methods require that the two bit-stores use the same underlying word type. They also require that the left-hand-side and right-hand-side bit-store operands are the same size. That precondition is always checked unless the <span class="tt">NDEBUG</span> flag is set at compile time. Interactions between bit-stores with different word types are only possible at the cost of increased code complexity, and are not a common use case.</dd></dl>
<p>The methods can act in place, mutating the left-hand side operator: <span class="tt">lhs &amp;= rhs</span>. There is also a non-mutating version <span class="tt">result = lhs &amp; rhs</span>, which returns a new <span class="tt">result</span> <em>bit-vector</em> in each case.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a39ac1c9c4e8d925816d2bc5ff12e0711" title="In-place XOR of one bit-store with an equal-sized bit-store.">gf2::operator^=</a></span>  </td><td class="markdownTableBodyNone">In-place <span class="tt">XOR</span> operation of equal-sized bit-stores: <span class="tt">lhs = lhs ^ rhs</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&amp;=</span>  </td><td class="markdownTableBodyNone">In-place <span class="tt">AND</span> operation of equal-sized bit-stores: <span class="tt">lhs = lhs &amp; rhs</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator\|=</span>  </td><td class="markdownTableBodyNone">In-place <span class="tt">OR</span> operation of equal-sized bit-stores: <span class="tt">lhs = lhs \| rhs</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a63cdbdaf058edb19748525579aaa0118" title="Returns a new bit-vector that has the same bits as a bit-store but with all the bits flipped.">gf2::operator~</a></span>  </td><td class="markdownTableBodyNone">Returns a new <em>bit-vector</em> that has the bits all flipped.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a1687ef8e4f015f7387912bd013500584" title="Returns the XOR of two equal-sized bit-stores as a new bit-vector.">gf2::operator^</a></span>  </td><td class="markdownTableBodyNone">Returns the <span class="tt">XOR</span> of this store with another equal-sized store as a new bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator&amp;</span>  </td><td class="markdownTableBodyNone">Returns the <span class="tt">AND</span> of this store with another equal-sized store as a new bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gf2::operator\|</span>  </td><td class="markdownTableBodyNone">Returns the <span class="tt">OR</span> of this store with another equal-sized store as a new bit-vector.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="arithmetic-operators"></a>
Arithmetic Operators</h1>
<p>In GF(2), the arithmetic operators <span class="tt">+</span> and <span class="tt">-</span> are both the <span class="tt">XOR</span> operator.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a7ea68d994ef5b413822fe67c735d452a" title="In-place addition of one bit-store with an equal-sized bit-store.">gf2::operator+=</a></span>  </td><td class="markdownTableBodyNone">Adds the passed (equal-sized) <span class="tt">rhs</span> bit-store to this one.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a97b4bd320f0d11a6cb5ae25135034d47" title="In-place difference of one bit-store with an equal-sized bit-store.">gf2::operator-=</a></span>  </td><td class="markdownTableBodyNone">Subtracts the passed (equal-sized) <span class="tt">rhs</span> bit-store from this one.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#ad15366027d99c7dbb1f02ffe1c8dd03d" title="Adds two equal-sized bit-stores and returns the result as a new bit-vector.">gf2::operator+</a></span>  </td><td class="markdownTableBodyNone">Adds two equal-sized bit-stores and returns the result as a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a92d7eb66f490d301485d15466635edda" title="Subtracts two equal-sized bit-stores and returns the result as a new bit-vector.">gf2::operator-</a></span>  </td><td class="markdownTableBodyNone">Subtracts two equal-sized bit-stores and returns the result as a bit-vector.  </td></tr>
</table>
<p>The constraints mentioned in the last bit-twiddling section also apply here.</p>
<h1 class="doxsection"><a class="anchor" id="other-functions"></a>
Other Functions</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf" title="Bit-matrix, bit-store multiplication, M * v, returning a new bit-vector.">gf2::dot</a></span>  </td><td class="markdownTableBodyNone">Returns the dot product of two equal-sized bit-stores as a boolean.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a287f8e09de01d9f8db3ad6363ee55088" title="Operator form for bit-matrix, bit-store multiplication, M * v, returning a new bit-vector.">gf2::operator*</a></span>  </td><td class="markdownTableBodyNone">Returns the dot product of two equal-sized bit-stores as a boolean.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a3b0ea5c405d2ed08ce9fa5bbbb2cc169" title="Convolutions:">gf2::convolve</a></span>  </td><td class="markdownTableBodyNone">Returns the convolution of two bit-stores as a new bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="namespacegf2.html#a10232b64eb69a81bc462f7b7cc18e0fc" title="Returns a new bit-vector formed by joining two bit-stores lhs and rhs.">gf2::join</a></span>  </td><td class="markdownTableBodyNone">Concatenates two bit-stores into a new bit-vector.  </td></tr>
</table>
<p>We have overloaded the <span class="tt">*</span> operator for pairs of bit-stores to compute the dot product of those stores.</p>
<h1 class="doxsection"><a class="anchor" id="see-also"></a>
See Also</h1>
<ul>
<li>The <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> reference for detailed documentation with examples for each function.</li>
<li><a class="el" href="md_docs_2pages_2BitArray.html"><span class="tt">BitArray</span></a> for fixed-size vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitVector.html"><span class="tt">BitVector</span></a> for dynamically-sized vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitSpan.html"><span class="tt">BitSpan</span></a> for non-owning views into any bit-store.</li>
<li><a class="el" href="md_docs_2pages_2BitRef.html"><span class="tt">BitRef</span></a> for read-write references to individual bits in a bit-store.</li>
<li><a class="el" href="md_docs_2pages_2Iterators.html"><span class="tt">Bits</span></a> for iterators over the bits in a bit-store.</li>
<li><a class="el" href="md_docs_2pages_2Iterators.html"><span class="tt">SetBits</span></a> for iterators over the indices of set bits in a bit-store.</li>
<li><a class="el" href="md_docs_2pages_2Iterators.html"><span class="tt">UnsetBits</span></a> for iterators over the indices of unset bits in a bit-store.</li>
<li><a class="el" href="md_docs_2pages_2Iterators.html"><span class="tt">Words</span></a> for iterators over the underlying "words" in a bit-store. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
