<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: The &lt;tt&gt;BitVector&lt;/tt&gt; Class</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2pages_2BitVector.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The <span class="tt">BitVector</span> Class </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="the-bitvector-class"></a></p>
<h1 class="doxsection"><a class="anchor" id="introduction-2"></a>
Introduction</h1>
<p>A <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> is a dynamically sized vector of bit elements stored compactly in an array of unsigned integer words.</p>
<p>The class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, which provides a rich API for manipulating the bits in the vector. The free functions defined for that concept are also pulled into the class as member functions. For example, if <span class="tt">v</span> is a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span>, you can call <span class="tt">v.count_ones()</span> to count the number of set bits in the vector instead of calling the free function <span class="tt">gf2::count_ones(v)</span>, though both forms are valid.</p>
<p>In addition to the many methods that mirror a corresponding utility function defined in <span class="tt"><a class="el" href="BitStore_8h.html" title="A concept for types that can access individual bits packed into contiguous primitive unsigned words,...">BitStore.h</a></span>, the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> class provides methods to construct bit-vectors in various ways, methods to resize a vector, and methods to append or remove elements from the end of a vector.</p>
<p>In mathematical terms, a bit-vector is a vector over <a href="https://en.wikipedia.org/wiki/GF(2)">GF2</a>, the simplest <a href="https://en.wikipedia.org/wiki/Galois_field">Galois-Field</a> with just two elements, usually denoted 0 &amp; 1, as the booleans true &amp; false, or as the bits set &amp; unset. Arithmetic over GF(2) is mod 2, so addition/subtraction becomes the <span class="tt">XOR</span> operation while multiplication/division becomes <span class="tt">AND</span>.</p>
<dl class="section note"><dt>Note</dt><dd>Operations on and between bit-vectors and other objects in the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> library are implemented using bitwise operations on whole underlying words at a time. These operations are highly optimised in modern CPUs, allowing for fast computation even on large bit-vectors. It also means we never have to worry about overflows or carries as we would with normal integer arithmetic.</dd></dl>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> class is a hybrid between a <a href="https://en.cppreference.com/w/cpp/container/vector"><span class="tt">std::vector</span></a> and a <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a>, along with extra mathematical features to facilitate numerical work, and in particular, linear algebra.</p>
<p>One can dynamically resize a <span class="tt">BitVector</span> as needed. Contrast this to a <span class="tt">std::bitset</span>, which has a <em>fixed</em> size determined at compile time. <em>Boost</em> provides the <a href="https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html"><span class="tt">boost::dynamic_bitset</span></a> class, which allows runtime resizing, as its name suggests. However, neither class supports algebraic operations.</p>
<p>It is worth noting that a <span class="tt">BitVector</span> is printed in <em>vector order</em>. For example, a bit-vector of size four will print as \(v_0 v_1 v_2 v_3\) with the elements in increasing index order, so the least significant vector element, \(v_0\), comes <b>first</b> on the <em>left</em>. Contrast that to a <span class="tt">std::bitset</span>, which always prints in <em>bit-order</em>. The equivalent <span class="tt">std::bitset</span> with four elements prints as \(b_3 b_2 b_1 b_0\) with the least significant bit \(b_0\) printed <b>last</b> on the <em>right</em>.</p>
<p>Of course, for many applications, printing in <em>bit-order</em> makes perfect sense. A bit-vector of four elements initialised to <span class="tt">0x1</span> will print <span class="tt">1000</span>. A <span class="tt">std::bitset</span> prints the same value as <span class="tt">0001</span>, which will be more natural in some settings.</p>
<p>However, our main aim is numerical work, where vector order is more natural. In particular, bit-order is unnatural for <em>matrices</em> over GF(2). It is too confusing to print a matrix in any order other than the one where the (0,0) element is at the top left, and proceed from there.</p>
<h1 class="doxsection"><a class="anchor" id="declaration-1"></a>
Declaration</h1>
<p>The declaration of the bit-vector class looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;Un<span class="keywordtype">signed</span> Word = usize&gt;</div>
<div class="line"><span class="keyword">class </span>BitVector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>word_type = Word;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The <span class="tt">Word</span> template parameter specifies the underlying <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">gf2::Unsigned</a></span> integer type used to hold the vector's bits, and the default is usually the most efficient type for the target platform. On most modern platforms, that <a href="https://en.cppreference.com/w/cpp/types/size_t"><span class="tt">usize</span></a> will be a 64-bit unsigned integer. The choice of underlying word type is exposed via the public <span class="tt">word_type</span> type alias as required by the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept.</p>
<p>If your application calls for a vast number of bit-vectors with only a few bits each, you might consider using <span class="tt">std::uint8_t</span> as the <span class="tt">Word</span> type to save memory.</p>
<dl class="section note"><dt>Note</dt><dd>If you peruse the header files, you may notice that many of the <a href="https://nessan.github.io/doxytest/">doctests</a> in the library use 8-bit underlying words. The reason is we want to exercise the various functions across word boundaries for modest, easily readable bit-stores.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="methods-overview-1"></a>
Methods Overview</h1>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> class provides a rich set of methods for constructing, querying, and manipulating, bit-vectors. Here is an overview of the main methods available in the class:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-concept">Concept Methods</a>  </td><td class="markdownTableBodyNone">Methods needed to satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-constructors">Constructors</a>  </td><td class="markdownTableBodyNone">Methods to create bit-vectors of various sizes and initial values.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-factory">Factory Constructors</a>  </td><td class="markdownTableBodyNone">Class methods to create bit-vectors with specific properties or fills.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-strings">Construction from Strings</a>  </td><td class="markdownTableBodyNone">Class methods to create bit-vectors from string representations.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-resizing">Resizing</a>  </td><td class="markdownTableBodyNone">Methods to query and manipulate the size and capacity of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-append">Appending Elements</a>  </td><td class="markdownTableBodyNone">Methods to append bits from various sources to the end of a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-remove">Removing Elements</a>  </td><td class="markdownTableBodyNone">Methods to remove bits from the end of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-bit-access">Bit Access</a>  </td><td class="markdownTableBodyNone">Methods to access individual bit elements in a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-queries">Queries</a>  </td><td class="markdownTableBodyNone">Methods to query the overall state of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-mutators">Mutators</a>  </td><td class="markdownTableBodyNone">Methods to mutate the overall state of a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-fills">Fills</a>  </td><td class="markdownTableBodyNone">Methods to fill a bit-vector from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-exports">Exports</a>  </td><td class="markdownTableBodyNone">Methods to export the bits from a bit-vector to various destinations.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-span">Spans</a>  </td><td class="markdownTableBodyNone">Methods to create non-owning views over a part of a bit-vector &mdash; <em>bit-spans</em>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-sub-vectors">Sub-vectors</a>  </td><td class="markdownTableBodyNone">Methods to pull out a clone of piece of a bit-vector as new bit-vectors  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-riffling">Riffling</a>  </td><td class="markdownTableBodyNone">Methods to create vectors that copy a bit-vector with interleaved zeros.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-indices">Set/Unset Indices</a>  </td><td class="markdownTableBodyNone">Methods to find the indices of set &amp; unset bits in a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-iterators">Iterators</a>  </td><td class="markdownTableBodyNone">Methods to create various iterators over a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-stringification">Stringification</a>  </td><td class="markdownTableBodyNone">Methods to create string representations of a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-vectors for content equality.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-vectors left or right.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-vectors.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-concept"></a>
Concept Methods</h1>
<p>Bit-vectors satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept and forwards many method calls to free functions defined for that concept. The concept requires us to provide the following methods:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">gf2::BitVector::size</a></span>  </td><td class="markdownTableBodyNone">Returns the number of bit elements in the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a05813fe7456c3b44322f29f3a34cf7af" title="Returns a const pointer to the underlying store of words .">gf2::BitVector::store</a> const</span>  </td><td class="markdownTableBodyNone">Returns a const pointer to the first <span class="tt">Word</span> holding bits in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a05813fe7456c3b44322f29f3a34cf7af" title="Returns a const pointer to the underlying store of words .">gf2::BitVector::store</a></span>  </td><td class="markdownTableBodyNone">Returns a non-const pointer to the first <span class="tt">Word</span> holding bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a70b5a50e5a357fda36b9faa81eb0d270" title="Returns the offset (in bits) of the first bit in the bit-vector within the first word.">gf2::BitVector::offset</a></span>  </td><td class="markdownTableBodyNone">For bit-vectors, this always returns 0.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a916cdd15c618a1a2eb2d58d47be5eaba" title="Returns the number of words in the bit-vector&#39;s underlying word store.">gf2::BitVector::words</a></span>  </td><td class="markdownTableBodyNone">Returns the number of <span class="tt">Word</span>s needed to vector those elements.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a94f28415157fbc4b4486555fe71b98bd" title="Returns word i from the bit-vector&#39;s underlying word store.">gf2::BitVector::word</a></span>  </td><td class="markdownTableBodyNone">Returns the word for the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ab3edaa3f54306e82e8190372e6e4d8f6" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVector::set_word</a></span>  </td><td class="markdownTableBodyNone">Sets the word at the passed index to the passed value.  </td></tr>
</table>
<p>These methods are trivial to implement for bit-vectors.</p>
<p>The one place where care is needed is in the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ab3edaa3f54306e82e8190372e6e4d8f6" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVector::set_word</a></span> method, which must ensure that any bits beyond the size of the bit-vector remain set to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>While the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a05813fe7456c3b44322f29f3a34cf7af" title="Returns a const pointer to the underlying store of words .">gf2::BitVector::store</a></span> method provides write access to the underlying words, you must be careful when modifying them directly. You must ensure that any bits beyond the bit-vector's size remain zero. The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ab3edaa3f54306e82e8190372e6e4d8f6" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVector::set_word</a></span> method takes care of this for you, so prefer using that method when possible.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-constructors"></a>
Constructors</h1>
<p>The default constructor for a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> creates an <em>empty</em> bit-vector with zero size. You can also create a bit-vector of a given size using the following constructors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector(usize)</a></span>  </td><td class="markdownTableBodyNone">Constructs a bit-vector of the given length where all the elements are zero.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector(usize, Word)</a></span>  </td><td class="markdownTableBodyNone">Constructs a bit-vector by repeatedly copying the bits from the <span class="tt">Word</span>  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-factory"></a>
Factory Constructors</h1>
<p>There are also many static factory construction functions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a214dd0c738e0a17e8d6afda0c55b5962" title="Factory method to construct an empty bit-vector with at least the specified capacity.">gf2::BitVector::with_capacity</a></span>  </td><td class="markdownTableBodyNone">Returns a zero-sized bit-vector that can add some elements without any extra allocations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1" title="Factory method to generate a bit-vector of length n where the elements are all 0.">gf2::BitVector::zeros</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are 0.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d" title="Factory method to generate a bit-vector of length n where the elements are all 1.">gf2::BitVector::ones</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are 1.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a6772a3f88ec78ec6d26ee559d2e20e7f" title="Factory method to generate a bit-vector of length n where the elements are set to value.">gf2::BitVector::constant</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are whatever is passed as a <span class="tt">value</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a3be06c38681e26a2e4695c90f2edf9c7" title="Factory method to generate a &quot;unit&quot; bit-vector of length n where only element i is set.">gf2::BitVector::unit</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are zero except for a single 1.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a" title="Factory method to generate a bit-vector of length n looking like 101010....">gf2::BitVector::alternating</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements follow the pattern <span class="tt">101010...</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a3f33e12942bab8d475697297db924cb0" title="Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....">gf2::BitVector::from</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVector</span> filled with bits from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a4b7006134bcff1ddfc81bcc8133dd3cc" title="Factory method to generate a bit-vector of size size where the elements are picked at random.">gf2::BitVector::random</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVector</span> with a random fill seeded from entropy.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#adaced7a7dcdc71fa7ac67f2fefb5553c" title="Factory method to generate a bit-vector of size size where the elements are from independent fair coi...">gf2::BitVector::seeded_random</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVector</span> with a reproducible random fill.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a1b2b8c3a489d9c5c88d51b90008bacf3" title="Factory method to generate a bit-vector of size size where the elements are from independent fair coi...">gf2::BitVector::biased_random</a></span>  </td><td class="markdownTableBodyNone">Returns a random <span class="tt">BitVector</span> where you set the probability of bits being 1.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a3f33e12942bab8d475697297db924cb0" title="Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....">gf2::BitVector::from</a></span> factory method is overloaded to allow construction from:</p>
<ul>
<li><em>Any</em> other <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> object. The source object need not share the same underlying storage type. <br  />
 This allows conversions from bit-stores based on a different word type.</li>
<li><em>Any</em> unsigned integer type, where we copy the bits corresponding to the value.<br  />
 The source type need not be the same as the underlying <span class="tt">Word</span> type used by the bit-vector. The size of the resulting vector is determined by the number of bits in the source type.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> where we copy the bits over.</li>
<li>A callable object (a function of some sort) that generates bits on demand when passed an index.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="vec-strings"></a>
Construction from Strings</h1>
<p>We can construct a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> from strings &mdash; these methods can fail, so they return a <span class="tt">std::optional&lt;<a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a>&gt;</span> and <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><span class="tt">std::nullopt</span></a> if the string cannot be parsed.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea" title="Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.">gf2::BitVector::from_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from an arbitrary string.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a193a2ffb36fa664bbdbfe057f4f491d2" title="Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.">gf2::BitVector::from_binary_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from a <em>binary</em> string.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a94bc956ed38b656c83518854999bc5f1" title="Factory method to construct a bit-vector from a hex string, returning std::nullopt on failure.">gf2::BitVector::from_hex_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from a <em>hexadecimal</em> string.  </td></tr>
</table>
<p>Space, comma, single quote, and underscore characters are removed from the string.</p>
<p>If the string has an optional <span class="tt">"0b"</span> prefix, it is assumed to be binary. If it has an optional <span class="tt">"0x"</span> prefix, it is assumed to be hex. If there is no prefix and the string consists entirely of 0s and 1s, we assume it is binary; otherwise, we think it is hex.</p>
<dl class="section warning"><dt>Warning</dt><dd>This means the string <span class="tt">"0x11</span> is interpreted as the bit-vector of size 8 <span class="tt">"11110001"</span>, whereas the same string without a prefix, <span class="tt">"11"</span> is interpreted as the bit-vector of size 2 <span class="tt">"11"</span>. To avoid any ambiguity, it is best to use a prefix.</dd></dl>
<p>See the <a class="el" href="md_docs_2pages_2BitStore.html#string-encodings">string-encodings</a> section in the <span class="tt">BitStore</span> documentation for more details on the accepted string formats.</p>
<h1 class="doxsection"><a class="anchor" id="vec-resizing"></a>
Resizing</h1>
<p>We have methods to query and manipulate the size and capacity of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a8b10006eb120ea7fafdeecf68adb53cb" title="Returns the number of bit-elements in the bit-vector.">gf2::BitVector::size</a></span>  </td><td class="markdownTableBodyNone">Returns the number of bit elements in the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a4b9cffc16ebebe17e183311de0119d55" title="Returns the current capacity of the bit-vector.">gf2::BitVector::capacity</a></span>  </td><td class="markdownTableBodyNone">Returns the total number of bits the vector can hold without allocating more memory.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a3c460bba89b8c439f20f0b4d5330932a" title="Returns the number of additional elements we can store in the bit-vector without reallocating.">gf2::BitVector::remaining_capacity</a></span>  </td><td class="markdownTableBodyNone">Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a5bf1540020eb0b155578832dcd535513" title="Shrinks the bit-vector&#39;s capacity as much as possible.">gf2::BitVector::shrink_to_fit</a></span>  </td><td class="markdownTableBodyNone">Tries to shrink the vector's capacity as much as possible.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad77aa9ce9b0abde4d43bd7062ce2e9b4" title="Removes all elements from the bit-vector so size()==0.">gf2::BitVector::clear</a></span>  </td><td class="markdownTableBodyNone">Sets the <span class="tt">size()</span> to zero. Leaves the capacity unaltered.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a9e43be056727a9fe0b684a54e5a796d3" title="Resize the bit-vector so that its size() is n.">gf2::BitVector::resize</a></span>  </td><td class="markdownTableBodyNone">Resizes the bit-vector, either adding zeros, or truncating existing elements.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7f30b7ca6335493a4ac73d5a54fa4038" title="Sets any unused bits in the last occupied word to 0.">gf2::BitVector::clean</a></span>  </td><td class="markdownTableBodyNone">Sets any unused bits in the <em>last</em> occupied word to 0.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7f30b7ca6335493a4ac73d5a54fa4038" title="Sets any unused bits in the last occupied word to 0.">gf2::BitVector::clean</a></span> method is primarily used internally in the library.</p>
<h1 class="doxsection"><a class="anchor" id="vec-append"></a>
Appending Elements</h1>
<p>We have methods to append elements from various sources to the end of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ab1ec353b0b28d8f85f402b368883405e" title="Pushes a single bit b onto the bit-vector.">gf2::BitVector::push</a></span>  </td><td class="markdownTableBodyNone">Pushes a single bit (0 or 1) onto the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aa9116014ea3e714e7c5017a90a5d7ace" title="Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...">gf2::BitVector::append</a></span>  </td><td class="markdownTableBodyNone">Appends bits from various sources to the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7b73a1d27f306f5b7fc3909f46ab6809" title="Appends a single character c onto the end of bit-vector and returns this for chaining.">gf2::BitVector::append_digit</a></span>  </td><td class="markdownTableBodyNone">Appends a "character's" worth of bits to the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a95ad154ae65e3999bb24c7ad0e03db50" title="Appends a single hex digit character c onto the end of bit-vector and returns this for chaining.">gf2::BitVector::append_hex_digit</a></span>  </td><td class="markdownTableBodyNone">Appends four bits from a "hex-character" to the end of the bit-vector.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aa9116014ea3e714e7c5017a90a5d7ace" title="Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...">gf2::BitVector::append</a></span> method is overloaded to allow appending bits from:</p>
<ul>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> where we append the bits to the end of the bit-vector.</li>
<li><em>Any</em> unsigned integer type, where we append the bits corresponding to the value.<br  />
 The type need not be the same as the underlying <span class="tt">Word</span> type used by the bit-vector.</li>
<li><em>Any</em> other <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> object, which need not share the same underlying <span class="tt">Word</span> storage type.</li>
</ul>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7b73a1d27f306f5b7fc3909f46ab6809" title="Appends a single character c onto the end of bit-vector and returns this for chaining.">gf2::BitVector::append_digit</a></span> method appends bits from a character representing a digit in one of the bases 2, 4, 8, or 16. It does nothing if it fails to parse the character.</p>
<h1 class="doxsection"><a class="anchor" id="vec-remove"></a>
Removing Elements</h1>
<p>We have methods to remove elements from the end of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7cab0bece6d69e0d89ae7a4b866ed12b" title="Removes the last bit from the bit-vector and returns it or std::nullopt if the bit-vector is empty.">gf2::BitVector::pop</a></span>  </td><td class="markdownTableBodyNone">Removes the last bit from the bit-vector and returns it.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a9908f2bf308fd4371d920aeea320a489" title="Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or s...">gf2::BitVector::split_off_unsigned</a></span>  </td><td class="markdownTableBodyNone">Removes a single arbitrary-sized unsigned integer off the end of the bit-vector and returns it.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a1dbeafd75d30e211d688822448a5da03" title="Splits a bit-vector into two at the given index, returning a new BitVector.">gf2::BitVector::split_off</a></span>  </td><td class="markdownTableBodyNone">Splits a bit-vector into two at a given index  </td></tr>
</table>
<p>The first two methods return the removed elements as a <a href="https://en.cppreference.com/w/cpp/utility/optional"><span class="tt">std::optional</span></a>, and as a <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><span class="tt">std::nullopt</span></a> if the vector is empty.</p>
<p>The two <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a1dbeafd75d30e211d688822448a5da03" title="Splits a bit-vector into two at the given index, returning a new BitVector.">gf2::BitVector::split_off</a></span> methods complement the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a6e2078e3f40d295f483d87a09d26a92f" title="Views the bit-vector as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVector::split_at</a></span> methods. These versions change the size of the bit-vector <em>in place</em>.</p>
<h1 class="doxsection"><a class="anchor" id="vec-bit-access"></a>
Bit Access</h1>
<p>The following methods provide access to individual bit elements in the bit-vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a4174ea457afc81234d769dcf75f1b4ac" title="Returns true if the bit at the given index i is set, false otherwise.">gf2::BitVector::get</a></span>  </td><td class="markdownTableBodyNone">Returns the value of a single bit element as a read-only boolean.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a46aaf33f13e4b6d79467bdb33bc36db8" title="Returns the boolean value of the bit element i.">gf2::BitVector::operator[]()</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">bool</span> in the const case and a <span class="tt">BitRef</span> with read-write access to a bit element in the non-const version.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#abaed9cf3881b1064339ca246099cdce4" title="Returns true if the first bit element is set, false otherwise.">gf2::BitVector::front</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the first element in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ae5e06517a282d17f1e2b914e66322538" title="Returns true if the last bit element is set, false otherwise.">gf2::BitVector::back</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the last element in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a73c5c0d160af7ae95e495e1288f73440" title="Sets the bit-element i to the specified boolean value &amp; returns this for chaining....">gf2::BitVector::set</a></span>  </td><td class="markdownTableBodyNone">Sets a bit to the given boolean value which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad5425d23c332a0170eb24b8242373ad0" title="Flips the value of the bit-element i and returns this for chaining.">gf2::BitVector::flip</a></span>  </td><td class="markdownTableBodyNone">Flips the value of the bit element at a given index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#abc6a83f3db17bdad733a606ec0c04f7e" title="Swaps the bits in the bit-vector at indices i0 and i1 and returns this for chaining.">gf2::BitVector::swap</a></span>  </td><td class="markdownTableBodyNone">Swaps the values of bit elements at locations <span class="tt">i</span> and <span class="tt">j</span>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You can set the <span class="tt">DEBUG</span> flag at compile time to enable bounds checks on the index arguments.</dd></dl>
<p>The non-const version of <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a46aaf33f13e4b6d79467bdb33bc36db8" title="Returns the boolean value of the bit element i.">gf2::BitVector::operator[]()</a></span> returns a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">gf2::BitRef</a></span>, which is "reference" to an individual bit in the vector. It is automatically converted to a boolean on reads, but it also allows writes, which means you can write natural-looking single-bit assignments:</p>
<div class="fragment"><div class="line">v[12] = <span class="keyword">true</span>;</div>
</div><!-- fragment --><p>This is equivalent to calling <span class="tt">v.set(12, true);</span>.</p>
<h1 class="doxsection"><a class="anchor" id="vec-queries"></a>
Queries</h1>
<p>The following methods let you query the overall state of a bit-vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a26c48c7ba8dc5dacdfe886a081641e0e" title="Returns true if the bit-vector is empty, false otherwise.">gf2::BitVector::is_empty</a></span>  </td><td class="markdownTableBodyNone">Returns true if the vector is empty  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ac47715a1879d7e80066ca121f21d381c" title="Returns true if at least one bit in the bit-vector is set, false otherwise.">gf2::BitVector::any</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>any</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ae2e0b8b3f0dd29888976c9b8c8b92656" title="Returns true if all bits in the bit-vector are set, false otherwise.">gf2::BitVector::all</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>every</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad35a4ea3c7e58752695053c532f70104" title="Returns true if no bits in the bit-vector are set, false otherwise.">gf2::BitVector::none</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>no</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ac2d2d233519d4c7531ceb2be692eae3d" title="Returns the number of set bits in the bit-vector.">gf2::BitVector::count_ones</a></span>  </td><td class="markdownTableBodyNone">Returns the number of set bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#acdc8cf20785c6091f60dfb2498a69316" title="Returns the number of unset bits in the bit-vector.">gf2::BitVector::count_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of unset bits in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a3c810f15c19034ff0fb20cc8bd038616" title="Returns the number of leading zeros in the bit-vector.">gf2::BitVector::leading_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of leading unset bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a1d68c1882ed92a0d9731f3c4990a9e56" title="Returns the number of trailing zeros in the bit-vector.">gf2::BitVector::trailing_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of trailing unset bits in the vector.  </td></tr>
</table>
<p>These methods efficiently operate on words at a time, so they are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="vec-mutators"></a>
Mutators</h1>
<p>The following methods let you mutate the entire vector in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a930b70847fba4092fa8be14a40dce295" title="Sets the bits in the bit-vector to the boolean value and returns a reference to this for chaining.">gf2::BitVector::set_all</a></span>  </td><td class="markdownTableBodyNone">Sets all the bits in the vector to the passed value, which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aff3b6b072f9c5c15a05fc994a178edaa" title="Flips the value of the bits in the bit-vector and returns a reference to this for chaining.">gf2::BitVector::flip_all</a></span>  </td><td class="markdownTableBodyNone">Flips the values of all the bits in the vector.  </td></tr>
</table>
<p>The methods operate on words at a time, so are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="vec-fills"></a>
Copies &amp; Fills</h1>
<p>The following methods let you populate the entire vector in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a85e93ce5352f5a87bc23e767cbe90fd7" title="Copies all the bits from any unsigned integral src value to this equal-sized bit-vector....">gf2::BitVector::copy</a></span>  </td><td class="markdownTableBodyNone">Makes the bits in this vector identical to those from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aa04714ab255021c1a38adbe375099f26" title="Fill the bit-vector with random bits and returns a reference to this for chaining.">gf2::BitVector::fill_random</a></span>  </td><td class="markdownTableBodyNone">Fills the vector with random 0's and 1's.  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="copies-2"></a>
Copies</h2>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a85e93ce5352f5a87bc23e767cbe90fd7" title="Copies all the bits from any unsigned integral src value to this equal-sized bit-vector....">gf2::BitVector::copy</a></span> method is overloaded to copy bit values from various sources, where the size of bit-vector <b>must</b> match the number of bits in the source:</p>
<ul>
<li>Another bit-store of the same size but possibly a different underlying word type.</li>
<li>A single unsigned integer value, which need not be the same type as the underlying <span class="tt">Word</span> used here.</li>
<li>An iteration of unsigned integer values, which need not be the same type as the underlying <span class="tt">Word</span> used here.</li>
<li>A function or callable object that takes a single <span class="tt">usize</span> index argument and returns a boolean value for that index.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> of the same size as the bit-vector.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In each case, the <em>number of bits</em> in the source and destination must match exactly and that condition is always checked unless the <span class="tt">NDEBUG</span> flag is set at compile time. You can always use a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> to copy a subset of bits if needed.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="random-fills-2"></a>
Random Fills</h2>
<p>By default, the random fill method uses a random number generator seeded with system entropy, so the results change from run to run. You can set a specific seed to get reproducible fills.</p>
<p>The default probability that a bit is set is 50%, but you can pass a different probability in the range <span class="tt">[0.0, 1.0]</span> if desired.</p>
<h1 class="doxsection"><a class="anchor" id="vec-exports"></a>
Exports</h1>
<p>The following overloaded method lets you export the bits in the bit-vector to various destinations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad634ddd3e30bbf06fbf58127ee3f21a5" title="Returns a copy of the words underlying this bit-vector and puts them into the passed output iterator.">gf2::BitVector::to_words</a></span>  </td><td class="markdownTableBodyNone">Exports the bits in the bit-vector as unsigned words.  </td></tr>
</table>
<p>The `<span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad634ddd3e30bbf06fbf58127ee3f21a5" title="Returns a copy of the words underlying this bit-vector and puts them into the passed output iterator.">gf2::BitVector::to_words</a></span> function can be passed an output iterator to fill where we assume:</p>
<ul>
<li>The output iterator points to a location that can accept values of the underlying word type.</li>
<li>There is enough space at the output location to hold all those words.</li>
</ul>
<p>If <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad634ddd3e30bbf06fbf58127ee3f21a5" title="Returns a copy of the words underlying this bit-vector and puts them into the passed output iterator.">gf2::BitVector::to_words</a></span> is called with no argument it returns a new <span class="tt">std::vector</span> of the underlying word type.</p>
<p><b>Note:</b> The final word in the output may have unused high-order bits that are guaranteed to be set to zero.</p>
<h1 class="doxsection"><a class="anchor" id="vec-span"></a>
Spans</h1>
<p>The following methods let you create a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>, which is a non-owning view of some contiguous subset of bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea" title="Returns an immutable bit-span encompassing the bit-vector&#39;s bits in the half-open range [begin,...">gf2::BitVector::span</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a0afbe86b05c12a2a7a7d69ac519035ea" title="Returns an immutable bit-span encompassing the bit-vector&#39;s bits in the half-open range [begin,...">gf2::BitVector::span</a></span> method &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> span(usize begin, usize end);        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> span(usize begin, usize end) <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that allows modification of the bits in the specified range.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that does not allow modification of the bits in the specified range.</li>
</ol>
<p>In both cases, the <span class="tt">begin</span> and <span class="tt">end</span> arguments define a half-open range of bits in the vector.</p>
<p>Mutability/immutability of the returned <span class="tt">BitSpan</span> is <em>deep</em>. The span's mutability reflects that of the underlying vector, so if the vector is mutable, so is the span, and vice versa.</p>
<p>This is similar to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span.html"><span class="tt">std::span</span></a> class for regular data collection types.</p>
<dl class="section note"><dt>Note</dt><dd>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> also satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, so you can take a span of a span.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-sub-vectors"></a>
Sub-vectors</h1>
<p>The following methods create or fill <em>independent</em> bit-vectors with copies of some contiguous subset of the bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a07fe4a8c5bf228f595f7612c23911970" title="Returns a clone of the elements in the half-open range [begin, end) as a new bit-vector.">gf2::BitVector::sub</a></span>  </td><td class="markdownTableBodyNone">Returns a new <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a6e2078e3f40d295f483d87a09d26a92f" title="Views the bit-vector as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVector::split_at</a></span>  </td><td class="markdownTableBodyNone">Fills two bit-vectors with the bits in the ranges <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span>.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a6e2078e3f40d295f483d87a09d26a92f" title="Views the bit-vector as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVector::split_at</a></span> method can optionally take two pre-existing bit-vectors to fill, thereby avoiding unnecessary allocations in some iterative algorithms that repeatedly use this method.</p>
<dl class="section note"><dt>Note</dt><dd>These methods do not alter the underlying vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-riffling"></a>
Riffling</h1>
<p>We have methods that can interleave (<em>riffle</em>) the bits in a vector with zeros.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad33314f6e953a6808a2303bc9a755a3b" title="Interleaves the bits of this bit-vector with zeros storing the result into the bit-vector dst.">gf2::BitVector::riffled</a></span>  </td><td class="markdownTableBodyNone">Fills a pre-existing bit-vector with the result of riffling this vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad33314f6e953a6808a2303bc9a755a3b" title="Interleaves the bits of this bit-vector with zeros storing the result into the bit-vector dst.">gf2::BitVector::riffled</a></span>  </td><td class="markdownTableBodyNone">Returns a new bit-vector that is this vector with its bits interleaved with zeros.  </td></tr>
</table>
<p>If the vector looks like \(v_0 v_1 v_2 \ldots v_n\), then the riffling operation produces the vector \(v_0 0 v_1 0 v_2 0 \ldots v_n\) where a zero is interleaved <em>between</em> every bit in the original vector (there is no trailing zero at the end).</p>
<p>If you think of a bit-vector as representing the coefficients of a polynomial over GF(2), then riffling corresponds to squaring that polynomial. See the documentation for <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html#a30309419a9ed46754fc450052ef19bfb" title="Fills dst with the square of this bit-polynomial.">gf2::BitPolynomial::squared</a></span> for more information.</p>
<h1 class="doxsection"><a class="anchor" id="vec-indices"></a>
Set/Unset Bit Indices</h1>
<p>The following methods find the indices of set or unset bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7880bbbf06f4ee31d9baf2d6bfa61d03" title="Returns the index of the first set bit in the bit-vector or {} if no bits are set.">gf2::BitVector::first_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first set bit in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a0623e155d7ddf9d08f64d3eee6e7aec3" title="Returns the index of the last set bit in the bit-vector or {} if no bits are set.">gf2::BitVector::last_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last set bit in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aa6f8f81db958c9e0b6749b0e1c05a974" title="Returns the index of the next set bit after index in the bit-vector or {} if no more set bits exist.">gf2::BitVector::next_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next set bit in the vector <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a8a1df02604e2457c56c4de2a9d00c5c3" title="Returns the index of the previous set bit before index in the bit-vector or {} if there are none.">gf2::BitVector::previous_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous set bit in the vector <em>before</em> the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad5801c5e4bad14d86cfa9276e0e1229c" title="Returns the index of the first unset bit in the bit-vector or {} if no bits are unset.">gf2::BitVector::first_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first unset bit in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad820bf33df2faff7cc700824b370d864" title="Returns the index of the last unset bit in the bit-vector or {} if no bits are unset.">gf2::BitVector::last_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last unset bit in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aa6ec1590bad64a8ff835918eed8afb50" title="Returns the index of the next unset bit after index in the bit-vector or {} if no more unset bits exi...">gf2::BitVector::next_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next unset bit in the vector <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a9000a2348948286e3d12eacaa5948ff6" title="Returns the index of the previous unset bit before index in the bit-vector or {} if no more unset bit...">gf2::BitVector::previous_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous unset bit in the vector <em>before</em> the passed index.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-iterators"></a>
Iterators</h1>
<p>The following methods create iterators for traversing the bits or underlying words in the vector:</p>
<ul>
<li>Read-only iteration through the individual bits.</li>
<li>Read-write iteration through the individual bits.</li>
<li>Read-only iteration through the indices of the set bits.</li>
<li>Read-only iteration through the indices of the unset bits.</li>
<li>Read-write iteration through the underlying vector words.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a899931f1989b4af7ee2ad2bdef3684b3" title="Returns a const iterator over the bool values of the bits in the const bit-vector.">gf2::BitVector::bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> iterator over the bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a4679323bfd87481db46124b8533d7bf4" title="Returns an iterator over the indices of any set bits in the bit-vector.">gf2::BitVector::set_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1SetBits.html" title="An iterator over the index locations of the set bits in a bit-store.   You get this iterator by calli...">gf2::SetBits</a></span> iterator to view the indices of all the set bits.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a15d5236d2ad3e82c208ee262e67ef893" title="Returns an iterator over the indices of any unset bits in the bit-vector.">gf2::BitVector::unset_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1UnsetBits.html" title="An iterator over the index locations of the unset bits in a bit-store.  You get this iterator by call...">gf2::UnsetBits</a></span> iterator to view the indices of all the unset bits.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aedb09244ec466632c6e1d0d2a5e877b0" title="Returns a const iterator over all the words underlying the bit-vector.">gf2::BitVector::store_words</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Words.html" title="An iterator over the &quot;words&quot; underlying a bit-store.  You get this iterator by calling the BitStore::...">gf2::Words</a></span> iterator to view the "words" underlying the vector.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a899931f1989b4af7ee2ad2bdef3684b3" title="Returns a const iterator over the bool values of the bits in the const bit-vector.">gf2::BitVector::bits</a></span> method &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bits();        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> bits() <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that allows modification of the bits in the vector.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that only allows one to view the bits in the vector.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="vec-stringification"></a>
Stringification</h1>
<p>The following methods return a string representation for a bit-vector. The string can be in the obvious binary format or a more compact hex format.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#ad2b8ef3dc6d1ea250253135172bb48e7" title="Returns a binary string representation of the bit-vector.">gf2::BitVector::to_string</a></span>  </td><td class="markdownTableBodyNone">Returns a default string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#aebf24ce533ec44f83c83105b55a3b5e3" title="Returns a &quot;pretty&quot; string representation of the bit-vector.">gf2::BitVector::to_pretty_string</a></span>  </td><td class="markdownTableBodyNone">Returns a "pretty" string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#a7cc78c5e7773c30d8da8916af258d081" title="Returns a binary string representation of the bit-vector.">gf2::BitVector::to_binary_string</a></span>  </td><td class="markdownTableBodyNone">Returns a binary string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVector.html#afec1640c73d1be249030207fcd061ab1" title="Returns the &quot;hex&quot; string representation of the bits in the bit-vector.">gf2::BitVector::to_hex_string</a></span>  </td><td class="markdownTableBodyNone">Returns a compact hex string representation for a bit-vector.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="other-operators-and-functions-1"></a>
Other Operators and Functions</h1>
<p>There are many operators and free functions defined for any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> compatible class, including:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-vectors for content equality.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-vectors left or right.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-vectors.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="see-also-2"></a>
See Also</h1>
<ul>
<li><span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> reference for detailed documentation with examples for each method.</li>
<li><a class="el" href="md_docs_2pages_2BitStore.html"><span class="tt">BitStore</span></a> for the concept API shared by all bit-stores.</li>
<li><a class="el" href="md_docs_2pages_2BitArray.html"><span class="tt">BitArray</span></a> for fixed-size vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitSpan.html"><span class="tt">BitSpan</span></a> for non-owning views of some of the bits in a bit-vector.</li>
<li><a class="el" href="md_docs_2pages_2BitMatrix.html"><span class="tt">BitMatrix</span></a> for matrices of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitPolynomial.html"><span class="tt">BitPolynomial</span></a> for polynomials over GF(2). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
