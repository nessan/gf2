<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: The &lt;tt&gt;BitSpan&lt;/tt&gt; Class</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2pages_2BitSpan.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The <span class="tt">BitSpan</span> Class </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="the-bitspan-class"></a></p>
<h1 class="doxsection"><a class="anchor" id="introduction-3"></a>
Introduction</h1>
<p>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> is a non-owning <em>view</em> of bit elements stored compactly in an array of unsigned integer words. Typically bit-spans are created as views into existing <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> or <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> objects, but they can also be created from an existing bit-span or even from raw pointers to word arrays.</p>
<p>The class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, which provides a rich API for manipulating the bits in the bit-span. The free functions defined for that concept are also pulled into the class as member functions. For example, if <span class="tt">s</span> is a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>, you can call <span class="tt">s.count_ones()</span> to count the number of set bits in the span instead of calling the free function <span class="tt">gf2::count_ones(s)</span>, though both forms are valid.</p>
<p>A span is a cheap way to work with a slice of a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>, <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span>, or any other <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span>. It never allocates or copies; it just remembers a pointer into the backing words, a bit-offset, and a length.</p>
<dl class="section note"><dt>Note</dt><dd>Operations on and between bit-spans and other objects in the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> library are implemented using bitwise operations on whole underlying words at a time. These operations are highly optimised in modern CPUs, allowing for fast computation even on large bitsets. It also means we never have to worry about overflows or carries as we would with normal integer arithmetic.</dd></dl>
<p>Use spans when you need fast, zero-copy views for algorithms (e.g., matrix row slices, polynomial segments, or temporary windows) without giving up the rich <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> operations.</p>
<p>Because they are non-owning you can pass spans by value without worrying about copies.</p>
<p>This is similar in spirit to <a href="https://en.cppreference.com/w/cpp/container/span.html"><span class="tt">std::span</span></a> for arrays of regular types, but specialised for bit-level access and manipulation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> keeps a pointer back to the underlying <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span>, that store must outlive the span. Outside of that lifetime guarantee, you can freely pass bit spans by value &ndash; they are tiny and intentionally lightweight.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="declaration-2"></a>
Declaration</h1>
<p>The declaration of the bit-span class looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;Un<span class="keywordtype">signed</span> Word&gt;</div>
<div class="line"><span class="keyword">class </span>BitSpan {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>word_type = Word;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>In the case of a a bit-span, the const-ness of the <span class="tt">Word</span> type determines whether the span is read-only or read-write. A span created using <span class="tt">gf2::BitStore::span(begin, end) const</span> will have <span class="tt">Word</span> as a <span class="tt">const</span> type, while one created using <span class="tt">gf2::BitStore::span(begin, end)</span> will have a non-const <span class="tt">Word</span> type. The former is a read-only view, while the latter allows mutation.</p>
<dl class="section note"><dt>Note</dt><dd>Spans are lightweight and you generally pass them by value so <span class="tt">fun(BitSpan&lt;Word&gt; span)</span> is preferred over <span class="tt">fun(BitSpan&lt;Word&gt; const&amp; span)</span>. This form also emphasises that what matters is the <em>interior</em> const-ness of the span, not whether the span object itself is const.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="methods-overview-2"></a>
Methods Overview</h1>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> class provides a rich set of methods for querying and manipulating, bit-spans. Here is an overview of the main methods available in the class:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-concept">Concept Methods</a>  </td><td class="markdownTableBodyNone">Methods needed to satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-constructors">Constructors</a>  </td><td class="markdownTableBodyNone">Methods to create bit-spans.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-bit-access">Bit Access</a>  </td><td class="markdownTableBodyNone">Methods to access individual bit elements in a bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-queries">Queries</a>  </td><td class="markdownTableBodyNone">Methods to query the overall state of a bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-mutators">Mutators</a>  </td><td class="markdownTableBodyNone">Methods to mutate the overall state of a bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-fills">Fills</a>  </td><td class="markdownTableBodyNone">Methods to fill a bit-span from various sources.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-span">Spans</a>  </td><td class="markdownTableBodyNone">Methods to create non-owning views over a part of a bit-span &mdash; <em>sib-bit-spans</em>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-sub-vectors">Sub-vectors</a>  </td><td class="markdownTableBodyNone">Methods to pull out a clone of piece of a bit-span as new bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-riffling">Riffling</a>  </td><td class="markdownTableBodyNone">Methods to create bit-vectors that copy a bit-span with interleaved zeros.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-indices">Set/Unset Indices</a>  </td><td class="markdownTableBodyNone">Methods to find the indices of set &amp; unset bits in a bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#span-iterators">Iterators</a>  </td><td class="markdownTableBodyNone">Methods to create various iterators over a bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#span-stringification">Stringification</a>  </td><td class="markdownTableBodyNone">Methods to create string representations of a bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-spans for content equality.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-spans left or right.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-spans.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="span-concept"></a>
Concept Methods</h1>
<p>Bit-spans satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept and forwards many method calls to free functions defined for that concept. The concept requires us to provide the following methods:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a394bdf415ce323567537b31779244da7" title="Returns the number of bits in the bit-span.">gf2::BitSpan::size</a></span>  </td><td class="markdownTableBodyNone">Returns the number of bit elements in the span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ace3504c9101c1696e92c9188dfb601b4" title="Returns the minimum number of words needed to hold the bits in the bit-span.">gf2::BitSpan::words</a></span>  </td><td class="markdownTableBodyNone">Returns the <em>minimum</em> number of <span class="tt">Word</span>s needed to store those elements.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a5fb42074c8d31f1197962bf968861cbe" title="Returns a &quot;word&quot;&#39;s worth of bits from the bit-span.">gf2::BitSpan::word</a></span>  </td><td class="markdownTableBodyNone">Returns the "word" for the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a9eea3be4a464e84bd015c5ff7c89a814" title="Sets a &quot;word&quot;&#39;s worth of bits in the bit-span.">gf2::BitSpan::set_word</a></span>  </td><td class="markdownTableBodyNone">Sets the "word" at the passed index to the passed value.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a82991653375eb8b86036b1aee9df0335" title="Returns a pointer to the first bit-span word in some underlying span of words (const version).">gf2::BitSpan::store</a> const</span>  </td><td class="markdownTableBodyNone">Returns a const pointer to the beginning of the underlying store.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a82991653375eb8b86036b1aee9df0335" title="Returns a pointer to the first bit-span word in some underlying span of words (const version).">gf2::BitSpan::store</a></span>  </td><td class="markdownTableBodyNone">Returns a non-const pointer to the beginning of the underlying store.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ac703c2a0163f4f5f99d5796706fe0215" title="Returns the offset (in bits) of the first bit in the bit-span within the first bit-span word.">gf2::BitSpan::offset</a></span>  </td><td class="markdownTableBodyNone">The bit-span begins at this bit-offset inside its first word.  </td></tr>
</table>
<p>These methods were trivial to implement for bit-arrays and vectors but require some thought for bit spans.</p>
<p>The key thing to understand is that all functions operating on a <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> operates <em>as if</em> the span is a contiguous array of bits starting at bit-index <b>0</b>.</p>
<p>Of course, the actual bits in the span may start part-way through a word in the underlying store, so we have to adjust for that in our implementation.</p>
<p>For a bit-span, the return value from the <span class="tt">gf2::BitSpan::word(i)</span> method will often be synthesised from two contiguous "real" words <span class="tt">w[j]</span> and <span class="tt">w[j+1]</span> for some <span class="tt">j</span>:</p>
<p><span class="tt">word[i]</span> will use some high-order bits from <span class="tt">w[j]</span> and low-order bits from <span class="tt">w[j+1]</span> as shown in the following example:</p>
<div class="image">
<object type="image/svg+xml" data="bit-span.svg" style="pointer-events: none;"></object>
<div class="caption">
A bit-span with 20 elements, where the `X` is always zero</div></div>
    <p>The <span class="tt">BitSpan</span> class behaves <em>as if</em> bits from the real underlying store were copied and shuffled down so that element zero is bit 0 of word 0 in the bit-span. However, it never actually copies anything; instead, it synthesises "words" as needed.</p>
<p>The same principle applies to the <span class="tt">gf2::BitSpan::set_word(i, value)</span> method. In the case of a bit-span, calls to <span class="tt">set_word(i, value)</span> will generally copy low-order bits from <span class="tt">value</span> into the high-order bits of some real underlying word <span class="tt">w[j]</span> and copy the rest of the high-order bits from <span class="tt">value</span> into the low-order bits of <span class="tt">w[j+1]</span>.</p>
<p>The other bits in <span class="tt">w[j]</span> and <span class="tt">w[j+1]</span> will not be touched.</p>
<dl class="section warning"><dt>Warning</dt><dd>While the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a82991653375eb8b86036b1aee9df0335" title="Returns a pointer to the first bit-span word in some underlying span of words (const version).">gf2::BitSpan::store</a></span> method provides write access to the underlying words, this is primarily for internal use. If you do use the pointer, you must ensure that any bits outside the span's range remain unaltered. The <span class="tt">set_word</span> method takes care of this for you, so prefer using that method when possible.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="span-constructors"></a>
Constructors</h1>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> class provides just one constructor to create bit-span objects:</p>
<div class="fragment"><div class="line">BitSpan(Word* data, <span class="keywordtype">size_t</span> offset, <span class="keywordtype">size_t</span> length);</div>
</div><!-- fragment --><p>This constructor creates a bit-span that views <span class="tt">length</span> bits starting at bit-offset <span class="tt">offset</span> inside the array of words pointed to by <span class="tt">data</span>. If the <span class="tt">Word</span> type is <span class="tt">const</span>, the span will be read-only; otherwise, it will allow mutation.</p>
<p>However, you don't usually construct <span class="tt">BitSpan</span> objects directly. Instead, you typically obtain them from existing <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> objects using their <span class="tt">span</span> member functions:</p>
<ul>
<li><span class="tt">gf2::BitXXX::span(begin, end) const</span> creates a bit-span as a read-only view of the bits in the half open range <span class="tt">[begin, end)</span>.</li>
<li><span class="tt">gf2::BitXXX::span(begin, end)</span> creates a bit-span as a read-write view of the bits in the half open range <span class="tt">[begin, end)</span>.</li>
</ul>
<p>Here <span class="tt">BitXXX</span> can be any class that satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, such as <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span>, <span class="tt"><a class="el" href="classgf2_1_1BitArray.html" title="A fixed-size &quot;vector&quot; over GF(2) with N bit elements compactly stored in a standard array of primitiv...">gf2::BitArray</a></span>, or even <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> as taking a span of a span is supported.</p>
<p>Those methods use the generic <span class="tt"><a class="el" href="namespacegf2.html#a91642aa97f8c3823b3630dde99574a8b" title="Constructs a read-only bit-span over the const bit-store store for its bits in the range [begin,...">gf2::span</a></span> method defined for the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept as described <a class="el" href="md_docs_2pages_2BitStore.html#store-spans">here</a> documentation.</p>
<p>Spans can start in the middle of a machine word and can end part-way through another word; the class synthesises whole-word reads/writes for you.</p>
<dl class="section note"><dt>Note</dt><dd>Because a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> keeps a pointer back to the underlying word store, that store must outlive the span. In the Rust version of the library, this is enforced using lifetime parameters. In C++, this is just a convention the user must follow. We could use smart pointers to enforce this at runtime, but that would add overhead and complexity to the concrete <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> types.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="example-1"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">gf2::BitVector&lt;u8&gt;::from_string</a>(<span class="stringliteral">&quot;1111&#39;1111&#39;1111&quot;</span>).value();</div>
<div class="line">v.span(2, 6).flip_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;110000111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a17ba4f50de43f5e84ef3943ad77410ea"><div class="ttname"><a href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">gf2::BitVector::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:411</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="span-bit-access"></a>
Bit Access</h1>
<p>The following methods provide access to individual bit elements in the bit-span.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae3fbdca67b049aa5bef82749ea4fe235" title="Returns true if the bit at the given index i is set, false otherwise.">gf2::BitSpan::get</a></span>  </td><td class="markdownTableBodyNone">Returns the value of a single bit element as a read-only boolean.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a52e7a98ecc073c73f2229b6c471792a7" title="Returns the boolean value of the bit element i.">gf2::BitSpan::operator[]()</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">bool</span> in the const case and a <span class="tt">BitRef</span> with read-write access to a bit element in the non-const version.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a34e94da15e0f3e36fe52e06973226f98" title="Returns true if the first bit element is set, false otherwise.">gf2::BitSpan::front</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the first element in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#adf7aee770c68ff00c5661e603eaf92d4" title="Returns true if the last bit element is set, false otherwise.">gf2::BitSpan::back</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the last element in the bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a3b2047e801d179d9e243ab338f0c6773" title="Sets the bit-element i to the specified boolean value &amp; returns this for chaining....">gf2::BitSpan::set</a></span>  </td><td class="markdownTableBodyNone">Sets a bit to the given boolean value which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a476bf6e5ea68d524e2fca165b83ba8bc" title="Flips the value of the bit-element i and returns this for chaining.">gf2::BitSpan::flip</a></span>  </td><td class="markdownTableBodyNone">Flips the value of the bit element at a given index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a5b96d192e6044535677defc3f8b085e1" title="Swaps the bits in the bit-span at indices i0 and i1 and returns this for chaining.">gf2::BitSpan::swap</a></span>  </td><td class="markdownTableBodyNone">Swaps the values of bit elements at locations <span class="tt">i</span> and <span class="tt">j</span>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You can set the <span class="tt">DEBUG</span> flag at compile time to enable bounds checks on the index arguments.</dd></dl>
<p>The non-const version of <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a52e7a98ecc073c73f2229b6c471792a7" title="Returns the boolean value of the bit element i.">gf2::BitSpan::operator[]()</a></span> returns a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">gf2::BitRef</a></span>, which is "reference" to an individual bit in the vector. It is automatically converted to a boolean on reads, but it also allows writes, which means you can write natural-looking single-bit assignments:</p>
<div class="fragment"><div class="line">s[12] = <span class="keyword">true</span>;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="span-queries"></a>
Queries</h1>
<p>The following methods let you query the overall state of a bit-span.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a9b4d90a83d5f00f72d1bb5b4931afc07" title="Returns true if the bit-span is empty, false otherwise.">gf2::BitSpan::is_empty</a></span>  </td><td class="markdownTableBodyNone">Returns true if the bit-span is empty  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a3f4d5eb0f8ba3946b7f05997b1fd68d8" title="Returns true if at least one bit in the bit-span is set, false otherwise.">gf2::BitSpan::any</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>any</em> bit in the bit-span is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a7e851f65c3c245dacda0a74553955188" title="Returns true if all bits in the bit-span are set, false otherwise.">gf2::BitSpan::all</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>every</em> bit in the bit-span is set.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae7585b2c017b08faf41f0750b615aa2f" title="Returns true if no bits in the bit-span are set, false otherwise.">gf2::BitSpan::none</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>no</em> bit in the bit-span is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#af6565a89efdf0ed61935915868041506" title="Returns the number of set bits in the bit-span.">gf2::BitSpan::count_ones</a></span>  </td><td class="markdownTableBodyNone">Returns the number of set bits in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ab41c18bc9e9fb37a2436a3ef3063dbc5" title="Returns the number of unset bits in the bit-span.">gf2::BitSpan::count_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of unset bits in the bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a059036b3f45a74c977db87e131ec06ee" title="Returns the number of leading zeros in the bit-span.">gf2::BitSpan::leading_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of leading unset bits in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a7aef10820711679c5d9bcc8ec7507b64" title="Returns the number of trailing zeros in the bit-span.">gf2::BitSpan::trailing_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of trailing unset bits in the bit-span.  </td></tr>
</table>
<p>These methods efficiently operate on words at a time, so they are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="span-mutators"></a>
Mutators</h1>
<p>The following methods let you mutate the entire bit-span in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a0ca9d22615ea6325767b4280d846ecce" title="Sets the bits in the bit-span to the boolean value and returns a reference to this for chaining.">gf2::BitSpan::set_all</a></span>  </td><td class="markdownTableBodyNone">Sets all the bits in the span to the passed value, which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ac8e60c305a7e007fa362a2f3925a2d63" title="Flips the value of the bits in the bit-span and returns a reference to this for chaining.">gf2::BitSpan::flip_all</a></span>  </td><td class="markdownTableBodyNone">Flips the values of all the bits in the span.  </td></tr>
</table>
<p>The methods operate on words at a time, so are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="span-fills"></a>
Fills</h1>
<p>The following methods let you populate the entire bit-span in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae29df65f10c228aa9b8db2f02c594e9a" title="Copies all the bits from any unsigned integral src value to this equal-sized bit-span and returns a r...">gf2::BitSpan::copy</a></span>  </td><td class="markdownTableBodyNone">Makes the bits in this span identical to those from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#af413badf300407b7135af3ee9ee32c76" title="Fill the bit-span with random bits and returns a reference to this for chaining.">gf2::BitSpan::fill_random</a></span>  </td><td class="markdownTableBodyNone">Fills the span with random 0's and 1's.  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="copies-3"></a>
Copies</h2>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae29df65f10c228aa9b8db2f02c594e9a" title="Copies all the bits from any unsigned integral src value to this equal-sized bit-span and returns a r...">gf2::BitSpan::copy</a></span> methods support copying bits from:</p>
<ul>
<li>Another bit-store of the same size but possibly a different underlying word type.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> of the same size as the bit-span.</li>
<li>An unsigned integer that has the same number of bits as the span. The integer type need not be the same as the underlying <span class="tt">Word</span> used by the bit-span.</li>
<li>A function or callable object that takes a single <span class="tt">usize</span> index argument and returns a boolean value for that index.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In each case, the size of the source and destinations must match exactly and that condition is always checked unless the <span class="tt">NDEBUG</span> flag is set at compile time. You can always use a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> sub-span to copy a subset of bits if needed.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="random-fills-3"></a>
Random Fills</h2>
<p>By default, the random fill method uses a random number generator seeded with system entropy, so the results change from run to run. You can set a specific seed to get reproducible fills.</p>
<p>The default probability that a bit is set is 50%, but you can pass a different probability in the range <span class="tt">[0.0, 1.0]</span> if desired.</p>
<h1 class="doxsection"><a class="anchor" id="span-span"></a>
Spans</h1>
<p>The following methods let you create a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> from a bit-span &mdash; a <em>sub-bit-span</em>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aa08ebd188936122fa769a87869d342b5" title="Returns an immutable sub-span encompassing the bit-span&#39;s bits in the half-open range [begin,...">gf2::BitSpan::span</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aa08ebd188936122fa769a87869d342b5" title="Returns an immutable sub-span encompassing the bit-span&#39;s bits in the half-open range [begin,...">gf2::BitSpan::span</a></span> method &mdash; one for <span class="tt">const</span> bit-spans and one for non-<span class="tt">const</span> bit-spans:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> span(usize begin, usize end);        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> span(usize begin, usize end) <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that allows modification of the bits in the specified range.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that does not allow modification of the bits in the specified range.</li>
</ol>
<p>In both cases, the <span class="tt">begin</span> and <span class="tt">end</span> arguments define a half-open range of bits in the vector.</p>
<p>Mutability/immutability of the returned <span class="tt">BitSpan</span> is <em>deep</em>. The span's mutability reflects that of the underlying vector, so if the vector is mutable, so is the span, and vice versa.</p>
<p>This is similar to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span.html"><span class="tt">std::span</span></a> class for regular data collection types.</p>
<dl class="section note"><dt>Note</dt><dd>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> also satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, so you can take a span of a span.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="span-sub-vectors"></a>
Sub-vectors</h1>
<p>The following methods create or fill <em>independent</em> bit-vectors with copies of some contiguous subset of the bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a06b220f8ea7fbfd8633e7b3d34fea232" title="Returns a clone of the span elements in the half-open range [begin, end) as a new bit-vector.">gf2::BitSpan::sub</a></span>  </td><td class="markdownTableBodyNone">Returns a new <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVector</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae116b38d6233851868423b5351684880" title="Views a bit-span as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitSpan::split_at</a></span>  </td><td class="markdownTableBodyNone">Fills two bit-vectors with the bits in the ranges <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span>.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ae116b38d6233851868423b5351684880" title="Views a bit-span as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitSpan::split_at</a></span> method can optionally take two pre-existing bit-vectors to fill, thereby avoiding unnecessary allocations in some iterative algorithms that repeatedly use this method.</p>
<dl class="section note"><dt>Note</dt><dd>These methods do not alter the underlying vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="span-riffling"></a>
Riffling</h1>
<p>We have methods that can interleave (<em>riffle</em>) the bits in a span with zeros.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aeb83fa6b8e6e2adfafd090fed6d69184" title="Interleaves the bits of this bit-span with zeros storing the result into the bit-vector dst.">gf2::BitSpan::riffled</a></span>  </td><td class="markdownTableBodyNone">Fills a pre-existing bit-vector with the result of riffling this bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aeb83fa6b8e6e2adfafd090fed6d69184" title="Interleaves the bits of this bit-span with zeros storing the result into the bit-vector dst.">gf2::BitSpan::riffled</a></span>  </td><td class="markdownTableBodyNone">Returns a new bit-vector that is this bit-span with its bits interleaved with zeros.  </td></tr>
</table>
<p>If the bit-span looks like \(v_0 v_1 v_2 \ldots v_n\), then the riffling operation produces the vector \(v_0 0 v_1 0 v_2 0 \ldots v_n\) where a zero is interleaved <em>between</em> every bit in the original bit-span (there is no trailing zero at the end).</p>
<p>If you think of a bit-span as representing the coefficients of a polynomial over GF(2), then riffling corresponds to squaring that polynomial. See the documentation for <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html#a30309419a9ed46754fc450052ef19bfb" title="Fills dst with the square of this bit-polynomial.">gf2::BitPolynomial::squared</a></span> for more information.</p>
<h1 class="doxsection"><a class="anchor" id="span-indices"></a>
Set/Unset Bit Indices</h1>
<p>The following methods find the indices of set or unset bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a0fdef5132eb0b3c7740b044819f64b93" title="Returns the index of the first set bit in the bit-span or {} if no bits are set.">gf2::BitSpan::first_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first set bit in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#acddfd80b128f10f3fff457ab25aeb259" title="Returns the index of the last set bit in the bit-span or {} if no bits are set.">gf2::BitSpan::last_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last set bit in the bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a3aea63deddac89a9f375e9888b7f0d05" title="Returns the index of the next set bit after index in the bit-span or {} if no more set bits exist.">gf2::BitSpan::next_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next set bit in the bit-span <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aada8bd4b9e0ebb906850af368800e27c" title="Returns the index of the previous set bit before index in the bit-span or {} if there are none.">gf2::BitSpan::previous_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous set bit in the bit-span <em>before</em> the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a9da6a99b6ebcfe256ea7f42be2a28fa2" title="Returns the index of the first unset bit in the bit-span or {} if no bits are unset.">gf2::BitSpan::first_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first unset bit in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ab0fd1eeeb86c93c01b299ef6ea37c28b" title="Returns the index of the last unset bit in the bit-span or {} if no bits are unset.">gf2::BitSpan::last_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last unset bit in the bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a6fdfccbb5f1edf0c95258da7d21e6c4d" title="Returns the index of the next unset bit after index in the bit-span or {} if no more unset bits exist...">gf2::BitSpan::next_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next unset bit in the bit-span <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#ad388e08f60848e03910e2c0a4a779d2f" title="Returns the index of the previous unset bit before index in the bit-span or {} if no more unset bits ...">gf2::BitSpan::previous_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous unset bit in the bit-span <em>before</em> the passed index.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="span-iterators"></a>
Iterators</h1>
<p>The following methods create iterators for traversing the bits or underlying words in the bit-span:</p>
<ul>
<li>Read-only iteration through the individual bits.</li>
<li>Read-write iteration through the individual bits.</li>
<li>Read-only iteration through the indices of the set bits.</li>
<li>Read-only iteration through the indices of the unset bits.</li>
<li>Read-write iteration through the underlying vector words.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a8362316bef3380d4ff685dd7e21f27ba" title="Returns a const iterator over the bool values of the bits in the const bit-span.">gf2::BitSpan::bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> iterator over the bits in the bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aac52c3efe00a377beb8ab1007944e0b1" title="Returns an iterator over the indices of any set bits in the bit-span.">gf2::BitSpan::set_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1SetBits.html" title="An iterator over the index locations of the set bits in a bit-store.   You get this iterator by calli...">gf2::SetBits</a></span> iterator to view the indices of all the set bits.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a1de37852da1f30fba3fe368b50b05a96" title="Returns an iterator over the indices of any unset bits in the bit-span.">gf2::BitSpan::unset_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1UnsetBits.html" title="An iterator over the index locations of the unset bits in a bit-store.  You get this iterator by call...">gf2::UnsetBits</a></span> iterator to view the indices of all the unset bits.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aa9dc6987e7cd000ddae27d53b5734078" title="Returns a const iterator over all the words underlying the bit-span.">gf2::BitSpan::store_words</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Words.html" title="An iterator over the &quot;words&quot; underlying a bit-store.  You get this iterator by calling the BitStore::...">gf2::Words</a></span> iterator to view the "words" underlying the bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#af936e824e11da1392f9ad55e5f2fe742" title="Returns a copy of the words underlying this bit-span.">gf2::BitSpan::to_words</a></span>  </td><td class="markdownTableBodyNone">Returns a copy of the "words" underlying the bit-span.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a8362316bef3380d4ff685dd7e21f27ba" title="Returns a const iterator over the bool values of the bits in the const bit-span.">gf2::BitSpan::bits</a></span> method &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bits();        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> bits() <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that allows modification of the bits in the bit-span.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that only allows one to view the bits in the bit-span.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="span-stringification"></a>
Stringification</h1>
<p>The following methods return a string representation for a bit-span. The string can be in the obvious binary format or a more compact hex format.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a8f5e28cc16718e22973c9fec0ddfe077" title="Returns a binary string representation of the bit-span.">gf2::BitSpan::to_string</a></span>  </td><td class="markdownTableBodyNone">Returns a default string representation for a bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aaba2ace208f196f67c90700eb41c9621" title="Returns a &quot;pretty&quot; string representation of the bit-span.">gf2::BitSpan::to_pretty_string</a></span>  </td><td class="markdownTableBodyNone">Returns a "pretty" string representation for a bit-span.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#a8944b9e4308a59b2f2a8a9d4b725a57e" title="Returns a binary string representation of the bit-span.">gf2::BitSpan::to_binary_string</a></span>  </td><td class="markdownTableBodyNone">Returns a binary string representation for a bit-span.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html#aa1b295282604bd942c5831fb835d4af3" title="Returns the &quot;hex&quot; string representation of the bits in the bit-span.">gf2::BitSpan::to_hex_string</a></span>  </td><td class="markdownTableBodyNone">Returns a compact hex string representation for a bit-span.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="other-operators-and-functions-2"></a>
Other Operators and Functions</h1>
<p>There are many operators and free functions defined for any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> compatible class, including:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-spans for content equality.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-spans left or right.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-spans.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="see-also-3"></a>
See Also</h1>
<ul>
<li><span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> for detailed documentation of all class methods.</li>
<li><a class="el" href="md_docs_2pages_2BitStore.html"><span class="tt">BitStore</span></a> for the common API shared by all bit-stores.</li>
<li><a class="el" href="md_docs_2pages_2BitArray.html"><span class="tt">BitArray</span></a> for fixed-size vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitVector.html"><span class="tt">BitVector</span></a> for dynamically-sized vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitMatrix.html"><span class="tt">BitMatrix</span></a> for matrices of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitPolynomial.html"><span class="tt">BitPolynomial</span></a> for polynomials over GF(2). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
