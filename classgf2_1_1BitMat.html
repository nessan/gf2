<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitMat&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitMat.html','','classgf2_1_1BitMat-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitMat&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the matrix. The row elements are compactly stored in standard vectors of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitMat_8h_source.html">BitMat.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36f4797be3063da29d79c583f0aa25a0" id="r_a36f4797be3063da29d79c583f0aa25a0"><td class="memItemLeft" align="right" valign="top"><a id="a36f4797be3063da29d79c583f0aa25a0" name="a36f4797be3063da29d79c583f0aa25a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_type</b> = Word</td></tr>
<tr class="memdesc:a36f4797be3063da29d79c583f0aa25a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying unsigned word type used to store the bits. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ae88d67d1d6526d751964b519979f4001" id="r_ae88d67d1d6526d751964b519979f4001"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> ()</td></tr>
<tr class="memdesc:ae88d67d1d6526d751964b519979f4001"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor creates an empty bit-matrix with no rows or columns.  <br /></td></tr>
<tr class="memitem:ababf780896aab3cbfe7f99ceb8ccaa8f" id="r_ababf780896aab3cbfe7f99ceb8ccaa8f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ababf780896aab3cbfe7f99ceb8ccaa8f">BitMat</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ababf780896aab3cbfe7f99ceb8ccaa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> square bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:ab62ab2830d46def8b471b78c914c25ea" id="r_ab62ab2830d46def8b471b78c914c25ea"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab62ab2830d46def8b471b78c914c25ea">BitMat</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ab62ab2830d46def8b471b78c914c25ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">m x n</span> bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:a49d594838ff085d343313e536735e4a3" id="r_a49d594838ff085d343313e536735e4a3"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49d594838ff085d343313e536735e4a3">BitMat</a> (std::vector&lt; row_type &gt; const &amp;<a class="el" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>)</td></tr>
<tr class="memdesc:a49d594838ff085d343313e536735e4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit-matrix by <em>copying</em> a given set of rows which can be any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> subclass.  <br /></td></tr>
<tr class="memitem:a4e338445333cc47845318db556ca61d9" id="r_a4e338445333cc47845318db556ca61d9"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e338445333cc47845318db556ca61d9">BitMat</a> (std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; &amp;&amp;<a class="el" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>)</td></tr>
<tr class="memdesc:a4e338445333cc47845318db556ca61d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit-matrix by <em>moving</em> the given rows.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Basic queries</div></td></tr>
<tr class="memitem:a87fe993bc8a0d39b5ef2cf560b6a67e0" id="r_a87fe993bc8a0d39b5ef2cf560b6a67e0"><td class="memItemLeft" align="right" valign="top"><a id="a87fe993bc8a0d39b5ef2cf560b6a67e0" name="a87fe993bc8a0d39b5ef2cf560b6a67e0"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const</td></tr>
<tr class="memdesc:a87fe993bc8a0d39b5ef2cf560b6a67e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the bit-matrix. <br /></td></tr>
<tr class="memitem:a52b02d91b49c16245b6279daf7e9c1fe" id="r_a52b02d91b49c16245b6279daf7e9c1fe"><td class="memItemLeft" align="right" valign="top"><a id="a52b02d91b49c16245b6279daf7e9c1fe" name="a52b02d91b49c16245b6279daf7e9c1fe"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () const</td></tr>
<tr class="memdesc:a52b02d91b49c16245b6279daf7e9c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the bit-matrix. <br /></td></tr>
<tr class="memitem:a4b80149b9005d284382d2068de045d54" id="r_a4b80149b9005d284382d2068de045d54"><td class="memItemLeft" align="right" valign="top"><a id="a4b80149b9005d284382d2068de045d54" name="a4b80149b9005d284382d2068de045d54"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a4b80149b9005d284382d2068de045d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the totalnumber of elements in the bit-matrix. <br /></td></tr>
<tr class="memitem:aa309f523903a7794d74a6459c7abf986" id="r_aa309f523903a7794d74a6459c7abf986"><td class="memItemLeft" align="right" valign="top"><a id="aa309f523903a7794d74a6459c7abf986" name="aa309f523903a7794d74a6459c7abf986"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const</td></tr>
<tr class="memdesc:aa309f523903a7794d74a6459c7abf986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an empty bit-matrix? <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Checks for Special Bit-Matrices</div></td></tr>
<tr class="memitem:a1866dc22def29600967442d125eed667" id="r_a1866dc22def29600967442d125eed667"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1866dc22def29600967442d125eed667">is_square</a> () const</td></tr>
<tr class="memdesc:a1866dc22def29600967442d125eed667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this a square bit-matrix? Note that empty bit-matrices are NOT considered square.  <br /></td></tr>
<tr class="memitem:a80ab7bdc92c767b229cac62fb7f3141e" id="r_a80ab7bdc92c767b229cac62fb7f3141e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80ab7bdc92c767b229cac62fb7f3141e">is_zero</a> () const</td></tr>
<tr class="memdesc:a80ab7bdc92c767b229cac62fb7f3141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this a square <em>zero</em> bit-matrix?  <br /></td></tr>
<tr class="memitem:a47dfb8e771473880ba37987998b8afd6" id="r_a47dfb8e771473880ba37987998b8afd6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47dfb8e771473880ba37987998b8afd6">is_identity</a> () const</td></tr>
<tr class="memdesc:a47dfb8e771473880ba37987998b8afd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this is the identity bit-matrix.  <br /></td></tr>
<tr class="memitem:a7b823c9c540470e403d9db1a8ca1f16d" id="r_a7b823c9c540470e403d9db1a8ca1f16d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b823c9c540470e403d9db1a8ca1f16d">is_symmetric</a> () const</td></tr>
<tr class="memdesc:a7b823c9c540470e403d9db1a8ca1f16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this is a symmetric square bit-matrix.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts</div></td></tr>
<tr class="memitem:a759c68d79bc0106a90336c1bb889b430" id="r_a759c68d79bc0106a90336c1bb889b430"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759c68d79bc0106a90336c1bb889b430">count_ones</a> () const</td></tr>
<tr class="memdesc:a759c68d79bc0106a90336c1bb889b430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of one elements in the bit-matrix.  <br /></td></tr>
<tr class="memitem:ae9afa535b18f184a9dfba210085d550f" id="r_ae9afa535b18f184a9dfba210085d550f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9afa535b18f184a9dfba210085d550f">count_zeros</a> () const</td></tr>
<tr class="memdesc:ae9afa535b18f184a9dfba210085d550f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of zero elements in the bit-matrix.  <br /></td></tr>
<tr class="memitem:a22ba781dbadb2943b5987ef65d972903" id="r_a22ba781dbadb2943b5987ef65d972903"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ba781dbadb2943b5987ef65d972903">count_ones_on_diagonal</a> () const</td></tr>
<tr class="memdesc:a22ba781dbadb2943b5987ef65d972903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ones on the main diagonal of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a02e025abc390a94b8fb9bc9b0de34f2f" id="r_a02e025abc390a94b8fb9bc9b0de34f2f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e025abc390a94b8fb9bc9b0de34f2f">trace</a> () const</td></tr>
<tr class="memdesc:a02e025abc390a94b8fb9bc9b0de34f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "sum" of the main diagonal elements of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Overall State Queries</div></td></tr>
<tr class="memitem:ae899d183312149f2b855d7e0a60cee01" id="r_ae899d183312149f2b855d7e0a60cee01"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae899d183312149f2b855d7e0a60cee01">any</a> () const</td></tr>
<tr class="memdesc:ae899d183312149f2b855d7e0a60cee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if any element of the bit-matrix is set.  <br /></td></tr>
<tr class="memitem:a8f8ef3c907ec4036c862f650bcd71c97" id="r_a8f8ef3c907ec4036c862f650bcd71c97"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f8ef3c907ec4036c862f650bcd71c97">all</a> () const</td></tr>
<tr class="memdesc:a8f8ef3c907ec4036c862f650bcd71c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all elements of the bit-matrix are set.  <br /></td></tr>
<tr class="memitem:ae141b42cbf7de80e0e4c870cc9912e94" id="r_ae141b42cbf7de80e0e4c870cc9912e94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae141b42cbf7de80e0e4c870cc9912e94">none</a> () const</td></tr>
<tr class="memdesc:ae141b42cbf7de80e0e4c870cc9912e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no elements of the bit-matrix are set.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Individual Element Access</div></td></tr>
<tr class="memitem:a20d4b073fa358adea7bdba8fee0c8fc7" id="r_a20d4b073fa358adea7bdba8fee0c8fc7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20d4b073fa358adea7bdba8fee0c8fc7">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:a20d4b073fa358adea7bdba8fee0c8fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the element at row <span class="tt">r</span> and column <span class="tt">c</span> is set.  <br /></td></tr>
<tr class="memitem:a7b6a6cf8e2b0eed3584e8830c4ce546b" id="r_a7b6a6cf8e2b0eed3584e8830c4ce546b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6a6cf8e2b0eed3584e8830c4ce546b">operator()</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:a7b6a6cf8e2b0eed3584e8830c4ce546b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt">bool</span>.  <br /></td></tr>
<tr class="memitem:a2e39b9d992f6fe59c23c0f6cbded28d5" id="r_a2e39b9d992f6fe59c23c0f6cbded28d5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e39b9d992f6fe59c23c0f6cbded28d5">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c, bool val=true)</td></tr>
<tr class="memdesc:a2e39b9d992f6fe59c23c0f6cbded28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at row <span class="tt">r</span> and column <span class="tt">c</span> to the bool value <span class="tt">val</span>. The default is to set the bit to <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:aabe08eabd2076e61c9fbe19104f8c96a" id="r_aabe08eabd2076e61c9fbe19104f8c96a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgf2_1_1BitRef.html">BitRef</a>&lt; row_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe08eabd2076e61c9fbe19104f8c96a">operator()</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:aabe08eabd2076e61c9fbe19104f8c96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference which can be used to set the bit.  <br /></td></tr>
<tr class="memitem:a274ecdffe91e8c6641505c4ee6fe1953" id="r_a274ecdffe91e8c6641505c4ee6fe1953"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a274ecdffe91e8c6641505c4ee6fe1953">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:a274ecdffe91e8c6641505c4ee6fe1953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the bit at row <span class="tt">r</span> and column <span class="tt">c</span>.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Row Access</div></td></tr>
<tr class="memitem:a5ab87bba4f2a0646d6068f44266ec81b" id="r_a5ab87bba4f2a0646d6068f44266ec81b"><td class="memItemLeft" align="right" valign="top">constexpr const row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r) const</td></tr>
<tr class="memdesc:a5ab87bba4f2a0646d6068f44266ec81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:a24e9d7b9616adbba1eb4e6ebc9f181a5" id="r_a24e9d7b9616adbba1eb4e6ebc9f181a5"><td class="memItemLeft" align="right" valign="top">constexpr row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24e9d7b9616adbba1eb4e6ebc9f181a5">row</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:a24e9d7b9616adbba1eb4e6ebc9f181a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:a6af885c95cc27a028ffb4a5782db3719" id="r_a6af885c95cc27a028ffb4a5782db3719"><td class="memItemLeft" align="right" valign="top">constexpr const row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af885c95cc27a028ffb4a5782db3719">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r) const</td></tr>
<tr class="memdesc:a6af885c95cc27a028ffb4a5782db3719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:abb467d738570f4da88a4e9de219e7edd" id="r_abb467d738570f4da88a4e9de219e7edd"><td class="memItemLeft" align="right" valign="top">constexpr row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb467d738570f4da88a4e9de219e7edd">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:abb467d738570f4da88a4e9de219e7edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Column Access</div></td></tr>
<tr class="memitem:a7289082679dd8cf05d64203c3a98c4c1" id="r_a7289082679dd8cf05d64203c3a98c4c1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:a7289082679dd8cf05d64203c3a98c4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <b>clone</b> of the elements in column <span class="tt">c</span> from the bit-matrix as an independent bit-vector.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Whole Matrix Mutators</div></td></tr>
<tr class="memitem:a5198a02dbcd29f646fc0d92c1a608f97" id="r_a5198a02dbcd29f646fc0d92c1a608f97"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5198a02dbcd29f646fc0d92c1a608f97">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:a5198a02dbcd29f646fc0d92c1a608f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the elements of the bit-matrix to the specified boolean <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a726888e876c2ca2251c78b791a0370d2" id="r_a726888e876c2ca2251c78b791a0370d2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726888e876c2ca2251c78b791a0370d2">flip_all</a> ()</td></tr>
<tr class="memdesc:a726888e876c2ca2251c78b791a0370d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Diagonal Mutators</div></td></tr>
<tr class="memitem:ac80c7f066605d218565eac56983318d6" id="r_ac80c7f066605d218565eac56983318d6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac80c7f066605d218565eac56983318d6">set_diagonal</a> (bool val=true)</td></tr>
<tr class="memdesc:ac80c7f066605d218565eac56983318d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the main diagonal of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a4b2c6382c50f0ba2f8a573b26eb8ae5f" id="r_a4b2c6382c50f0ba2f8a573b26eb8ae5f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b2c6382c50f0ba2f8a573b26eb8ae5f">flip_diagonal</a> ()</td></tr>
<tr class="memdesc:a4b2c6382c50f0ba2f8a573b26eb8ae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the main diagonal of a square bit-matrix.  <br /></td></tr>
<tr class="memitem:a500b8f1c9f32696358e3741cd3f75d81" id="r_a500b8f1c9f32696358e3741cd3f75d81"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a500b8f1c9f32696358e3741cd3f75d81">set_super_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d, bool val=true)</td></tr>
<tr class="memdesc:a500b8f1c9f32696358e3741cd3f75d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the elements on super-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a55a8d19de3575a8886a733fd39fa6465" id="r_a55a8d19de3575a8886a733fd39fa6465"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a8d19de3575a8886a733fd39fa6465">flip_super_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d)</td></tr>
<tr class="memdesc:a55a8d19de3575a8886a733fd39fa6465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the super-diagonal <span class="tt">d</span> of a square bit-matrix.  <br /></td></tr>
<tr class="memitem:afc119aab0b19902541667b698156e31d" id="r_afc119aab0b19902541667b698156e31d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc119aab0b19902541667b698156e31d">set_sub_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d, bool val=true)</td></tr>
<tr class="memdesc:afc119aab0b19902541667b698156e31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the elements on sub-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a4eba9d954df9bc073da81bcc615e8008" id="r_a4eba9d954df9bc073da81bcc615e8008"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eba9d954df9bc073da81bcc615e8008">flip_sub_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d)</td></tr>
<tr class="memdesc:a4eba9d954df9bc073da81bcc615e8008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the sub-diagonal <span class="tt">d</span> of a square bit-matrix.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Resizing</div></td></tr>
<tr class="memitem:a70e4088cf3f89e13e827d157266b4033" id="r_a70e4088cf3f89e13e827d157266b4033"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70e4088cf3f89e13e827d157266b4033">resize</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:a70e4088cf3f89e13e827d157266b4033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the bit-matrix to <span class="tt">r</span> rows and <span class="tt">c</span> columns.  <br /></td></tr>
<tr class="memitem:a8ec6c8b1e48b95e5fe074f95be7b98f0" id="r_a8ec6c8b1e48b95e5fe074f95be7b98f0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ec6c8b1e48b95e5fe074f95be7b98f0">clear</a> ()</td></tr>
<tr class="memdesc:a8ec6c8b1e48b95e5fe074f95be7b98f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the bit-matrix.  <br /></td></tr>
<tr class="memitem:ab6ff34707914ed583f6a7ebde3e2d3f7" id="r_ab6ff34707914ed583f6a7ebde3e2d3f7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ff34707914ed583f6a7ebde3e2d3f7">make_square</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ab6ff34707914ed583f6a7ebde3e2d3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an arbitrary rectangular bit-matrix into a square <span class="tt"><a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a></span>.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Appending Rows and Columns</div></td></tr>
<tr class="memitem:ae37ed6cc2376ddc9ca89cdb1dc280499" id="r_ae37ed6cc2376ddc9ca89cdb1dc280499"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:ae37ed6cc2376ddc9ca89cdb1dc280499 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37ed6cc2376ddc9ca89cdb1dc280499">append_row</a> (Store const &amp;<a class="el" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a>)</td></tr>
<tr class="memdesc:ae37ed6cc2376ddc9ca89cdb1dc280499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single row onto the end of the bit-matrix by copying it.  <br /></td></tr>
<tr class="memitem:ac068c4b7cd9920cd07e1df4f7941bc7d" id="r_ac068c4b7cd9920cd07e1df4f7941bc7d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:ac068c4b7cd9920cd07e1df4f7941bc7d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac068c4b7cd9920cd07e1df4f7941bc7d">append_row</a> (Store &amp;&amp;<a class="el" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a>)</td></tr>
<tr class="memdesc:ac068c4b7cd9920cd07e1df4f7941bc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single row onto the end of the bit-matrix by moving it.  <br /></td></tr>
<tr class="memitem:a8f1f953d761b58b5265d21ef71030396" id="r_a8f1f953d761b58b5265d21ef71030396"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1f953d761b58b5265d21ef71030396">append_rows</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:a8f1f953d761b58b5265d21ef71030396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by copying them.  <br /></td></tr>
<tr class="memitem:a7c38b7a6ef8b806fcce2971b99b2dab2" id="r_a7c38b7a6ef8b806fcce2971b99b2dab2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c38b7a6ef8b806fcce2971b99b2dab2">append_rows</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:a7c38b7a6ef8b806fcce2971b99b2dab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by moving them.  <br /></td></tr>
<tr class="memitem:a2df802cd1d9d0823b77260d08462a08d" id="r_a2df802cd1d9d0823b77260d08462a08d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:a2df802cd1d9d0823b77260d08462a08d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2df802cd1d9d0823b77260d08462a08d">append_col</a> (Store const &amp;<a class="el" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>)</td></tr>
<tr class="memdesc:a2df802cd1d9d0823b77260d08462a08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single column <span class="tt"><a class="el" href="#a7289082679dd8cf05d64203c3a98c4c1" title="Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.">col</a></span> onto the right of the bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|col</span>.  <br /></td></tr>
<tr class="memitem:aff4bb82509b25dfc364fe8ee9a20049e" id="r_aff4bb82509b25dfc364fe8ee9a20049e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff4bb82509b25dfc364fe8ee9a20049e">append_cols</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:aff4bb82509b25dfc364fe8ee9a20049e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the columns from the <span class="tt">src</span> bit-matrix onto the right of this bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|src</span>.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Removing Rows and Columns</div></td></tr>
<tr class="memitem:a759c2f35c863f577b4e70fe0fde715ca" id="r_a759c2f35c863f577b4e70fe0fde715ca"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759c2f35c863f577b4e70fe0fde715ca">remove_row</a> ()</td></tr>
<tr class="memdesc:a759c2f35c863f577b4e70fe0fde715ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a row off the end of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty.  <br /></td></tr>
<tr class="memitem:af59fc626168269636a1e68d7e08dd5e0" id="r_af59fc626168269636a1e68d7e08dd5e0"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af59fc626168269636a1e68d7e08dd5e0">remove_rows</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> k)</td></tr>
<tr class="memdesc:af59fc626168269636a1e68d7e08dd5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <span class="tt">k</span> rows off the end of the bit-matrix and returns them as a new bit-matrix or <span class="tt">std::nullopt</span> if the bit-matrix has fewer than <span class="tt">k</span> rows.  <br /></td></tr>
<tr class="memitem:abbe7a6152e2e67e44c51d3d4cc6897b1" id="r_abbe7a6152e2e67e44c51d3d4cc6897b1"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe7a6152e2e67e44c51d3d4cc6897b1">remove_col</a> ()</td></tr>
<tr class="memdesc:abbe7a6152e2e67e44c51d3d4cc6897b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a column off the right of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-matrices</div></td></tr>
<tr class="memitem:a41fadec6e42fd59379f6b0e5a6efda98" id="r_a41fadec6e42fd59379f6b0e5a6efda98"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41fadec6e42fd59379f6b0e5a6efda98">sub_matrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r_start, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r_end, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c_start, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c_end) const</td></tr>
<tr class="memdesc:a41fadec6e42fd59379f6b0e5a6efda98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the sub-matrix delimited by the given row and column ranges.  <br /></td></tr>
<tr class="memitem:aa8862fec79e74a2ddfb70e0fca589658" id="r_aa8862fec79e74a2ddfb70e0fca589658"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8862fec79e74a2ddfb70e0fca589658">replace_sub_matrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> top, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> left, <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:aa8862fec79e74a2ddfb70e0fca589658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the sub-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span> with a copy of the sub-matrix <span class="tt">src</span>.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Triangular Sub-Matrices</div></td></tr>
<tr class="memitem:af703e868dd9e46d089129df2e81fe371" id="r_af703e868dd9e46d089129df2e81fe371"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af703e868dd9e46d089129df2e81fe371">lower</a> () const</td></tr>
<tr class="memdesc:af703e868dd9e46d089129df2e81fe371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a11315f46b66ca7c0cb2a9986fb61ef32" id="r_a11315f46b66ca7c0cb2a9986fb61ef32"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11315f46b66ca7c0cb2a9986fb61ef32">upper</a> () const</td></tr>
<tr class="memdesc:a11315f46b66ca7c0cb2a9986fb61ef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the upper triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a0c897f53bba819c34da0528ad242ecbc" id="r_a0c897f53bba819c34da0528ad242ecbc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c897f53bba819c34da0528ad242ecbc">strictly_lower</a> () const</td></tr>
<tr class="memdesc:a0c897f53bba819c34da0528ad242ecbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the strictly lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:aca3e37cc6d930c3d5d0dd0ff6cf76631" id="r_aca3e37cc6d930c3d5d0dd0ff6cf76631"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3e37cc6d930c3d5d0dd0ff6cf76631">strictly_upper</a> () const</td></tr>
<tr class="memdesc:aca3e37cc6d930c3d5d0dd0ff6cf76631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the strictly upper triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a50a51b4d0fea918d1fbe4cf500cdf70b" id="r_a50a51b4d0fea918d1fbe4cf500cdf70b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a51b4d0fea918d1fbe4cf500cdf70b">unit_lower</a> () const</td></tr>
<tr class="memdesc:a50a51b4d0fea918d1fbe4cf500cdf70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the unit lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:ab9f46255165a99c13bd4ef61dd50c640" id="r_ab9f46255165a99c13bd4ef61dd50c640"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f46255165a99c13bd4ef61dd50c640">unit_upper</a> () const</td></tr>
<tr class="memdesc:ab9f46255165a99c13bd4ef61dd50c640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the unit upper triangular part of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Elementary Row and Column Operations</div></td></tr>
<tr class="memitem:a64ed6512ab98ea82089f1e828d51cef7" id="r_a64ed6512ab98ea82089f1e828d51cef7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ed6512ab98ea82089f1e828d51cef7">swap_rows</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> j)</td></tr>
<tr class="memdesc:a64ed6512ab98ea82089f1e828d51cef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps rows <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a5b75df0cea860b3fbe9ba65cf1362a74" id="r_a5b75df0cea860b3fbe9ba65cf1362a74"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b75df0cea860b3fbe9ba65cf1362a74">swap_cols</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> j)</td></tr>
<tr class="memdesc:a5b75df0cea860b3fbe9ba65cf1362a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps columns <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a7b14b90a3d53cdc56cae3aa00f9861c2" id="r_a7b14b90a3d53cdc56cae3aa00f9861c2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b14b90a3d53cdc56cae3aa00f9861c2">add_identity</a> ()</td></tr>
<tr class="memdesc:a7b14b90a3d53cdc56cae3aa00f9861c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the identity bit-matrix to the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Transposing</div></td></tr>
<tr class="memitem:aa802a4ff75e7618e5d9b793597f744d3" id="r_aa802a4ff75e7618e5d9b793597f744d3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa802a4ff75e7618e5d9b793597f744d3">transposed</a> () const</td></tr>
<tr class="memdesc:aa802a4ff75e7618e5d9b793597f744d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is the transpose of this one.  <br /></td></tr>
<tr class="memitem:a04e78961de3d0e90c645843558cc2e4e" id="r_a04e78961de3d0e90c645843558cc2e4e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04e78961de3d0e90c645843558cc2e4e">transpose</a> ()</td></tr>
<tr class="memdesc:a04e78961de3d0e90c645843558cc2e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a <em>square</em> bit-matrix in place.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Exponentiation</div></td></tr>
<tr class="memitem:af0e373a9641584346c4c1bad6dbcd183" id="r_af0e373a9641584346c4c1bad6dbcd183"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e373a9641584346c4c1bad6dbcd183">to_the</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, bool n_is_log2=false) const</td></tr>
<tr class="memdesc:af0e373a9641584346c4c1bad6dbcd183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is this one raised to some power <span class="tt">n</span> or <span class="tt">2^n</span>.  <br /></td></tr>
<tr id="pub-methods-18" class="groupHeader"><td colspan="2"><div class="groupHeader">Row-echelon forms</div></td></tr>
<tr class="memitem:a7f21e17fa903fe1f2da8cfbe5f6b1f2d" id="r_a7f21e17fa903fe1f2da8cfbe5f6b1f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f21e17fa903fe1f2da8cfbe5f6b1f2d">to_echelon_form</a> ()</td></tr>
<tr class="memdesc:a7f21e17fa903fe1f2da8cfbe5f6b1f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an arbitrary shaped, non-empty, bit-matrix to row-echelon form (in-place).  <br /></td></tr>
<tr class="memitem:a570344257f8263b952330221702c6a11" id="r_a570344257f8263b952330221702c6a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570344257f8263b952330221702c6a11">to_reduced_echelon_form</a> ()</td></tr>
<tr class="memdesc:a570344257f8263b952330221702c6a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the bit-matrix to reduced row-echelon form (in-place).  <br /></td></tr>
<tr id="pub-methods-19" class="groupHeader"><td colspan="2"><div class="groupHeader">LU Decomposition</div></td></tr>
<tr class="memitem:a84e53cded14276bb661c2ed6639c7bdb" id="r_a84e53cded14276bb661c2ed6639c7bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitLU.html">BitLU</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e53cded14276bb661c2ed6639c7bdb">LU</a> () const</td></tr>
<tr class="memdesc:a84e53cded14276bb661c2ed6639c7bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LU decomposition of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-20" class="groupHeader"><td colspan="2"><div class="groupHeader">Solving systems of linear equations</div></td></tr>
<tr class="memitem:ae989c3b9d8eef5067aaa4d5c19ffc44a" id="r_ae989c3b9d8eef5067aaa4d5c19ffc44a"><td class="memTemplParams" colspan="2">template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:ae989c3b9d8eef5067aaa4d5c19ffc44a template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae989c3b9d8eef5067aaa4d5c19ffc44a">solver_for</a> (Rhs const &amp;b) const</td></tr>
<tr class="memdesc:ae989c3b9d8eef5067aaa4d5c19ffc44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gaussian elimination solver for this bit-matrix and the passed r.h.s. vector <span class="tt">b</span>.  <br /></td></tr>
<tr class="memitem:aa6a25d388b498f7079227d80e70e6fbb" id="r_aa6a25d388b498f7079227d80e70e6fbb"><td class="memTemplParams" colspan="2">template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:aa6a25d388b498f7079227d80e70e6fbb template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a25d388b498f7079227d80e70e6fbb">x_for</a> (Rhs const &amp;b) const</td></tr>
<tr class="memdesc:aa6a25d388b498f7079227d80e70e6fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a solution to the system of linear equations <span class="tt">A.x_ = b</span> or <span class="tt">std::nullopt</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-21" class="groupHeader"><td colspan="2"><div class="groupHeader">Bitwise Operations</div></td></tr>
<tr class="memitem:aac0b998639028daff95ec0ed6eb44fd7" id="r_aac0b998639028daff95ec0ed6eb44fd7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac0b998639028daff95ec0ed6eb44fd7">operator^=</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aac0b998639028daff95ec0ed6eb44fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">XOR</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:ad01c6bc4178dd73359742fb47c334836" id="r_ad01c6bc4178dd73359742fb47c334836"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01c6bc4178dd73359742fb47c334836">operator&amp;=</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ad01c6bc4178dd73359742fb47c334836"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">AND</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:a624a562c12012acf68453cecb132ccb3" id="r_a624a562c12012acf68453cecb132ccb3"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a624a562c12012acf68453cecb132ccb3">operator|=</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a624a562c12012acf68453cecb132ccb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">OR</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:afa27f2b61500c4ece084b72c4548c5e4" id="r_afa27f2b61500c4ece084b72c4548c5e4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa27f2b61500c4ece084b72c4548c5e4">operator^</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:afa27f2b61500c4ece084b72c4548c5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">XOR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:aa257b73c4bdf09933f4860c51fc5b606" id="r_aa257b73c4bdf09933f4860c51fc5b606"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa257b73c4bdf09933f4860c51fc5b606">operator&amp;</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:aa257b73c4bdf09933f4860c51fc5b606"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">AND</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:a0d2edd32d82952a622021f2565e26b43" id="r_a0d2edd32d82952a622021f2565e26b43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2edd32d82952a622021f2565e26b43">operator|</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a0d2edd32d82952a622021f2565e26b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">OR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:aa3ba1c3ff85d4f043062523e13ff0a3a" id="r_aa3ba1c3ff85d4f043062523e13ff0a3a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3ba1c3ff85d4f043062523e13ff0a3a">operator~</a> ()</td></tr>
<tr class="memdesc:aa3ba1c3ff85d4f043062523e13ff0a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this bit-matrix with all the elements flipped.  <br /></td></tr>
<tr id="pub-methods-22" class="groupHeader"><td colspan="2"><div class="groupHeader">Arithmetic Operations</div></td></tr>
<tr class="memitem:a240488c1f92239c9c08a035ac6c8fa14" id="r_a240488c1f92239c9c08a035ac6c8fa14"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240488c1f92239c9c08a035ac6c8fa14">operator+=</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a240488c1f92239c9c08a035ac6c8fa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) addition is the same as <span class="tt">XOR</span>.  <br /></td></tr>
<tr class="memitem:a8b65b78484d7e569e600a800f0a4c01f" id="r_a8b65b78484d7e569e600a800f0a4c01f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b65b78484d7e569e600a800f0a4c01f">operator-=</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a8b65b78484d7e569e600a800f0a4c01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place difference with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) subtraction is the same as <span class="tt">XOR</span>.  <br /></td></tr>
<tr class="memitem:a499e6bd001f20becf85d7ed8ca9ad49f" id="r_a499e6bd001f20becf85d7ed8ca9ad49f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a499e6bd001f20becf85d7ed8ca9ad49f">operator+</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a499e6bd001f20becf85d7ed8ca9ad49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is <span class="tt">*this + rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2).  <br /></td></tr>
<tr class="memitem:a35d231359f0926183365ed30f9e68a72" id="r_a35d231359f0926183365ed30f9e68a72"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35d231359f0926183365ed30f9e68a72">operator-</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a35d231359f0926183365ed30f9e68a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is <span class="tt">*this - rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2).  <br /></td></tr>
<tr id="pub-methods-23" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations</div></td></tr>
<tr class="memitem:ab02edafb0c7a7fdf53b1827beda9ce3b" id="r_ab02edafb0c7a7fdf53b1827beda9ce3b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a> (std::string_view row_sep=&quot;\n&quot;, std::string_view bit_sep=&quot;&quot;, std::string_view row_prefix=&quot;&quot;, std::string_view row_suffix=&quot;&quot;) const</td></tr>
<tr class="memdesc:ab02edafb0c7a7fdf53b1827beda9ce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a configurable binary string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:a8d832fcbbfa34fa2ed4f9e8b99d94365" id="r_a8d832fcbbfa34fa2ed4f9e8b99d94365"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a> () const</td></tr>
<tr class="memdesc:a8d832fcbbfa34fa2ed4f9e8b99d94365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a one-line minimal binary string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:a34327a2dd7ce74ccca06dd7b3c781a73" id="r_a34327a2dd7ce74ccca06dd7b3c781a73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a> () const</td></tr>
<tr class="memdesc:a34327a2dd7ce74ccca06dd7b3c781a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:a0006a960bef6a8e8341f37f53ec3887c" id="r_a0006a960bef6a8e8341f37f53ec3887c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0006a960bef6a8e8341f37f53ec3887c">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:a0006a960bef6a8e8341f37f53ec3887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default pretty string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:adfaceb93472a831e5a0f613eaa54c591" id="r_adfaceb93472a831e5a0f613eaa54c591"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfaceb93472a831e5a0f613eaa54c591">to_hex_string</a> (std::string_view row_sep=&quot;\n&quot;) const</td></tr>
<tr class="memdesc:adfaceb93472a831e5a0f613eaa54c591"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Returns the "hex" string representation of the bit-matrix  <br /></td></tr>
<tr class="memitem:a0fd7a32df8792cfbfe7c0818a00533ce" id="r_a0fd7a32df8792cfbfe7c0818a00533ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd7a32df8792cfbfe7c0818a00533ce">to_compact_hex_string</a> () const</td></tr>
<tr class="memdesc:a0fd7a32df8792cfbfe7c0818a00533ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compact "hex" string representation of the bit-matrix.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Factory Constructors</div></td></tr>
<tr class="memitem:a05f40b195c5affe7a547789cf8b63ca5" id="r_a05f40b195c5affe7a547789cf8b63ca5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05f40b195c5affe7a547789cf8b63ca5">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a05f40b195c5affe7a547789cf8b63ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> zero bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:a380695f57a2038aa28de73e58ef67560" id="r_a380695f57a2038aa28de73e58ef67560"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a380695f57a2038aa28de73e58ef67560">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a380695f57a2038aa28de73e58ef67560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:a7e87c213d75342d864bdddfaaf6b9536" id="r_a7e87c213d75342d864bdddfaaf6b9536"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e87c213d75342d864bdddfaaf6b9536">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a7e87c213d75342d864bdddfaaf6b9536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix with all the elements set to 1.  <br /></td></tr>
<tr class="memitem:a1ddd9148fd69fd076b29a6e70549d49c" id="r_a1ddd9148fd69fd076b29a6e70549d49c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ddd9148fd69fd076b29a6e70549d49c">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a1ddd9148fd69fd076b29a6e70549d49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 1.  <br /></td></tr>
<tr class="memitem:a7a5d1c515877926ea5e2dea020d10af7" id="r_a7a5d1c515877926ea5e2dea020d10af7"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a5d1c515877926ea5e2dea020d10af7">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a7a5d1c515877926ea5e2dea020d10af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix with alternating elements.  <br /></td></tr>
<tr class="memitem:a601abf25e67c315353e6cfe7b9d68d6f" id="r_a601abf25e67c315353e6cfe7b9d68d6f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601abf25e67c315353e6cfe7b9d68d6f">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a601abf25e67c315353e6cfe7b9d68d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with alternating elements.  <br /></td></tr>
<tr class="memitem:ada40ac9ff6ebf038d58167d35a249b32" id="r_ada40ac9ff6ebf038d58167d35a249b32"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:ada40ac9ff6ebf038d58167d35a249b32 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada40ac9ff6ebf038d58167d35a249b32">from_outer_product</a> (Lhs const &amp;u, Rhs const &amp;v)</td></tr>
<tr class="memdesc:ada40ac9ff6ebf038d58167d35a249b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer product of the given bit-stores.  <br /></td></tr>
<tr class="memitem:adb7b6f55739ba13c13defba37326a058" id="r_adb7b6f55739ba13c13defba37326a058"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:adb7b6f55739ba13c13defba37326a058 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb7b6f55739ba13c13defba37326a058">from_outer_sum</a> (Lhs const &amp;u, Rhs const &amp;v)</td></tr>
<tr class="memdesc:adb7b6f55739ba13c13defba37326a058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer sum of the given bit-stores.  <br /></td></tr>
<tr class="memitem:a16df3af60009477f12efdbe5276fb7b0" id="r_a16df3af60009477f12efdbe5276fb7b0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16df3af60009477f12efdbe5276fb7b0">from</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a16df3af60009477f12efdbe5276fb7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct an \(m \times n\) bit-matrix by repeatedly calling <span class="tt">f(i, j)</span> for each index pair.  <br /></td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Randomly Populated Constructors</div></td></tr>
<tr class="memitem:ab960f06474a7dcce924632e50dcc376b" id="r_ab960f06474a7dcce924632e50dcc376b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab960f06474a7dcce924632e50dcc376b">random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, double p=0.5, std::uint64_t seed=0)</td></tr>
<tr class="memdesc:ab960f06474a7dcce924632e50dcc376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are picked at random.  <br /></td></tr>
<tr class="memitem:a51f86dab5b50d17604364334d97c96f8" id="r_a51f86dab5b50d17604364334d97c96f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f86dab5b50d17604364334d97c96f8">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, std::uint64_t seed)</td></tr>
<tr class="memdesc:a51f86dab5b50d17604364334d97c96f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a03ad4d2b19e2d92f71a04b64f0191466" id="r_a03ad4d2b19e2d92f71a04b64f0191466"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ad4d2b19e2d92f71a04b64f0191466">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, std::uint64_t seed)</td></tr>
<tr class="memdesc:a03ad4d2b19e2d92f71a04b64f0191466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a486f9340638761de0b6b0852901fc42d" id="r_a486f9340638761de0b6b0852901fc42d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a486f9340638761de0b6b0852901fc42d">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, double p)</td></tr>
<tr class="memdesc:a486f9340638761de0b6b0852901fc42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:a8b6222f161b8407d2a0840df328b7b90" id="r_a8b6222f161b8407d2a0840df328b7b90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6222f161b8407d2a0840df328b7b90">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, double p)</td></tr>
<tr class="memdesc:a8b6222f161b8407d2a0840df328b7b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr id="pub-static-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors for Special Matrices</div></td></tr>
<tr class="memitem:a46b8ab9c9a59a35ef0dce40b2275bcde" id="r_a46b8ab9c9a59a35ef0dce40b2275bcde"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">zero</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a46b8ab9c9a59a35ef0dce40b2275bcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square "zero" bit-matrix.  <br /></td></tr>
<tr class="memitem:a6bf2df8fe783b5b05f354e2c1db07310" id="r_a6bf2df8fe783b5b05f354e2c1db07310"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf2df8fe783b5b05f354e2c1db07310">identity</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a6bf2df8fe783b5b05f354e2c1db07310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> identity bit-matrix.  <br /></td></tr>
<tr class="memitem:ac57654e55c43ab661fae9349e94ee356" id="r_ac57654e55c43ab661fae9349e94ee356"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:ac57654e55c43ab661fae9349e94ee356 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57654e55c43ab661fae9349e94ee356">companion</a> (Store const &amp;top_row)</td></tr>
<tr class="memdesc:ac57654e55c43ab661fae9349e94ee356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a square <em>companion <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a></em> with a copy of the given top row and a sub-diagonal of <span class="tt">1</span>s.  <br /></td></tr>
<tr class="memitem:aed4d39ae9e13c543a00819c38c433307" id="r_aed4d39ae9e13c543a00819c38c433307"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4d39ae9e13c543a00819c38c433307">left_shift</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:aed4d39ae9e13c543a00819c38c433307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> shift-left by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>.  <br /></td></tr>
<tr class="memitem:acc3f3a6a8e661b050f64ecf4caca4f66" id="r_acc3f3a6a8e661b050f64ecf4caca4f66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3f3a6a8e661b050f64ecf4caca4f66">right_shift</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:acc3f3a6a8e661b050f64ecf4caca4f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> shift-right by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>.  <br /></td></tr>
<tr class="memitem:ab0adf92ca051399749f63c431f40e419" id="r_ab0adf92ca051399749f63c431f40e419"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0adf92ca051399749f63c431f40e419">left_rotation</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:ab0adf92ca051399749f63c431f40e419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> rotate-left by <span class="tt">p</span> places matrix.  <br /></td></tr>
<tr class="memitem:a2ad1f5eed64497f9e7f3121d4e971454" id="r_a2ad1f5eed64497f9e7f3121d4e971454"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad1f5eed64497f9e7f3121d4e971454">right_rotation</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:a2ad1f5eed64497f9e7f3121d4e971454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> rotate-right by <span class="tt">p</span> places matrix.  <br /></td></tr>
<tr id="pub-static-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction by reshaping bit-stores.</div></td></tr>
<tr class="memitem:a8000a926b02a2c9b8b949207b3f3cbc8" id="r_a8000a926b02a2c9b8b949207b3f3cbc8"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:a8000a926b02a2c9b8b949207b3f3cbc8 template"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8000a926b02a2c9b8b949207b3f3cbc8">from_row_store</a> (Store const &amp;v, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:a8000a926b02a2c9b8b949207b3f3cbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to reshape a bit-vector <span class="tt">v</span> that is assumed to a sequence of <span class="tt">r</span> rows into a bit-matrix.  <br /></td></tr>
<tr class="memitem:ace8fc5a7d26f5044e0268d42b81355a7" id="r_ace8fc5a7d26f5044e0268d42b81355a7"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:ace8fc5a7d26f5044e0268d42b81355a7 template"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8fc5a7d26f5044e0268d42b81355a7">from_col_store</a> (Store const &amp;v, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:ace8fc5a7d26f5044e0268d42b81355a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to reshape a bit-vector that is assumed to a sequence of <span class="tt">c</span> columns into a bit-matrix.  <br /></td></tr>
<tr id="pub-static-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction from strings</div></td></tr>
<tr class="memitem:aab6669fb2fb9d0a804698dc362c1363e" id="r_aab6669fb2fb9d0a804698dc362c1363e"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab6669fb2fb9d0a804698dc362c1363e">from_string</a> (std::string_view s)</td></tr>
<tr class="memdesc:aab6669fb2fb9d0a804698dc362c1363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Inversion</h2></td></tr>
<tr class="memitem:a8d342ec3ed3f4ea5e10a1d9fe7c357e5" id="r_a8d342ec3ed3f4ea5e10a1d9fe7c357e5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d342ec3ed3f4ea5e10a1d9fe7c357e5">inverse</a> () const</td></tr>
<tr class="memdesc:a8d342ec3ed3f4ea5e10a1d9fe7c357e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of a square bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular.  <br /></td></tr>
<tr class="memitem:a3b8ba1da0230bc82dd2974ac751d9a5e" id="r_a3b8ba1da0230bc82dd2974ac751d9a5e"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8ba1da0230bc82dd2974ac751d9a5e">probability_invertible</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a3b8ba1da0230bc82dd2974ac751d9a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is invertible if each element is chosen independently and uniformly at random by flips of a fair coin.  <br /></td></tr>
<tr class="memitem:a46525f36b95df8b4ee03facecdf32e99" id="r_a46525f36b95df8b4ee03facecdf32e99"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46525f36b95df8b4ee03facecdf32e99">probability_singular</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a46525f36b95df8b4ee03facecdf32e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is singular if each element is chosen independently and uniformly at random by flips of a fair coin.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Characteristic Polynomial</h2></td></tr>
<tr class="memitem:add7201e09f15ebdd0824673f0c12d4fb" id="r_add7201e09f15ebdd0824673f0c12d4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add7201e09f15ebdd0824673f0c12d4fb">characteristic_polynomial</a> () const</td></tr>
<tr class="memdesc:add7201e09f15ebdd0824673f0c12d4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the characteristic polynomial of any square bit-matrix as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>.  <br /></td></tr>
<tr class="memitem:a43387a3b493d108a6dab6e1580081f13" id="r_a43387a3b493d108a6dab6e1580081f13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43387a3b493d108a6dab6e1580081f13">frobenius_form</a> () const</td></tr>
<tr class="memdesc:a43387a3b493d108a6dab6e1580081f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>Frobenius form</em> of this bit-matrix in compact top-row only form.  <br /></td></tr>
<tr class="memitem:a5301e96deca6270fc9fa8f0585ba40e9" id="r_a5301e96deca6270fc9fa8f0585ba40e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5301e96deca6270fc9fa8f0585ba40e9">frobenius_matrix_characteristic_polynomial</a> (std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; const &amp;top_rows)</td></tr>
<tr class="memdesc:a5301e96deca6270fc9fa8f0585ba40e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the characteristic polynomial of a <em>Frobenius matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>.  <br /></td></tr>
<tr class="memitem:a45034fa15ea70251c8654b8405ba4dbf" id="r_a45034fa15ea70251c8654b8405ba4dbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45034fa15ea70251c8654b8405ba4dbf">companion_matrix_characteristic_polynomial</a> (<a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; const &amp;top_row)</td></tr>
<tr class="memdesc:a45034fa15ea70251c8654b8405ba4dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method to return the characteristic polynomial of a <em>companion matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Comparison Operator</h2></td></tr>
<tr class="memitem:a29b24e1c82eae445aac3e0a11dccd446" id="r_a29b24e1c82eae445aac3e0a11dccd446"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29b24e1c82eae445aac3e0a11dccd446">operator==</a> (<a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> const &amp;lhs, <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a29b24e1c82eae445aac3e0a11dccd446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator checks that any pair of bit-matrices are equal in content.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word = usize&gt;<br />
class gf2::BitMat&lt; Word &gt;</div><p>A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the matrix. The row elements are compactly stored in standard vectors of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. </p>
<dl class="section note"><dt>Note</dt><dd>These matrices are stored by row, so it is always more efficient to arrange computations to operate on rows instead of columns. The high-level methods in this library take care of this for you. </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae88d67d1d6526d751964b519979f4001" name="ae88d67d1d6526d751964b519979f4001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88d67d1d6526d751964b519979f4001">&#9670;&#160;</a></span>BitMat() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::BitMat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor creates an empty bit-matrix with no rows or columns. </p>
<h1 class="doxsection"><a class="anchor" id="example-90"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a8d832fcbbfa34fa2ed4f9e8b99d94365"><div class="ttname"><a href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">gf2::BitMat::to_compact_binary_string</a></div><div class="ttdeci">std::string to_compact_binary_string() const</div><div class="ttdoc">Returns a one-line minimal binary string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:2289</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ae88d67d1d6526d751964b519979f4001"><div class="ttname"><a href="#ae88d67d1d6526d751964b519979f4001">gf2::BitMat::BitMat</a></div><div class="ttdeci">constexpr BitMat()</div><div class="ttdoc">The default constructor creates an empty bit-matrix with no rows or columns.</div><div class="ttdef"><b>Definition</b> BitMat.h:54</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ababf780896aab3cbfe7f99ceb8ccaa8f" name="ababf780896aab3cbfe7f99ceb8ccaa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababf780896aab3cbfe7f99ceb8ccaa8f">&#9670;&#160;</a></span>BitMat() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::BitMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> square bit-matrix with all the elements set to 0. </p>
<p>If <span class="tt">n</span> is zero, we create an empty bit-matrix with no rows or columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-91"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m{3};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab62ab2830d46def8b471b78c914c25ea" name="ab62ab2830d46def8b471b78c914c25ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62ab2830d46def8b471b78c914c25ea">&#9670;&#160;</a></span>BitMat() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::BitMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">m x n</span> bit-matrix with all the elements set to 0. </p>
<p>If either <span class="tt">m</span> or <span class="tt">n</span> is zero, we create an empty bit-matrix with no rows or columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-92"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m{3, 4};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a>(), <span class="stringliteral">&quot;0000 0000 0000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a49d594838ff085d343313e536735e4a3" name="a49d594838ff085d343313e536735e4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d594838ff085d343313e536735e4a3">&#9670;&#160;</a></span>BitMat() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::BitMat </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; row_type &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit-matrix by <em>copying</em> a given set of rows which can be any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> subclass. </p>
<dl class="section note"><dt>Note</dt><dd>We check that all the rows have the same size unless <span class="tt">NDEBUG</span> is defined.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-93"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a> = std::vector{<a class="code hl_function" href="classgf2_1_1BitVec.html#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;&gt;::zeros</a>(3), <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3)};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitMat.html">BitMat</a> m{<a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html"><div class="ttname"><a href="classgf2_1_1BitMat.html">gf2::BitMat</a></div><div class="ttdoc">A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...</div><div class="ttdef"><b>Definition</b> BitMat.h:32</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a87fe993bc8a0d39b5ef2cf560b6a67e0"><div class="ttname"><a href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">gf2::BitMat::rows</a></div><div class="ttdeci">constexpr usize rows() const</div><div class="ttdoc">Returns the number of rows in the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:626</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a9cbdc533df0b2efeca27daaee792b081"><div class="ttname"><a href="classgf2_1_1BitVec.html#a9cbdc533df0b2efeca27daaee792b081">gf2::BitVec::zeros</a></div><div class="ttdeci">static constexpr BitVec zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVec.h:194</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_abe88a62254e18559eaa3a5bdc8eec2c7"><div class="ttname"><a href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">gf2::BitVec::ones</a></div><div class="ttdeci">static constexpr BitVec ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVec.h:202</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e338445333cc47845318db556ca61d9" name="a4e338445333cc47845318db556ca61d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e338445333cc47845318db556ca61d9">&#9670;&#160;</a></span>BitMat() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::BitMat </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit-matrix by <em>moving</em> the given rows. </p>
<p>Use <span class="tt">std::move(rows)</span> in the constructor argument to get this version. The input rows are moved into the bit-matrix so they are no longer valid after this constructor.</p>
<dl class="section note"><dt>Note</dt><dd>We check that all the rows have the same size unless <span class="tt">NDEBUG</span> is defined.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-94"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a> = std::vector{<a class="code hl_function" href="classgf2_1_1BitVec.html#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;&gt;::zeros</a>(3), <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3)};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitMat.html">BitMat</a> m{std::move(<a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>)};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a7b14b90a3d53cdc56cae3aa00f9861c2" name="a7b14b90a3d53cdc56cae3aa00f9861c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b14b90a3d53cdc56cae3aa00f9861c2">&#9670;&#160;</a></span>add_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::add_identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the identity bit-matrix to the bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this panics if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-170"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.add_identity();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a46b8ab9c9a59a35ef0dce40b2275bcde"><div class="ttname"><a href="#a46b8ab9c9a59a35ef0dce40b2275bcde">gf2::BitMat::zero</a></div><div class="ttdeci">static constexpr BitMat zero(usize m)</div><div class="ttdoc">Factory method to create the m x m square &quot;zero&quot; bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:371</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f8ef3c907ec4036c862f650bcd71c97" name="a8f8ef3c907ec4036c862f650bcd71c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ef3c907ec4036c862f650bcd71c97">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all elements of the bit-matrix are set. </p>
<p>Empty matrices are considered to have all bits set.</p>
<h1 class="doxsection"><a class="anchor" id="example-128"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.all(), <span class="keyword">false</span>);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.all(), <span class="keyword">true</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.all(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a601abf25e67c315353e6cfe7b9d68d6f" name="a601abf25e67c315353e6cfe7b9d68d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601abf25e67c315353e6cfe7b9d68d6f">&#9670;&#160;</a></span>alternating() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with alternating elements. </p>
<h1 class="doxsection"><a class="anchor" id="example-100"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7a5d1c515877926ea5e2dea020d10af7">BitMat&lt;&gt;::alternating</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;101 010 101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a7a5d1c515877926ea5e2dea020d10af7"><div class="ttname"><a href="#a7a5d1c515877926ea5e2dea020d10af7">gf2::BitMat::alternating</a></div><div class="ttdeci">static constexpr BitMat alternating(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n bit-matrix with alternating elements.</div><div class="ttdef"><b>Definition</b> BitMat.h:163</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a5d1c515877926ea5e2dea020d10af7" name="a7a5d1c515877926ea5e2dea020d10af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5d1c515877926ea5e2dea020d10af7">&#9670;&#160;</a></span>alternating() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix with alternating elements. </p>
<h1 class="doxsection"><a class="anchor" id="example-99"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7a5d1c515877926ea5e2dea020d10af7">BitMat&lt;&gt;::alternating</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;1010 0101 1010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae899d183312149f2b855d7e0a60cee01" name="ae899d183312149f2b855d7e0a60cee01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae899d183312149f2b855d7e0a60cee01">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if any element of the bit-matrix is set. </p>
<p>Empty matrices are considered to have no set bits.</p>
<h1 class="doxsection"><a class="anchor" id="example-127"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.any(), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.any(), <span class="keyword">true</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.any(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2df802cd1d9d0823b77260d08462a08d" name="a2df802cd1d9d0823b77260d08462a08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df802cd1d9d0823b77260d08462a08d">&#9670;&#160;</a></span>append_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_col </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>col</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single column <span class="tt"><a class="el" href="#a7289082679dd8cf05d64203c3a98c4c1" title="Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.">col</a></span> onto the right of the bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|col</span>. </p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The column must have the same number of elements as the bit-matrix has rows.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-155"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a> = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3);</div>
<div class="line">m.append_col(<a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;0001 0001 0001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a7289082679dd8cf05d64203c3a98c4c1"><div class="ttname"><a href="#a7289082679dd8cf05d64203c3a98c4c1">gf2::BitMat::col</a></div><div class="ttdeci">constexpr BitVec&lt; Word &gt; col(usize c) const</div><div class="ttdoc">Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.</div><div class="ttdef"><b>Definition</b> BitMat.h:1003</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aff4bb82509b25dfc364fe8ee9a20049e" name="aff4bb82509b25dfc364fe8ee9a20049e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4bb82509b25dfc364fe8ee9a20049e">&#9670;&#160;</a></span>append_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the columns from the <span class="tt">src</span> bit-matrix onto the right of this bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|src</span>. </p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The source bit-matrix must have the same number of rows as this bit-matrix.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-156"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> src = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 2);</div>
<div class="line">m.append_cols(src);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00011 00011 00011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a7e87c213d75342d864bdddfaaf6b9536"><div class="ttname"><a href="#a7e87c213d75342d864bdddfaaf6b9536">gf2::BitMat::ones</a></div><div class="ttdeci">static constexpr BitMat ones(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n bit-matrix with all the elements set to 1.</div><div class="ttdef"><b>Definition</b> BitMat.h:142</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac068c4b7cd9920cd07e1df4f7941bc7d" name="ac068c4b7cd9920cd07e1df4f7941bc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac068c4b7cd9920cd07e1df4f7941bc7d">&#9670;&#160;</a></span>append_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_row </td>
          <td>(</td>
          <td class="paramtype">Store &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single row onto the end of the bit-matrix by moving it. </p>
<p>Use <span class="tt">std::move(row)</span> in the method argument to guarantee this version. The input row is moved into the matrix and is no longer valid after this call.</p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The row must have the same number of elements as the bit-matrix has columns.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-152"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.append_row(<a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae37ed6cc2376ddc9ca89cdb1dc280499" name="ae37ed6cc2376ddc9ca89cdb1dc280499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37ed6cc2376ddc9ca89cdb1dc280499">&#9670;&#160;</a></span>append_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_row </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single row onto the end of the bit-matrix by copying it. </p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The row must have the same number of elements as the bit-matrix has columns.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-151"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a> = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3);</div>
<div class="line">m.append_row(<a class="code hl_function" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a5ab87bba4f2a0646d6068f44266ec81b"><div class="ttname"><a href="#a5ab87bba4f2a0646d6068f44266ec81b">gf2::BitMat::row</a></div><div class="ttdeci">constexpr const row_type &amp; row(usize r) const</div><div class="ttdoc">Returns a read-only reference to the row at index r.</div><div class="ttdef"><b>Definition</b> BitMat.h:928</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7c38b7a6ef8b806fcce2971b99b2dab2" name="a7c38b7a6ef8b806fcce2971b99b2dab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c38b7a6ef8b806fcce2971b99b2dab2">&#9670;&#160;</a></span>append_rows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by moving them. </p>
<p>Use <span class="tt">std::move(src)</span> in the method argument to guarantee this version. The source bit-matrix is moved into this matrix and is no longer valid after this call.</p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The source bit-matrix must have the same number of columns as this bit-matrix.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-154"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.append_rows(<a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f1f953d761b58b5265d21ef71030396" name="a8f1f953d761b58b5265d21ef71030396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1f953d761b58b5265d21ef71030396">&#9670;&#160;</a></span>append_rows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::append_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by copying them. </p>
<p>Returns a reference to the current object for chaining. </p><dl class="section note"><dt>Note</dt><dd>The source bit-matrix must have the same number of columns as this bit-matrix.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-153"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> src = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line">m.append_rows(src);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b6222f161b8407d2a0840df328b7b90" name="a8b6222f161b8407d2a0840df328b7b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6222f161b8407d2a0840df328b7b90">&#9670;&#160;</a></span>biased_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-108"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a486f9340638761de0b6b0852901fc42d">BitMat&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line">assert_eq(u.size(), 100);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a486f9340638761de0b6b0852901fc42d"><div class="ttname"><a href="#a486f9340638761de0b6b0852901fc42d">gf2::BitMat::biased_random</a></div><div class="ttdeci">static BitMat biased_random(usize m, usize n, double p)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are from independent fair co...</div><div class="ttdef"><b>Definition</b> BitMat.h:345</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a486f9340638761de0b6b0852901fc42d" name="a486f9340638761de0b6b0852901fc42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486f9340638761de0b6b0852901fc42d">&#9670;&#160;</a></span>biased_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-107"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a486f9340638761de0b6b0852901fc42d">BitMat&lt;&gt;::biased_random</a>(10, 7, 0.3);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a486f9340638761de0b6b0852901fc42d">BitMat&lt;&gt;::biased_random</a>(10, 7, 0.3);</div>
<div class="line">assert_eq(u.size(), v.size());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="add7201e09f15ebdd0824673f0c12d4fb" name="add7201e09f15ebdd0824673f0c12d4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7201e09f15ebdd0824673f0c12d4fb">&#9670;&#160;</a></span>characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::characteristic_polynomial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the characteristic polynomial of any square bit-matrix as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>. </p>
<p>The method uses similarity transformations to convert the bit-matrix to <em>Frobenius form</em> which has a readily computable characteristic polynomial. Similarity transformations preserve eigen-structure, and in particular they preserve the characteristic polynomial.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-182"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(2);</div>
<div class="line">assert_eq(m2.characteristic_polynomial().to_string(), <span class="stringliteral">&quot;1 + x^2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m3.characteristic_polynomial().to_string(), <span class="stringliteral">&quot;1 + x + x^2 + x^3&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m100 = <a class="code hl_function" href="#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;&gt;::random</a>(100, 100);</div>
<div class="line"><span class="keyword">auto</span> p = m100.characteristic_polynomial();</div>
<div class="line">assert_eq(p(m100).<a class="code hl_function" href="#a80ab7bdc92c767b229cac62fb7f3141e">is_zero</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a6bf2df8fe783b5b05f354e2c1db07310"><div class="ttname"><a href="#a6bf2df8fe783b5b05f354e2c1db07310">gf2::BitMat::identity</a></div><div class="ttdeci">static constexpr BitMat identity(usize m)</div><div class="ttdoc">Factory method to create the m x m identity bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:380</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a80ab7bdc92c767b229cac62fb7f3141e"><div class="ttname"><a href="#a80ab7bdc92c767b229cac62fb7f3141e">gf2::BitMat::is_zero</a></div><div class="ttdeci">constexpr bool is_zero() const</div><div class="ttdoc">Returns true if this a square zero bit-matrix?</div><div class="ttdef"><b>Definition</b> BitMat.h:665</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ab960f06474a7dcce924632e50dcc376b"><div class="ttname"><a href="#ab960f06474a7dcce924632e50dcc376b">gf2::BitMat::random</a></div><div class="ttdeci">static BitMat random(usize m, usize n, double p=0.5, std::uint64_t seed=0)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitMat.h:261</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8ec6c8b1e48b95e5fe074f95be7b98f0" name="a8ec6c8b1e48b95e5fe074f95be7b98f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec6c8b1e48b95e5fe074f95be7b98f0">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the elements from the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-149"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.rows(), 0);</div>
<div class="line">assert_eq(m.cols(), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7289082679dd8cf05d64203c3a98c4c1" name="a7289082679dd8cf05d64203c3a98c4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7289082679dd8cf05d64203c3a98c4c1">&#9670;&#160;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <b>clone</b> of the elements in column <span class="tt">c</span> from the bit-matrix as an independent bit-vector. </p>
<p>Matrices are stored by rows and there is no cheap reference style access to the <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a> columns!</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-139"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a> = m.col(1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>.to_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>.set(0);</div>
<div class="line"><a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>.set(2);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac57654e55c43ab661fae9349e94ee356" name="ac57654e55c43ab661fae9349e94ee356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57654e55c43ab661fae9349e94ee356">&#9670;&#160;</a></span>companion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::companion </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a square <em>companion <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a></em> with a copy of the given top row and a sub-diagonal of <span class="tt">1</span>s. </p>
<p>The top row should be passed as a bit-store and is copied to the first row of the <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>. The rest of the <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a> is initialized to zero and the sub-diagonal is set to <span class="tt">1</span>s.</p>
<h1 class="doxsection"><a class="anchor" id="example-111"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> top_row = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(5);</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac57654e55c43ab661fae9349e94ee356">BitMat&lt;&gt;::companion</a>(top_row);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11111 10000 01000 00100 00010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ac57654e55c43ab661fae9349e94ee356"><div class="ttname"><a href="#ac57654e55c43ab661fae9349e94ee356">gf2::BitMat::companion</a></div><div class="ttdeci">static constexpr BitMat companion(Store const &amp;top_row)</div><div class="ttdoc">Constructs a square companion BitMat with a copy of the given top row and a sub-diagonal of 1s.</div><div class="ttdef"><b>Definition</b> BitMat.h:399</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a45034fa15ea70251c8654b8405ba4dbf" name="a45034fa15ea70251c8654b8405ba4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45034fa15ea70251c8654b8405ba4dbf">&#9670;&#160;</a></span>companion_matrix_characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::companion_matrix_characteristic_polynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method to return the characteristic polynomial of a <em>companion matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>. </p>
<p>The function expects to be passed the top row of the companion matrix as a bit-vector.</p>
<p>A companion matrix is a square matrix that is all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>The characteristic polynomial of a companion matrix can be computed from its top row.</p>
<h1 class="doxsection"><a class="anchor" id="example-183"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> top_row = <a class="code hl_function" href="classgf2_1_1BitVec.html#ac8baf5a5cf90bb23038a3c97b6a9686c">BitVec&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a45034fa15ea70251c8654b8405ba4dbf">BitMat&lt;&gt;::companion_matrix_characteristic_polynomial</a>(top_row).<a class="code hl_function" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a>(), <span class="stringliteral">&quot;1 + x^2 + x^3&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a34327a2dd7ce74ccca06dd7b3c781a73"><div class="ttname"><a href="#a34327a2dd7ce74ccca06dd7b3c781a73">gf2::BitMat::to_string</a></div><div class="ttdeci">std::string to_string() const</div><div class="ttdoc">Returns the default string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:2300</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a45034fa15ea70251c8654b8405ba4dbf"><div class="ttname"><a href="#a45034fa15ea70251c8654b8405ba4dbf">gf2::BitMat::companion_matrix_characteristic_polynomial</a></div><div class="ttdeci">static BitPoly&lt; Word &gt; companion_matrix_characteristic_polynomial(BitVec&lt; Word &gt; const &amp;top_row)</div><div class="ttdoc">Class method to return the characteristic polynomial of a companion matrix as a gf2::BitPoly.</div><div class="ttdef"><b>Definition</b> BitMat.h:2000</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ac8baf5a5cf90bb23038a3c97b6a9686c"><div class="ttname"><a href="classgf2_1_1BitVec.html#ac8baf5a5cf90bb23038a3c97b6a9686c">gf2::BitVec::from_binary_string</a></div><div class="ttdeci">static std::optional&lt; BitVec &gt; from_binary_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVec.h:445</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a759c68d79bc0106a90336c1bb889b430" name="a759c68d79bc0106a90336c1bb889b430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759c68d79bc0106a90336c1bb889b430">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of one elements in the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-123"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.count_ones(), 0);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.count_ones(), 9);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a22ba781dbadb2943b5987ef65d972903" name="a22ba781dbadb2943b5987ef65d972903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ba781dbadb2943b5987ef65d972903">&#9670;&#160;</a></span>count_ones_on_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::count_ones_on_diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ones on the main diagonal of the bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-125"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.count_ones_on_diagonal(), 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae9afa535b18f184a9dfba210085d550f" name="ae9afa535b18f184a9dfba210085d550f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9afa535b18f184a9dfba210085d550f">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of zero elements in the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-124"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.count_zeros(), 6);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a274ecdffe91e8c6641505c4ee6fe1953" name="a274ecdffe91e8c6641505c4ee6fe1953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ecdffe91e8c6641505c4ee6fe1953">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the bit at row <span class="tt">r</span> and column <span class="tt">c</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-134"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a726888e876c2ca2251c78b791a0370d2" name="a726888e876c2ca2251c78b791a0370d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726888e876c2ca2251c78b791a0370d2">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-141"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4b2c6382c50f0ba2f8a573b26eb8ae5f" name="a4b2c6382c50f0ba2f8a573b26eb8ae5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2c6382c50f0ba2f8a573b26eb8ae5f">&#9670;&#160;</a></span>flip_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::flip_diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the main diagonal of a square bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-143"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip_diagonal();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4eba9d954df9bc073da81bcc615e8008" name="a4eba9d954df9bc073da81bcc615e8008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eba9d954df9bc073da81bcc615e8008">&#9670;&#160;</a></span>flip_sub_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::flip_sub_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the sub-diagonal <span class="tt">d</span> of a square bit-matrix. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first sub-diagonal etc.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-147"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m.flip_sub_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00000 10000 01000 00100 00010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a55a8d19de3575a8886a733fd39fa6465" name="a55a8d19de3575a8886a733fd39fa6465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a8d19de3575a8886a733fd39fa6465">&#9670;&#160;</a></span>flip_super_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::flip_super_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the super-diagonal <span class="tt">d</span> of a square bit-matrix. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first super-diagonal etc.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-145"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m.flip_super_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;01000 00100 00010 00001 00000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a43387a3b493d108a6dab6e1580081f13" name="a43387a3b493d108a6dab6e1580081f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43387a3b493d108a6dab6e1580081f13">&#9670;&#160;</a></span>frobenius_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::frobenius_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>Frobenius form</em> of this bit-matrix in compact top-row only form. </p>
<p>A Frobenius matrix is a square matrix that consists of one or more blocks of <em>companion matrices</em> along the diagonal. The companion matrices are square matrices that are all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>We can convert any bit-matrix to Frobenius form via a sequence of similarity transformations that preserve the eigen-structure of the original matrix.</p>
<p>We return the Frobenius companion matrices in a compact form as a <span class="tt">Vec</span> of their top rows as bit-vectors.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is not square. </dd></dl>

</div>
</div>
<a id="a5301e96deca6270fc9fa8f0585ba40e9" name="a5301e96deca6270fc9fa8f0585ba40e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5301e96deca6270fc9fa8f0585ba40e9">&#9670;&#160;</a></span>frobenius_matrix_characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPoly.html">BitPoly</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::frobenius_matrix_characteristic_polynomial </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the characteristic polynomial of a <em>Frobenius matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html" title="A BitPoly represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vect...">gf2::BitPoly</a></span>. </p>
<p>A Frobenius matrix is a square matrix that consists of blocks of <em>companion matrices</em> along the diagonal. Each companion matrix is a square matrix that is all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>This associated function expects to be passed the top rows of the companion matrices as an array of bit-vectors. The characteristic polynomial of a Frobenius matrix is the product of the characteristic polynomials of its block companion matrices which are readily computed. </p>

</div>
</div>
<a id="a16df3af60009477f12efdbe5276fb7b0" name="a16df3af60009477f12efdbe5276fb7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16df3af60009477f12efdbe5276fb7b0">&#9670;&#160;</a></span>from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct an \(m \times n\) bit-matrix by repeatedly calling <span class="tt">f(i, j)</span> for each index pair. </p>
<h1 class="doxsection"><a class="anchor" id="example-103"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a16df3af60009477f12efdbe5276fb7b0">BitMat&lt;&gt;::from</a>(3, 2, [](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 00 11&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a16df3af60009477f12efdbe5276fb7b0"><div class="ttname"><a href="#a16df3af60009477f12efdbe5276fb7b0">gf2::BitMat::from</a></div><div class="ttdeci">static constexpr BitMat from(usize m, usize n, std::invocable&lt; usize, usize &gt; auto f)</div><div class="ttdoc">Factory method to construct an  bit-matrix by repeatedly calling f(i, j) for each index pair.</div><div class="ttdef"><b>Definition</b> BitMat.h:226</div></div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ace8fc5a7d26f5044e0268d42b81355a7" name="ace8fc5a7d26f5044e0268d42b81355a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8fc5a7d26f5044e0268d42b81355a7">&#9670;&#160;</a></span>from_col_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from_col_store </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to reshape a bit-vector that is assumed to a sequence of <span class="tt">c</span> columns into a bit-matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The bit-vector to reshape. </td></tr>
    <tr><td class="paramname">c</td><td>The number of columns.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-117"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(15);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#ace8fc5a7d26f5044e0268d42b81355a7">BitMat&lt;&gt;::from_col_store</a>(v, 3).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#ace8fc5a7d26f5044e0268d42b81355a7">BitMat&lt;&gt;::from_col_store</a>(v, 5).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;11111 11111 11111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#ace8fc5a7d26f5044e0268d42b81355a7">BitMat&lt;&gt;::from_col_store</a>(v, 15).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;111111111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ace8fc5a7d26f5044e0268d42b81355a7"><div class="ttname"><a href="#ace8fc5a7d26f5044e0268d42b81355a7">gf2::BitMat::from_col_store</a></div><div class="ttdeci">static std::optional&lt; BitMat &gt; from_col_store(Store const &amp;v, usize c)</div><div class="ttdoc">Factory method to reshape a bit-vector that is assumed to a sequence of c columns into a bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:533</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ada40ac9ff6ebf038d58167d35a249b32" name="ada40ac9ff6ebf038d58167d35a249b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada40ac9ff6ebf038d58167d35a249b32">&#9670;&#160;</a></span>from_outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from_outer_product </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer product of the given bit-stores. </p>
<h1 class="doxsection"><a class="anchor" id="example-101"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;110&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ada40ac9ff6ebf038d58167d35a249b32">BitMat&lt;&gt;::from_outer_product</a>(u, v);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;110 000 110&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ada40ac9ff6ebf038d58167d35a249b32"><div class="ttname"><a href="#ada40ac9ff6ebf038d58167d35a249b32">gf2::BitMat::from_outer_product</a></div><div class="ttdeci">static constexpr BitMat from_outer_product(Lhs const &amp;u, Rhs const &amp;v)</div><div class="ttdoc">Factory method to create the m x n bit-matrix from the outer product of the given bit-stores.</div><div class="ttdef"><b>Definition</b> BitMat.h:190</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a19b6684f4fa06d3f003029850da307f1"><div class="ttname"><a href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1">gf2::BitVec::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVec &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVec.h:408</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adb7b6f55739ba13c13defba37326a058" name="adb7b6f55739ba13c13defba37326a058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b6f55739ba13c13defba37326a058">&#9670;&#160;</a></span>from_outer_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from_outer_sum </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer sum of the given bit-stores. </p>
<h1 class="doxsection"><a class="anchor" id="example-102"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;110&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#adb7b6f55739ba13c13defba37326a058">BitMat&lt;&gt;::from_outer_sum</a>(u, v);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;001 110 001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_adb7b6f55739ba13c13defba37326a058"><div class="ttname"><a href="#adb7b6f55739ba13c13defba37326a058">gf2::BitMat::from_outer_sum</a></div><div class="ttdeci">static constexpr BitMat from_outer_sum(Lhs const &amp;u, Rhs const &amp;v)</div><div class="ttdoc">Factory method to create the m x n bit-matrix from the outer sum of the given bit-stores.</div><div class="ttdef"><b>Definition</b> BitMat.h:210</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8000a926b02a2c9b8b949207b3f3cbc8" name="a8000a926b02a2c9b8b949207b3f3cbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8000a926b02a2c9b8b949207b3f3cbc8">&#9670;&#160;</a></span>from_row_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from_row_store </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to reshape a bit-vector <span class="tt">v</span> that is assumed to a sequence of <span class="tt">r</span> rows into a bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-116"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(15);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a8000a926b02a2c9b8b949207b3f3cbc8">BitMat&lt;&gt;::from_row_store</a>(v, 3).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;11111 11111 11111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a8000a926b02a2c9b8b949207b3f3cbc8">BitMat&lt;&gt;::from_row_store</a>(v, 5).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#a8000a926b02a2c9b8b949207b3f3cbc8">BitMat&lt;&gt;::from_row_store</a>(v, 15).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;1 1 1 1 1 1 1 1 1 1 1 1 1 1 1&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a8000a926b02a2c9b8b949207b3f3cbc8"><div class="ttname"><a href="#a8000a926b02a2c9b8b949207b3f3cbc8">gf2::BitMat::from_row_store</a></div><div class="ttdeci">static std::optional&lt; BitMat &gt; from_row_store(Store const &amp;v, usize r)</div><div class="ttdoc">Factory method to reshape a bit-vector v that is assumed to a sequence of r rows into a bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:496</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aab6669fb2fb9d0a804698dc362c1363e" name="aab6669fb2fb9d0a804698dc362c1363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6669fb2fb9d0a804698dc362c1363e">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::from_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows. </p>
<p>The rows can be separated by newlines, white space, commas, single quotes, or semicolons. Each row should be a binary or hex string representation of a bit-vector. The rows can have an optional prefix of "0b", "0x" or "0X" to indicate that the string is binary or hex.</p>
<p>A hex string can have a suffix of ".2", ".4", or ".8" to indicate the base of the last digit/character. This allows for rows of any length as opposed to just a multiple of 4.</p>
<p>After parsing, the rows must all have the same length.</p>
<h1 class="doxsection"><a class="anchor" id="example-118"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#aab6669fb2fb9d0a804698dc362c1363e">BitMat&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;111   111\n111&quot;</span>).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#aab6669fb2fb9d0a804698dc362c1363e">BitMat&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0XAA; 0b1111_0000&quot;</span>).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;10101010 11110000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#aab6669fb2fb9d0a804698dc362c1363e">BitMat&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0x7.8 000&quot;</span>).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;111 000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_aab6669fb2fb9d0a804698dc362c1363e"><div class="ttname"><a href="#aab6669fb2fb9d0a804698dc362c1363e">gf2::BitMat::from_string</a></div><div class="ttdeci">static std::optional&lt; BitMat &gt; from_string(std::string_view s)</div><div class="ttdoc">Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows.</div><div class="ttdef"><b>Definition</b> BitMat.h:579</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a20d4b073fa358adea7bdba8fee0c8fc7" name="a20d4b073fa358adea7bdba8fee0c8fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d4b073fa358adea7bdba8fee0c8fc7">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the element at row <span class="tt">r</span> and column <span class="tt">c</span> is set. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-130"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6bf2df8fe783b5b05f354e2c1db07310" name="a6bf2df8fe783b5b05f354e2c1db07310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf2df8fe783b5b05f354e2c1db07310">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> identity bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-110"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8d342ec3ed3f4ea5e10a1d9fe7c357e5" name="a8d342ec3ed3f4ea5e10a1d9fe7c357e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d342ec3ed3f4ea5e10a1d9fe7c357e5">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of a square bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular. </p>
<h1 class="doxsection"><a class="anchor" id="example-176"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.inverse().value().to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a47dfb8e771473880ba37987998b8afd6" name="a47dfb8e771473880ba37987998b8afd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dfb8e771473880ba37987998b8afd6">&#9670;&#160;</a></span>is_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::is_identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this is the identity bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-121"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.is_identity(), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1866dc22def29600967442d125eed667" name="a1866dc22def29600967442d125eed667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1866dc22def29600967442d125eed667">&#9670;&#160;</a></span>is_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::is_square </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this a square bit-matrix? Note that empty bit-matrices are NOT considered square. </p>
<h1 class="doxsection"><a class="anchor" id="example-119"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a1866dc22def29600967442d125eed667">is_square</a>(), <span class="keyword">false</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(3, 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a1866dc22def29600967442d125eed667">is_square</a>(), <span class="keyword">true</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(3, 4);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a1866dc22def29600967442d125eed667">is_square</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a1866dc22def29600967442d125eed667"><div class="ttname"><a href="#a1866dc22def29600967442d125eed667">gf2::BitMat::is_square</a></div><div class="ttdeci">constexpr bool is_square() const</div><div class="ttdoc">Returns true if this a square bit-matrix? Note that empty bit-matrices are NOT considered square.</div><div class="ttdef"><b>Definition</b> BitMat.h:652</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a70e4088cf3f89e13e827d157266b4033"><div class="ttname"><a href="#a70e4088cf3f89e13e827d157266b4033">gf2::BitMat::resize</a></div><div class="ttdeci">constexpr void resize(usize r, usize c)</div><div class="ttdoc">Resize the bit-matrix to r rows and c columns.</div><div class="ttdef"><b>Definition</b> BitMat.h:1168</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7b823c9c540470e403d9db1a8ca1f16d" name="a7b823c9c540470e403d9db1a8ca1f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b823c9c540470e403d9db1a8ca1f16d">&#9670;&#160;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::is_symmetric </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this is a symmetric square bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-122"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.is_symmetric(), <span class="keyword">true</span>);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.is_symmetric(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a80ab7bdc92c767b229cac62fb7f3141e" name="a80ab7bdc92c767b229cac62fb7f3141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ab7bdc92c767b229cac62fb7f3141e">&#9670;&#160;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::is_zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this a square <em>zero</em> bit-matrix? </p>
<h1 class="doxsection"><a class="anchor" id="example-120"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a80ab7bdc92c767b229cac62fb7f3141e">is_zero</a>(), <span class="keyword">false</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(3, 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a80ab7bdc92c767b229cac62fb7f3141e">is_zero</a>(), <span class="keyword">true</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(3, 4);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a80ab7bdc92c767b229cac62fb7f3141e">is_zero</a>(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab0adf92ca051399749f63c431f40e419" name="ab0adf92ca051399749f63c431f40e419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0adf92ca051399749f63c431f40e419">&#9670;&#160;</a></span>left_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::left_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> rotate-left by <span class="tt">p</span> places matrix. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector rotated right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-114"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab0adf92ca051399749f63c431f40e419">BitMat&lt;&gt;::left_rotation</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#ac8baf5a5cf90bb23038a3c97b6a9686c">BitVec&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;11100&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a7056122762ed4582459e853194bba275">dot</a>(m, v).<a class="code hl_function" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a>(), <span class="stringliteral">&quot;00111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ab0adf92ca051399749f63c431f40e419"><div class="ttname"><a href="#ab0adf92ca051399749f63c431f40e419">gf2::BitMat::left_rotation</a></div><div class="ttdeci">static BitMat left_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-left by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:450</div></div>
<div class="ttc" id="anamespacegf2_html_a7056122762ed4582459e853194bba275"><div class="ttname"><a href="namespacegf2.html#a7056122762ed4582459e853194bba275">gf2::dot</a></div><div class="ttdeci">constexpr auto dot(BitMat&lt; Word &gt; const &amp;lhs, Rhs const &amp;rhs)</div><div class="ttdoc">Bit-matrix, bit-store multiplication, M * v, returning a new bit-vector.</div><div class="ttdef"><b>Definition</b> BitMat.h:2522</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aed4d39ae9e13c543a00819c38c433307" name="aed4d39ae9e13c543a00819c38c433307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4d39ae9e13c543a00819c38c433307">&#9670;&#160;</a></span>left_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::left_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> shift-left by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector shifted left by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-112"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#aed4d39ae9e13c543a00819c38c433307">BitMat&lt;&gt;::left_shift</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a7056122762ed4582459e853194bba275">dot</a>(m, v).<a class="code hl_function" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a>(), <span class="stringliteral">&quot;11100&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_aed4d39ae9e13c543a00819c38c433307"><div class="ttname"><a href="#aed4d39ae9e13c543a00819c38c433307">gf2::BitMat::left_shift</a></div><div class="ttdeci">static constexpr BitMat left_shift(usize n, usize p)</div><div class="ttdoc">Constructs the n x n shift-left by p places BitMat.</div><div class="ttdef"><b>Definition</b> BitMat.h:418</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af703e868dd9e46d089129df2e81fe371" name="af703e868dd9e46d089129df2e81fe371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af703e868dd9e46d089129df2e81fe371">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the lower triangular part of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-162"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 110 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84e53cded14276bb661c2ed6639c7bdb" name="a84e53cded14276bb661c2ed6639c7bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e53cded14276bb661c2ed6639c7bdb">&#9670;&#160;</a></span>LU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitLU.html">BitLU</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::LU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the LU decomposition of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-179"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> lu = m.LU();</div>
<div class="line">assert_eq(lu.LU().to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6ff34707914ed583f6a7ebde3e2d3f7" name="ab6ff34707914ed583f6a7ebde3e2d3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ff34707914ed583f6a7ebde3e2d3f7">&#9670;&#160;</a></span>make_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::make_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an arbitrary rectangular bit-matrix into a square <span class="tt"><a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a></span>. </p>
<p>Existing elements are preserved. Any added elements are initialized to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-150"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#aab6669fb2fb9d0a804698dc362c1363e">BitMat&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;111 111 111 111&quot;</span>).value();</div>
<div class="line">m.make_square(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae141b42cbf7de80e0e4c870cc9912e94" name="ae141b42cbf7de80e0e4c870cc9912e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae141b42cbf7de80e0e4c870cc9912e94">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no elements of the bit-matrix are set. </p>
<p>Empty matrices are considered to have no set bits.</p>
<h1 class="doxsection"><a class="anchor" id="example-129"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.none(), <span class="keyword">true</span>);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.none(), <span class="keyword">false</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.none(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1ddd9148fd69fd076b29a6e70549d49c" name="a1ddd9148fd69fd076b29a6e70549d49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd9148fd69fd076b29a6e70549d49c">&#9670;&#160;</a></span>ones() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-98"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7e87c213d75342d864bdddfaaf6b9536" name="a7e87c213d75342d864bdddfaaf6b9536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e87c213d75342d864bdddfaaf6b9536">&#9670;&#160;</a></span>ones() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix with all the elements set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-97"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;1111 1111 1111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa257b73c4bdf09933f4860c51fc5b606" name="aa257b73c4bdf09933f4860c51fc5b606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa257b73c4bdf09933f4860c51fc5b606">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">AND</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-188"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs &amp; rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad01c6bc4178dd73359742fb47c334836" name="ad01c6bc4178dd73359742fb47c334836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01c6bc4178dd73359742fb47c334836">&#9670;&#160;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">AND</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-185"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs &amp;= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aabe08eabd2076e61c9fbe19104f8c96a" name="aabe08eabd2076e61c9fbe19104f8c96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe08eabd2076e61c9fbe19104f8c96a">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitRef.html">BitRef</a>&lt; row_type &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference which can be used to set the bit. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-133"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m(0,0), <span class="keyword">false</span>);</div>
<div class="line">m(0,0) = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(m(0,0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7b6a6cf8e2b0eed3584e8830c4ce546b" name="a7b6a6cf8e2b0eed3584e8830c4ce546b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6a6cf8e2b0eed3584e8830c4ce546b">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt">bool</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-131"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m(0, 0), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a499e6bd001f20becf85d7ed8ca9ad49f" name="a499e6bd001f20becf85d7ed8ca9ad49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499e6bd001f20becf85d7ed8ca9ad49f">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is <span class="tt">*this + rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2). </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-193"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs - rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a240488c1f92239c9c08a035ac6c8fa14" name="a240488c1f92239c9c08a035ac6c8fa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240488c1f92239c9c08a035ac6c8fa14">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) addition is the same as <span class="tt">XOR</span>. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions of do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-191"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs += rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a35d231359f0926183365ed30f9e68a72" name="a35d231359f0926183365ed30f9e68a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d231359f0926183365ed30f9e68a72">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is <span class="tt">*this - rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2). </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions so not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-194"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs + rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b65b78484d7e569e600a800f0a4c01f" name="a8b65b78484d7e569e600a800f0a4c01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b65b78484d7e569e600a800f0a4c01f">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place difference with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) subtraction is the same as <span class="tt">XOR</span>. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-192"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs -= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abb467d738570f4da88a4e9de219e7edd" name="abb467d738570f4da88a4e9de219e7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb467d738570f4da88a4e9de219e7edd">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_type &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the row at index <span class="tt">r</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-138"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m[0].set(1);</div>
<div class="line">assert_eq(m[0].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;110&quot;</span>);</div>
<div class="line">assert_eq(m[1].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m[2].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ab02edafb0c7a7fdf53b1827beda9ce3b"><div class="ttname"><a href="#ab02edafb0c7a7fdf53b1827beda9ce3b">gf2::BitMat::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view row_sep=&quot;\n&quot;, std::string_view bit_sep=&quot;&quot;, std::string_view row_prefix=&quot;&quot;, std::string_view row_suffix=&quot;&quot;) const</div><div class="ttdoc">Returns a configurable binary string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:2261</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6af885c95cc27a028ffb4a5782db3719" name="a6af885c95cc27a028ffb4a5782db3719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af885c95cc27a028ffb4a5782db3719">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const row_type &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the row at index <span class="tt">r</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-137"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m[0].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">assert_eq(m[1].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m[2].<a class="code hl_function" href="#ab02edafb0c7a7fdf53b1827beda9ce3b">to_binary_string</a>(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa27f2b61500c4ece084b72c4548c5e4" name="afa27f2b61500c4ece084b72c4548c5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27f2b61500c4ece084b72c4548c5e4">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">XOR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-187"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs ^ rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aac0b998639028daff95ec0ed6eb44fd7" name="aac0b998639028daff95ec0ed6eb44fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0b998639028daff95ec0ed6eb44fd7">&#9670;&#160;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">XOR</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-184"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs ^= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0d2edd32d82952a622021f2565e26b43" name="a0d2edd32d82952a622021f2565e26b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2edd32d82952a622021f2565e26b43">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">OR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-189"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs | rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a624a562c12012acf68453cecb132ccb3" name="a624a562c12012acf68453cecb132ccb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624a562c12012acf68453cecb132ccb3">&#9670;&#160;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">OR</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<dl class="section note"><dt>Note</dt><dd>This methods panics if the dimensions do not match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-186"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs |= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa3ba1c3ff85d4f043062523e13ff0a3a" name="aa3ba1c3ff85d4f043062523e13ff0a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ba1c3ff85d4f043062523e13ff0a3a">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of this bit-matrix with all the elements flipped. </p>
<h1 class="doxsection"><a class="anchor" id="example-190"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> result = ~m;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;011 101 110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3b8ba1da0230bc82dd2974ac751d9a5e" name="a3b8ba1da0230bc82dd2974ac751d9a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8ba1da0230bc82dd2974ac751d9a5e">&#9670;&#160;</a></span>probability_invertible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::probability_invertible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is invertible if each element is chosen independently and uniformly at random by flips of a fair coin. </p>
<p>For large <span class="tt">n</span>, the value is roughly 29% and that holds for n as low as 10.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if <span class="tt">n</span> is 0 &ndash; based on the assumption that querying the probability of a 0 x 0 bit-matrix being invertible is an upstream error somewhere.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-177"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#a3b8ba1da0230bc82dd2974ac751d9a5e">BitMat&lt;&gt;::probability_invertible</a>(10);</div>
<div class="line">assert(abs(p - 0.289) &lt; 1e-3);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a3b8ba1da0230bc82dd2974ac751d9a5e"><div class="ttname"><a href="#a3b8ba1da0230bc82dd2974ac751d9a5e">gf2::BitMat::probability_invertible</a></div><div class="ttdeci">static constexpr double probability_invertible(usize n)</div><div class="ttdoc">Class method that returns the probability that a square n x n bit-matrix is invertible if each elemen...</div><div class="ttdef"><b>Definition</b> BitMat.h:1856</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a46525f36b95df8b4ee03facecdf32e99" name="a46525f36b95df8b4ee03facecdf32e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46525f36b95df8b4ee03facecdf32e99">&#9670;&#160;</a></span>probability_singular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::probability_singular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is singular if each element is chosen independently and uniformly at random by flips of a fair coin. </p>
<p>For large <span class="tt">n</span>, the value is 71% and that holds for n as low as 10.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if <span class="tt">n</span> is 0 &ndash; based on the assumption that querying the probability of a 0 x 0 bit-matrix being invertible is an upstream error somewhere.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-178"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#a46525f36b95df8b4ee03facecdf32e99">BitMat&lt;&gt;::probability_singular</a>(10);</div>
<div class="line">assert(abs(p - 0.711) &lt; 1e-3);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a46525f36b95df8b4ee03facecdf32e99"><div class="ttname"><a href="#a46525f36b95df8b4ee03facecdf32e99">gf2::BitMat::probability_singular</a></div><div class="ttdeci">static constexpr double probability_singular(usize n)</div><div class="ttdoc">Class method that returns the probability that a square n x n bit-matrix is singular if each element ...</div><div class="ttdef"><b>Definition</b> BitMat.h:1886</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab960f06474a7dcce924632e50dcc376b" name="ab960f06474a7dcce924632e50dcc376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab960f06474a7dcce924632e50dcc376b">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are picked at random. </p>
<p>This is the workhorse method for generating random bit-matrices that allows one to specify the probability of each bit being 1, and also a seed for the random number generator for reproducibility. If you set the seed to 0 then computer entropy is used to seed the RNG.</p>
<p>The default call <span class="tt"><a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>&lt;&gt;::random(m, n)</span> produces a random bit-matrix with each bit being 1 with probability 0.5 and where the RNG is seeded from entropy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-104"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;&gt;::random</a>(3, 2, 0.5, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;&gt;::random</a>(3, 2, 0.5, seed);</div>
<div class="line">assert(u == v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abbe7a6152e2e67e44c51d3d4cc6897b1" name="abbe7a6152e2e67e44c51d3d4cc6897b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe7a6152e2e67e44c51d3d4cc6897b1">&#9670;&#160;</a></span>remove_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::remove_col </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a column off the right of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-159"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a> = m.remove_col();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a7289082679dd8cf05d64203c3a98c4c1">col</a>-&gt;to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 11 11&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a759c2f35c863f577b4e70fe0fde715ca" name="a759c2f35c863f577b4e70fe0fde715ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759c2f35c863f577b4e70fe0fde715ca">&#9670;&#160;</a></span>remove_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::remove_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a row off the end of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-157"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a> = m.remove_row();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a5ab87bba4f2a0646d6068f44266ec81b">row</a>-&gt;to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af59fc626168269636a1e68d7e08dd5e0" name="af59fc626168269636a1e68d7e08dd5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59fc626168269636a1e68d7e08dd5e0">&#9670;&#160;</a></span>remove_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::remove_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <span class="tt">k</span> rows off the end of the bit-matrix and returns them as a new bit-matrix or <span class="tt">std::nullopt</span> if the bit-matrix has fewer than <span class="tt">k</span> rows. </p>
<h1 class="doxsection"><a class="anchor" id="example-158"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> popped = m.remove_rows(2);</div>
<div class="line">assert_eq(popped-&gt;to_compact_binary_string(), <span class="stringliteral">&quot;111 111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa8862fec79e74a2ddfb70e0fca589658" name="aa8862fec79e74a2ddfb70e0fca589658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8862fec79e74a2ddfb70e0fca589658">&#9670;&#160;</a></span>replace_sub_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::replace_sub_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>top</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the sub-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span> with a copy of the sub-matrix <span class="tt">src</span>. </p>
<dl class="section note"><dt>Note</dt><dd>Panics if <span class="tt">src</span> does not fit within this bit-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span>.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-161"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(5);</div>
<div class="line">m.replace_sub_matrix(1, 1, <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;10000 01110 01110 01110 00001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70e4088cf3f89e13e827d157266b4033" name="a70e4088cf3f89e13e827d157266b4033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e4088cf3f89e13e827d157266b4033">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the bit-matrix to <span class="tt">r</span> rows and <span class="tt">c</span> columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The new number of rows &ndash; if r &lt; <a class="el" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0" title="Returns the number of rows in the bit-matrix.">rows()</a> then we lose the excess rows. </td></tr>
    <tr><td class="paramname">c</td><td>The new number of columns &ndash; if c &lt; <a class="el" href="#a52b02d91b49c16245b6279daf7e9c1fe" title="Returns the number of columns in the bit-matrix.">cols()</a> then we lose the excess columns.</td></tr>
  </table>
  </dd>
</dl>
<p>Any added elements are set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="example-148"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m;</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(10, 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>(), 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a52b02d91b49c16245b6279daf7e9c1fe">cols</a>(), 10);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(3, 7);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>(), 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a52b02d91b49c16245b6279daf7e9c1fe">cols</a>(), 7);</div>
<div class="line">m.<a class="code hl_function" href="#a70e4088cf3f89e13e827d157266b4033">resize</a>(0, 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a87fe993bc8a0d39b5ef2cf560b6a67e0">rows</a>(), 0);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a52b02d91b49c16245b6279daf7e9c1fe">cols</a>(), 0);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a52b02d91b49c16245b6279daf7e9c1fe"><div class="ttname"><a href="#a52b02d91b49c16245b6279daf7e9c1fe">gf2::BitMat::cols</a></div><div class="ttdeci">constexpr usize cols() const</div><div class="ttdoc">Returns the number of columns in the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:629</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ad1f5eed64497f9e7f3121d4e971454" name="a2ad1f5eed64497f9e7f3121d4e971454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad1f5eed64497f9e7f3121d4e971454">&#9670;&#160;</a></span>right_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::right_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> rotate-right by <span class="tt">p</span> places matrix. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector rotated right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-115"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a2ad1f5eed64497f9e7f3121d4e971454">BitMat&lt;&gt;::right_rotation</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#ac8baf5a5cf90bb23038a3c97b6a9686c">BitVec&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;11100&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a7056122762ed4582459e853194bba275">dot</a>(m, v).<a class="code hl_function" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a>(), <span class="stringliteral">&quot;10011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a2ad1f5eed64497f9e7f3121d4e971454"><div class="ttname"><a href="#a2ad1f5eed64497f9e7f3121d4e971454">gf2::BitMat::right_rotation</a></div><div class="ttdeci">static BitMat right_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-right by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:469</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acc3f3a6a8e661b050f64ecf4caca4f66" name="acc3f3a6a8e661b050f64ecf4caca4f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3f3a6a8e661b050f64ecf4caca4f66">&#9670;&#160;</a></span>right_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::right_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> shift-right by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMat.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMat</a>. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector shifted right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-113"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#acc3f3a6a8e661b050f64ecf4caca4f66">BitMat&lt;&gt;::right_shift</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a7056122762ed4582459e853194bba275">dot</a>(m, v).<a class="code hl_function" href="#a34327a2dd7ce74ccca06dd7b3c781a73">to_string</a>(), <span class="stringliteral">&quot;00111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_acc3f3a6a8e661b050f64ecf4caca4f66"><div class="ttname"><a href="#acc3f3a6a8e661b050f64ecf4caca4f66">gf2::BitMat::right_shift</a></div><div class="ttdeci">static BitMat right_shift(usize n, usize p)</div><div class="ttdoc">Constructs the n x n shift-right by p places BitMat.</div><div class="ttdef"><b>Definition</b> BitMat.h:434</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a24e9d7b9616adbba1eb4e6ebc9f181a5" name="a24e9d7b9616adbba1eb4e6ebc9f181a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e9d7b9616adbba1eb4e6ebc9f181a5">&#9670;&#160;</a></span>row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_type &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the row at index <span class="tt">r</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-136"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m.row(0).set(1);</div>
<div class="line">assert_eq(m.row(0).to_binary_string(), <span class="stringliteral">&quot;110&quot;</span>);</div>
<div class="line">assert_eq(m.row(1).to_binary_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m.row(2).to_binary_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5ab87bba4f2a0646d6068f44266ec81b" name="a5ab87bba4f2a0646d6068f44266ec81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab87bba4f2a0646d6068f44266ec81b">&#9670;&#160;</a></span>row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const row_type &amp; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the row at index <span class="tt">r</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-135"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.row(0).to_binary_string(), <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">assert_eq(m.row(1).to_binary_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m.row(2).to_binary_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a03ad4d2b19e2d92f71a04b64f0191466" name="a03ad4d2b19e2d92f71a04b64f0191466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ad4d2b19e2d92f71a04b64f0191466">&#9670;&#160;</a></span>seeded_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random square bit-matrices, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows &amp; columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-106"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a51f86dab5b50d17604364334d97c96f8">BitMat&lt;&gt;::seeded_random</a>(3, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a51f86dab5b50d17604364334d97c96f8">BitMat&lt;&gt;::seeded_random</a>(3, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a51f86dab5b50d17604364334d97c96f8"><div class="ttname"><a href="#a51f86dab5b50d17604364334d97c96f8">gf2::BitMat::seeded_random</a></div><div class="ttdeci">static BitMat seeded_random(usize m, usize n, std::uint64_t seed)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are from independent fair co...</div><div class="ttdef"><b>Definition</b> BitMat.h:311</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a51f86dab5b50d17604364334d97c96f8" name="a51f86dab5b50d17604364334d97c96f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f86dab5b50d17604364334d97c96f8">&#9670;&#160;</a></span>seeded_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random bit-vectors, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-105"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a51f86dab5b50d17604364334d97c96f8">BitMat&lt;&gt;::seeded_random</a>(3, 2, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a51f86dab5b50d17604364334d97c96f8">BitMat&lt;&gt;::seeded_random</a>(3, 2, seed);</div>
<div class="line">assert(u == v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2e39b9d992f6fe59c23c0f6cbded28d5" name="a2e39b9d992f6fe59c23c0f6cbded28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e39b9d992f6fe59c23c0f6cbded28d5">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit at row <span class="tt">r</span> and column <span class="tt">c</span> to the bool value <span class="tt">val</span>. The default is to set the bit to <span class="tt">true</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-132"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5198a02dbcd29f646fc0d92c1a608f97" name="a5198a02dbcd29f646fc0d92c1a608f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5198a02dbcd29f646fc0d92c1a608f97">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the elements of the bit-matrix to the specified boolean <span class="tt">value</span>. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-140"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac80c7f066605d218565eac56983318d6" name="ac80c7f066605d218565eac56983318d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80c7f066605d218565eac56983318d6">&#9670;&#160;</a></span>set_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::set_diagonal </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the main diagonal of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-142"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set_diagonal();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afc119aab0b19902541667b698156e31d" name="afc119aab0b19902541667b698156e31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc119aab0b19902541667b698156e31d">&#9670;&#160;</a></span>set_sub_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::set_sub_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the elements on sub-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first sub-diagonal etc.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-146"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m.set_sub_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00000 10000 01000 00100 00010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a500b8f1c9f32696358e3741cd3f75d81" name="a500b8f1c9f32696358e3741cd3f75d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b8f1c9f32696358e3741cd3f75d81">&#9670;&#160;</a></span>set_super_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::set_super_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the elements on super-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first super-diagonal etc.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-144"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m.set_super_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;01000 00100 00010 00001 00000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae989c3b9d8eef5067aaa4d5c19ffc44a" name="ae989c3b9d8eef5067aaa4d5c19ffc44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae989c3b9d8eef5067aaa4d5c19ffc44a">&#9670;&#160;</a></span>solver_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::solver_for </td>
          <td>(</td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Gaussian elimination solver for this bit-matrix and the passed r.h.s. vector <span class="tt">b</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-180"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3);</div>
<div class="line"><span class="keyword">auto</span> solver = A.solver_for(b);</div>
<div class="line">assert_eq(solver.rank(), 1);</div>
<div class="line">assert_eq(solver.free_count(), 2);</div>
<div class="line">assert_eq(solver.solution_count(), 4);</div>
<div class="line">assert_eq(solver.is_underdetermined(), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(solver.is_consistent(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0c897f53bba819c34da0528ad242ecbc" name="a0c897f53bba819c34da0528ad242ecbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c897f53bba819c34da0528ad242ecbc">&#9670;&#160;</a></span>strictly_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::strictly_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the strictly lower triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#af703e868dd9e46d089129df2e81fe371" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal reset to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-164"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.strictly_lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;000 100 110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aca3e37cc6d930c3d5d0dd0ff6cf76631" name="aca3e37cc6d930c3d5d0dd0ff6cf76631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3e37cc6d930c3d5d0dd0ff6cf76631">&#9670;&#160;</a></span>strictly_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::strictly_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the strictly upper triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#af703e868dd9e46d089129df2e81fe371" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal reset to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-165"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.strictly_upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;011 001 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a41fadec6e42fd59379f6b0e5a6efda98" name="a41fadec6e42fd59379f6b0e5a6efda98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fadec6e42fd59379f6b0e5a6efda98">&#9670;&#160;</a></span>sub_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::sub_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c_end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the sub-matrix delimited by the given row and column ranges. </p>
<p>The ranges are half open <span class="tt">[r_start, r_end) X [c_start, c_end)</span> where <span class="tt">r</span> is for rows and <span class="tt">c</span> for columns.</p>
<dl class="section note"><dt>Note</dt><dd>Panics if the bit-matrix has incompatible dimensions with the requested sub-matrix.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-160"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(5);</div>
<div class="line"><span class="keyword">auto</span> sub1 = m.sub_matrix(1, 4, 1, 4);</div>
<div class="line">assert_eq(sub1.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sub2 = m.sub_matrix(1, 1, 1, 1);</div>
<div class="line">assert_eq(sub2.to_compact_binary_string(), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b75df0cea860b3fbe9ba65cf1362a74" name="a5b75df0cea860b3fbe9ba65cf1362a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b75df0cea860b3fbe9ba65cf1362a74">&#9670;&#160;</a></span>swap_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::swap_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps columns <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if either of the indices is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-169"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m.swap_cols(0, 1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;010 100 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a64ed6512ab98ea82089f1e828d51cef7" name="a64ed6512ab98ea82089f1e828d51cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ed6512ab98ea82089f1e828d51cef7">&#9670;&#160;</a></span>swap_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::swap_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps rows <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if either of the indices is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-168"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m.swap_rows(0, 1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;010 100 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab02edafb0c7a7fdf53b1827beda9ce3b" name="ab02edafb0c7a7fdf53b1827beda9ce3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02edafb0c7a7fdf53b1827beda9ce3b">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;\n&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>bit_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a configurable binary string representation for this bit-matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_sep</td><td>What we use to separate the rows (defaults to a "\n"). </td></tr>
    <tr><td class="paramname">bit_sep</td><td>What we use to separate the bit elements in the rows (defaults to ""). </td></tr>
    <tr><td class="paramname">row_prefix</td><td>Added to the left of each row (defaults to ""). </td></tr>
    <tr><td class="paramname">row_suffix</td><td>Added to the right of each row (defaults to "").</td></tr>
  </table>
  </dd>
</dl>
<p>The default prints each row as 0's and 1's without any formatting, and separates the rows with newlines.</p>
<h1 class="doxsection"><a class="anchor" id="example-195"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_binary_string(), <span class="stringliteral">&quot;1000\n0100\n0010\n0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8d832fcbbfa34fa2ed4f9e8b99d94365" name="a8d832fcbbfa34fa2ed4f9e8b99d94365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d832fcbbfa34fa2ed4f9e8b99d94365">&#9670;&#160;</a></span>to_compact_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_compact_binary_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a one-line minimal binary string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's without any formatting, and separates the rows with a single space.</p>
<h1 class="doxsection"><a class="anchor" id="example-196"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_compact_binary_string(), <span class="stringliteral">&quot;1000 0100 0010 0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0fd7a32df8792cfbfe7c0818a00533ce" name="a0fd7a32df8792cfbfe7c0818a00533ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd7a32df8792cfbfe7c0818a00533ce">&#9670;&#160;</a></span>to_compact_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_compact_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a compact "hex" string representation of the bit-matrix. </p>
<p>Empty bit-matrices are represented as the empty string.</p>
<p>Each row in a non-empty bit-matrix is a string of hex chars without any spaces, commas, or other formatting. The rows are separated by a single space.</p>
<p>Each row may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-200"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m0;</div>
<div class="line">assert_eq(m0.<a class="code hl_function" href="#a0fd7a32df8792cfbfe7c0818a00533ce">to_compact_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(4);</div>
<div class="line">m1.set_all();</div>
<div class="line">assert_eq(m1.to_compact_hex_string(), <span class="stringliteral">&quot;F F F F&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m2.flip_all();</div>
<div class="line">assert_eq(m2.to_compact_hex_string(), <span class="stringliteral">&quot;F1.2 F1.2 F1.2 F1.2 F1.2&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a0fd7a32df8792cfbfe7c0818a00533ce"><div class="ttname"><a href="#a0fd7a32df8792cfbfe7c0818a00533ce">gf2::BitMat::to_compact_hex_string</a></div><div class="ttdeci">std::string to_compact_hex_string() const</div><div class="ttdoc">Returns a compact &quot;hex&quot; string representation of the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:2389</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7f21e17fa903fe1f2da8cfbe5f6b1f2d" name="a7f21e17fa903fe1f2da8cfbe5f6b1f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f21e17fa903fe1f2da8cfbe5f6b1f2d">&#9670;&#160;</a></span>to_echelon_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_echelon_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an arbitrary shaped, non-empty, bit-matrix to row-echelon form (in-place). </p>
<p>The method returns a bit-vector that shows which columns have a "pivot" (a non-zero on or below the diagonal). The matrix <em>rank</em> is the number of set bits in that pivot bit-vector.</p>
<p>A bit-matrix is in echelon form if the first 1 in any row is to the right of the first 1 in the preceding row. It is a generalization of an upper triangular form &ndash; the result is a matrix with a "staircase" shape.</p>
<p>The transformation is Gaussian elimination. Any all zero rows are moved to the bottom of the matrix. The echelon form is not unique.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is empty.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-174"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m.set(2, 1, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">auto</span> has_pivot = m.to_echelon_form();</div>
<div class="line">assert_eq(has_pivot.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adfaceb93472a831e5a0f613eaa54c591" name="adfaceb93472a831e5a0f613eaa54c591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaceb93472a831e5a0f613eaa54c591">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;\n&quot;</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Returns the "hex" string representation of the bit-matrix </p>
<p>Empty bit-matrices are represented as the empty string.</p>
<p>Each row in a non-empty bit-matrix is a string of hex chars without any spaces, commas, or other formatting. By default, the rows are separated by newlines.</p>
<p>Each row may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-199"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> m0;</div>
<div class="line">assert_eq(m0.<a class="code hl_function" href="#adfaceb93472a831e5a0f613eaa54c591">to_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(4);</div>
<div class="line">m1.set_all();</div>
<div class="line">assert_eq(m1.to_hex_string(), <span class="stringliteral">&quot;F\nF\nF\nF&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(5);</div>
<div class="line">m2.flip_all();</div>
<div class="line">assert_eq(m2.to_hex_string(), <span class="stringliteral">&quot;F1.2\nF1.2\nF1.2\nF1.2\nF1.2&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_adfaceb93472a831e5a0f613eaa54c591"><div class="ttname"><a href="#adfaceb93472a831e5a0f613eaa54c591">gf2::BitMat::to_hex_string</a></div><div class="ttdeci">std::string to_hex_string(std::string_view row_sep=&quot;\n&quot;) const</div><div class="ttdoc">&quot;Returns the &quot;hex&quot; string representation of the bit-matrix</div><div class="ttdef"><b>Definition</b> BitMat.h:2344</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0006a960bef6a8e8341f37f53ec3887c" name="a0006a960bef6a8e8341f37f53ec3887c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006a960bef6a8e8341f37f53ec3887c">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default pretty string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's with a space between each element. The rows are delimited by a light vertical bar on the left and right. The rows are separated by newlines.</p>
<h1 class="doxsection"><a class="anchor" id="example-198"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> bar = <span class="stringliteral">&quot;\u2502&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> expected = std::format(<span class="stringliteral">&quot;{0}1 0 0{0}\n{0}0 1 0{0}\n{0}0 0 1{0}&quot;</span>, bar);</div>
<div class="line">assert_eq(I.to_pretty_string(), expected);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a570344257f8263b952330221702c6a11" name="a570344257f8263b952330221702c6a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570344257f8263b952330221702c6a11">&#9670;&#160;</a></span>to_reduced_echelon_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_reduced_echelon_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the bit-matrix to reduced row-echelon form (in-place). </p>
<p>The method returns a bit-vector that shows which columns have a "pivot" (a non-zero on or below the diagonal). The matrix <em>rank</em> is the number of set bits in that bit-vector.</p>
<p>A bit-matrix is in reduced echelon form if it is in echelon form with at most one 1 in each column. The reduced echelon form is unique.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is empty.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-175"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">m.set(2, 1, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">auto</span> pivots = m.to_reduced_echelon_form();</div>
<div class="line">assert_eq(pivots.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a34327a2dd7ce74ccca06dd7b3c781a73" name="a34327a2dd7ce74ccca06dd7b3c781a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34327a2dd7ce74ccca06dd7b3c781a73">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's without any formatting, and separates the rows with a newline.</p>
<h1 class="doxsection"><a class="anchor" id="example-197"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_string(), <span class="stringliteral">&quot;1000\n0100\n0010\n0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af0e373a9641584346c4c1bad6dbcd183" name="af0e373a9641584346c4c1bad6dbcd183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e373a9641584346c4c1bad6dbcd183">&#9670;&#160;</a></span>to_the()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::to_the </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>n_is_log2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is this one raised to some power <span class="tt">n</span> or <span class="tt">2^n</span>. </p>
<p>We efficiently compute <span class="tt">M^e</span> by using a square and multiply algorithm where by default <span class="tt">e = n</span>. If the second argument <span class="tt">n_is_log2 = true</span> then we consider <span class="tt">e = 2^n</span> instead.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-173"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;&gt;::random</a>(100, 100);</div>
<div class="line"><span class="keyword">auto</span> p1 = m.to_the(3);</div>
<div class="line"><span class="keyword">auto</span> o1 = m * m * m;</div>
<div class="line">assert_eq(p1, o1);</div>
<div class="line"><span class="keyword">auto</span> p2 = m.to_the(2, <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> o2 = m * o1;</div>
<div class="line">assert_eq(p2, o2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02e025abc390a94b8fb9bc9b0de34f2f" name="a02e025abc390a94b8fb9bc9b0de34f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e025abc390a94b8fb9bc9b0de34f2f">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::trace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "sum" of the main diagonal elements of the bit-matrix. </p>
<p>Returns the "sum" of the main diagonal elements of the bit-matrix.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, this method will panic if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-126"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m1.trace(), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(4);</div>
<div class="line">assert_eq(m2.trace(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a04e78961de3d0e90c645843558cc2e4e" name="a04e78961de3d0e90c645843558cc2e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e78961de3d0e90c645843558cc2e4e">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a <em>square</em> bit-matrix in place. </p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix is not square.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-172"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 000 000&quot;</span>);</div>
<div class="line">m.transpose();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 100 100&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa802a4ff75e7618e5d9b793597f744d3" name="aa802a4ff75e7618e5d9b793597f744d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa802a4ff75e7618e5d9b793597f744d3">&#9670;&#160;</a></span>transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::transposed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is the transpose of this one. </p>
<dl class="section note"><dt>Note</dt><dd>This method isn't particularly efficient as it works by iterating over all elements of the bit-matrix.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-171"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a05f40b195c5affe7a547789cf8b63ca5">BitMat&lt;&gt;::zeros</a>(3, 2);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 00 00&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> n = m.transposed();</div>
<div class="line">assert_eq(n.to_compact_binary_string(), <span class="stringliteral">&quot;100 100&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a05f40b195c5affe7a547789cf8b63ca5"><div class="ttname"><a href="#a05f40b195c5affe7a547789cf8b63ca5">gf2::BitMat::zeros</a></div><div class="ttdeci">static constexpr BitMat zeros(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n zero bit-matrix with all the elements set to 0.</div><div class="ttdef"><b>Definition</b> BitMat.h:124</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a50a51b4d0fea918d1fbe4cf500cdf70b" name="a50a51b4d0fea918d1fbe4cf500cdf70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a51b4d0fea918d1fbe4cf500cdf70b">&#9670;&#160;</a></span>unit_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::unit_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the unit lower triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#af703e868dd9e46d089129df2e81fe371" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal set to one.</p>
<h1 class="doxsection"><a class="anchor" id="example-166"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a05f40b195c5affe7a547789cf8b63ca5">BitMat&lt;&gt;::zeros</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.unit_lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab9f46255165a99c13bd4ef61dd50c640" name="ab9f46255165a99c13bd4ef61dd50c640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f46255165a99c13bd4ef61dd50c640">&#9670;&#160;</a></span>unit_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::unit_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the unit upper triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#a11315f46b66ca7c0cb2a9986fb61ef32" title="Returns an independent clone of the upper triangular part of the bit-matrix.">upper()</a></span> but with the diagonal set to one.</p>
<h1 class="doxsection"><a class="anchor" id="example-167"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a05f40b195c5affe7a547789cf8b63ca5">BitMat&lt;&gt;::zeros</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.unit_upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a11315f46b66ca7c0cb2a9986fb61ef32" name="a11315f46b66ca7c0cb2a9986fb61ef32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11315f46b66ca7c0cb2a9986fb61ef32">&#9670;&#160;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the upper triangular part of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-163"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a7e87c213d75342d864bdddfaaf6b9536">BitMat&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;111 011 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6a25d388b498f7079227d80e70e6fbb" name="aa6a25d388b498f7079227d80e70e6fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a25d388b498f7079227d80e70e6fbb">&#9670;&#160;</a></span>x_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::x_for </td>
          <td>(</td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a solution to the system of linear equations <span class="tt">A.x_ = b</span> or <span class="tt">std::nullopt</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-181"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(3);</div>
<div class="line"><span class="keyword">auto</span> x = A.x_for(b).value();</div>
<div class="line">assert_eq(x.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a46b8ab9c9a59a35ef0dce40b2275bcde" name="a46b8ab9c9a59a35ef0dce40b2275bcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b8ab9c9a59a35ef0dce40b2275bcde">&#9670;&#160;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square "zero" bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-109"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a46b8ab9c9a59a35ef0dce40b2275bcde">BitMat&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a380695f57a2038aa28de73e58ef67560" name="a380695f57a2038aa28de73e58ef67560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380695f57a2038aa28de73e58ef67560">&#9670;&#160;</a></span>zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-96"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a05f40b195c5affe7a547789cf8b63ca5">BitMat&lt;&gt;::zeros</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05f40b195c5affe7a547789cf8b63ca5" name="a05f40b195c5affe7a547789cf8b63ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f40b195c5affe7a547789cf8b63ca5">&#9670;&#160;</a></span>zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a> <a class="el" href="classgf2_1_1BitMat.html">gf2::BitMat</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> zero bit-matrix with all the elements set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-95"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a05f40b195c5affe7a547789cf8b63ca5">BitMat&lt;&gt;::zeros</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;0000 0000 0000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a29b24e1c82eae445aac3e0a11dccd446" name="a29b24e1c82eae445aac3e0a11dccd446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b24e1c82eae445aac3e0a11dccd446">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88d67d1d6526d751964b519979f4001">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator checks that any pair of bit-matrices are equal in content. </p>
<h1 class="doxsection"><a class="anchor" id="example-201"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> q = <a class="code hl_function" href="#a6bf2df8fe783b5b05f354e2c1db07310">BitMat&lt;&gt;::identity</a>(3);</div>
<div class="line">assert(p == q);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitMat.html">BitMat</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
