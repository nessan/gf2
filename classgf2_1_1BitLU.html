<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitLU&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitLU.html','','classgf2_1_1BitLU-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitLU&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>The <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> class provides the <span class="tt"><a class="el" href="#a890e8e18141b984e99d1da412ab0554f" title="Read-only access to the LU form of the bit-matrix where A -&gt; [L\U].">LU</a></span> decomposition for bit-matrices.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitLU_8h_source.html">BitLU.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbef40c16cd95e73cca6151f0e5792a0" id="r_acbef40c16cd95e73cca6151f0e5792a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbef40c16cd95e73cca6151f0e5792a0">BitLU</a> (<a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; const &amp;A)</td></tr>
<tr class="memdesc:acbef40c16cd95e73cca6151f0e5792a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the LU decomposition object for a square matrix <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a7e8d5f21a8b7b0d5daedead86523152b" id="r_a7e8d5f21a8b7b0d5daedead86523152b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e8d5f21a8b7b0d5daedead86523152b">rank</a> () const</td></tr>
<tr class="memdesc:a7e8d5f21a8b7b0d5daedead86523152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the matrix.  <br /></td></tr>
<tr class="memitem:aa6eadf85c7d39dac296bc13d481e625b" id="r_aa6eadf85c7d39dac296bc13d481e625b"><td class="memItemLeft" align="right" valign="top"><a id="aa6eadf85c7d39dac296bc13d481e625b" name="aa6eadf85c7d39dac296bc13d481e625b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_singular</b> () const</td></tr>
<tr class="memdesc:aa6eadf85c7d39dac296bc13d481e625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the underlying matrix is singular (i.e. rank deficient). <br /></td></tr>
<tr class="memitem:a604b3e230fc09d6fa1ac3c916bc5110b" id="r_a604b3e230fc09d6fa1ac3c916bc5110b"><td class="memItemLeft" align="right" valign="top"><a id="a604b3e230fc09d6fa1ac3c916bc5110b" name="a604b3e230fc09d6fa1ac3c916bc5110b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>determinant</b> () const</td></tr>
<tr class="memdesc:a604b3e230fc09d6fa1ac3c916bc5110b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the determinant of the underlying matrix as <span class="tt">true</span> or <span class="tt">false</span> for 1 or 0. <br /></td></tr>
<tr class="memitem:a890e8e18141b984e99d1da412ab0554f" id="r_a890e8e18141b984e99d1da412ab0554f"><td class="memItemLeft" align="right" valign="top"><a id="a890e8e18141b984e99d1da412ab0554f" name="a890e8e18141b984e99d1da412ab0554f"></a>
constexpr const <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LU</b> () const</td></tr>
<tr class="memdesc:a890e8e18141b984e99d1da412ab0554f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the LU form of the bit-matrix where A -&gt; [L\U]. <br /></td></tr>
<tr class="memitem:abadbedaef443792b5b62dcec0128d8e9" id="r_abadbedaef443792b5b62dcec0128d8e9"><td class="memItemLeft" align="right" valign="top"><a id="abadbedaef443792b5b62dcec0128d8e9" name="abadbedaef443792b5b62dcec0128d8e9"></a>
constexpr <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>L</b> () const</td></tr>
<tr class="memdesc:abadbedaef443792b5b62dcec0128d8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit lower triangular matrix <span class="tt"><a class="el" href="#abadbedaef443792b5b62dcec0128d8e9" title="Returns the unit lower triangular matrix L in the LU decomposition.">L</a></span> in the LU decomposition. <br /></td></tr>
<tr class="memitem:a8dca16ce7a87211a7a9a0cfc09a627a3" id="r_a8dca16ce7a87211a7a9a0cfc09a627a3"><td class="memItemLeft" align="right" valign="top"><a id="a8dca16ce7a87211a7a9a0cfc09a627a3" name="a8dca16ce7a87211a7a9a0cfc09a627a3"></a>
constexpr <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>U</b> () const</td></tr>
<tr class="memdesc:a8dca16ce7a87211a7a9a0cfc09a627a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper triangular matrix <span class="tt"><a class="el" href="#a8dca16ce7a87211a7a9a0cfc09a627a3" title="Returns the upper triangular matrix U in the LU decomposition.">U</a></span> in the LU decomposition. <br /></td></tr>
<tr class="memitem:a948aa259cb7aa563f0fc0daff914fc5c" id="r_a948aa259cb7aa563f0fc0daff914fc5c"><td class="memItemLeft" align="right" valign="top">constexpr const std::vector&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a948aa259cb7aa563f0fc0daff914fc5c">swaps</a> () const</td></tr>
<tr class="memdesc:a948aa259cb7aa563f0fc0daff914fc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the row swap instructions in <a href="https://en.wikipedia.org/wiki/LAPACK"><span class="tt">LAPACK</span></a> form.  <br /></td></tr>
<tr class="memitem:a63728f5e57f796f304a950f83b42ecd5" id="r_a63728f5e57f796f304a950f83b42ecd5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63728f5e57f796f304a950f83b42ecd5">permutation_vector</a> () const</td></tr>
<tr class="memdesc:a63728f5e57f796f304a950f83b42ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permutation matrix as a vector of showing the index positions of the non-zero entries.  <br /></td></tr>
<tr class="memitem:a36dfccacabf8937863685c6c47e4d875" id="r_a36dfccacabf8937863685c6c47e4d875"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36dfccacabf8937863685c6c47e4d875">permute</a> (<a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &amp;B) const</td></tr>
<tr class="memdesc:a36dfccacabf8937863685c6c47e4d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the rows of the input matrix <span class="tt">B</span> in-place using our row-swap instruction vector.  <br /></td></tr>
<tr class="memitem:a76c6104824f5bdb8eaf2e2e5f06890f8" id="r_a76c6104824f5bdb8eaf2e2e5f06890f8"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires (std::same_as&lt;typename Store::word_type, Word&gt;)</td></tr>
<tr class="memitem:a76c6104824f5bdb8eaf2e2e5f06890f8 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76c6104824f5bdb8eaf2e2e5f06890f8">permute</a> (Store &amp;b) const</td></tr>
<tr class="memdesc:a76c6104824f5bdb8eaf2e2e5f06890f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the rows of the input vector <span class="tt">b</span> in-place using our row-swap instruction vector.  <br /></td></tr>
<tr class="memitem:a9502464ab5ce9b6d7ae38a4127c8a328" id="r_a9502464ab5ce9b6d7ae38a4127c8a328"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires (std::same_as&lt;typename Store::word_type, Word&gt;)</td></tr>
<tr class="memitem:a9502464ab5ce9b6d7ae38a4127c8a328 template"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9502464ab5ce9b6d7ae38a4127c8a328">operator()</a> (Store const &amp;b) const</td></tr>
<tr class="memdesc:a9502464ab5ce9b6d7ae38a4127c8a328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the linear system <span class="tt">A.x_for = b</span> for any <span class="tt">b</span> where <span class="tt">A</span> is the matrix used to construct the <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> object.  <br /></td></tr>
<tr class="memitem:a6ea6e1f38f9f05e3139613219262df31" id="r_a6ea6e1f38f9f05e3139613219262df31"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea6e1f38f9f05e3139613219262df31">operator()</a> (<a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; const &amp;B) const</td></tr>
<tr class="memdesc:a6ea6e1f38f9f05e3139613219262df31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the linear system <span class="tt">A.X_for = B</span> for any <span class="tt">B</span> where <span class="tt">A</span> is the matrix used to construct the <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> object.  <br /></td></tr>
<tr class="memitem:ab0e404d0e7763d230d1f244e397e92f5" id="r_ab0e404d0e7763d230d1f244e397e92f5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e404d0e7763d230d1f244e397e92f5">inverse</a> () const</td></tr>
<tr class="memdesc:ab0e404d0e7763d230d1f244e397e92f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the matrix <span class="tt">A</span> as a full independent bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word&gt;<br />
class gf2::BitLU&lt; Word &gt;</div><p>The <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> class provides the <span class="tt"><a class="el" href="#a890e8e18141b984e99d1da412ab0554f" title="Read-only access to the LU form of the bit-matrix where A -&gt; [L\U].">LU</a></span> decomposition for bit-matrices. </p>
<p>The class also has methods for solving systems of linear equations over GF(2) and for inverting square bit-matrices.</p>
<p>Formally, <em>LU</em> decomposition of <span class="tt">A</span> is \(P \cdot A = L \cdot U\) where \(P\) is a permutation matrix, \(L\) is a unit lower triangular matrix and \(U\) is an upper triangular matrix.</p>
<p>The <span class="tt"><a class="el" href="#abadbedaef443792b5b62dcec0128d8e9" title="Returns the unit lower triangular matrix L in the LU decomposition.">L</a></span> and <span class="tt"><a class="el" href="#a8dca16ce7a87211a7a9a0cfc09a627a3" title="Returns the upper triangular matrix U in the LU decomposition.">U</a></span> triangles can be efficiently packed into a single bit-matrix of the same size as <span class="tt">A</span></p>
<p><span class="tt">P</span> is a permutation of the identity matrix with one non-zero entry per row. In practice, we just need to store the locations of those entries as some form of vector.</p>
<dl class="section note"><dt>Note</dt><dd>There are generalisations of the LU decomposition for non-square matrices but those are not considered yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic">Finite field arithmetic</a> </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbef40c16cd95e73cca6151f0e5792a0" name="acbef40c16cd95e73cca6151f0e5792a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbef40c16cd95e73cca6151f0e5792a0">&#9670;&#160;</a></span>BitLU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::BitLU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the LU decomposition object for a square matrix <span class="tt">A</span>. </p>
<p>On construction, this method computes a unit lower triangular matrix <span class="tt"><a class="el" href="#abadbedaef443792b5b62dcec0128d8e9" title="Returns the unit lower triangular matrix L in the LU decomposition.">L</a></span>, an upper triangular matrix <span class="tt"><a class="el" href="#a8dca16ce7a87211a7a9a0cfc09a627a3" title="Returns the upper triangular matrix U in the LU decomposition.">U</a></span>, and a permutation matrix <span class="tt">P</span> such that <span class="tt">P.A = L.U</span>. The <span class="tt"><a class="el" href="#abadbedaef443792b5b62dcec0128d8e9" title="Returns the unit lower triangular matrix L in the LU decomposition.">L</a></span> and <span class="tt"><a class="el" href="#a8dca16ce7a87211a7a9a0cfc09a627a3" title="Returns the upper triangular matrix U in the LU decomposition.">U</a></span> triangles are efficiently packed into a single matrix and <span class="tt">P</span> is stored as a vector of row swap instructions.</p>
<p>The construction works even if <span class="tt">A</span> is singular, though the solver methods will not.</p>
<p>If <span class="tt">A</span> is <span class="tt">n x n</span>, then the construction takes O(n^3) operations. There are block iterative methods that can reduce that to a sub-cubic count but they are not implemented here. Of course, the method works on whole words or bit elements at a time so is very efficient even without those enhancements.</p>
<dl class="section note"><dt>Note</dt><dd>Panics if the <span class="tt">A</span> matrix is not square. There are generalisations of the LU decomposition for non-square matrices but those are not considered yet.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-checks-that-lu--pa-for-a-random-matrix-a"></a>
Example (checks that <span class="tt">LU = PA</span> for a random matrix <span class="tt">A</span>)</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;u8&gt;::random</a>(100, 100);</div>
<div class="line"><span class="keyword">auto</span> lu = A.LU();</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a890e8e18141b984e99d1da412ab0554f">LU</a> = lu.L() * lu.U();</div>
<div class="line"><span class="keyword">auto</span> PA = A;</div>
<div class="line">lu.permute(PA);</div>
<div class="line">assert_eq(PA, <a class="code hl_function" href="#a890e8e18141b984e99d1da412ab0554f">LU</a>);</div>
<div class="ttc" id="aclassgf2_1_1BitLU_html_a890e8e18141b984e99d1da412ab0554f"><div class="ttname"><a href="#a890e8e18141b984e99d1da412ab0554f">gf2::BitLU::LU</a></div><div class="ttdeci">constexpr const BitMat&lt; Word &gt; &amp; LU() const</div><div class="ttdoc">Read-only access to the LU form of the bit-matrix where A -&gt; [L\U].</div><div class="ttdef"><b>Definition</b> BitLU.h:117</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ab960f06474a7dcce924632e50dcc376b"><div class="ttname"><a href="classgf2_1_1BitMat.html#ab960f06474a7dcce924632e50dcc376b">gf2::BitMat::random</a></div><div class="ttdeci">static BitMat random(usize m, usize n, double p=0.5, std::uint64_t seed=0)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitMat.h:261</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ab0e404d0e7763d230d1f244e397e92f5" name="ab0e404d0e7763d230d1f244e397e92f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e404d0e7763d230d1f244e397e92f5">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the matrix <span class="tt">A</span> as a full independent bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular. </p>
<h1 class="doxsection"><a class="anchor" id="example-88"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab0adf92ca051399749f63c431f40e419">BitMat&lt;&gt;::left_rotation</a>(100, 1);</div>
<div class="line"><a class="code hl_function" href="#acbef40c16cd95e73cca6151f0e5792a0">BitLU</a> lu{A};</div>
<div class="line"><span class="keyword">auto</span> A_inv = lu.<a class="code hl_function" href="#ab0e404d0e7763d230d1f244e397e92f5">inverse</a>().value();</div>
<div class="line">assert_eq(A_inv, <a class="code hl_function" href="classgf2_1_1BitMat.html#a2ad1f5eed64497f9e7f3121d4e971454">BitMat&lt;&gt;::right_rotation</a>(100, 1));</div>
<div class="ttc" id="aclassgf2_1_1BitLU_html_ab0e404d0e7763d230d1f244e397e92f5"><div class="ttname"><a href="#ab0e404d0e7763d230d1f244e397e92f5">gf2::BitLU::inverse</a></div><div class="ttdeci">std::optional&lt; BitMat&lt; Word &gt; &gt; inverse() const</div><div class="ttdoc">Returns the inverse of the matrix A as a full independent bit-matrix or std::nullopt if the matrix is...</div><div class="ttdef"><b>Definition</b> BitLU.h:291</div></div>
<div class="ttc" id="aclassgf2_1_1BitLU_html_acbef40c16cd95e73cca6151f0e5792a0"><div class="ttname"><a href="#acbef40c16cd95e73cca6151f0e5792a0">gf2::BitLU::BitLU</a></div><div class="ttdeci">BitLU(BitMat&lt; Word &gt; const &amp;A)</div><div class="ttdoc">Constructs the LU decomposition object for a square matrix A.</div><div class="ttdef"><b>Definition</b> BitLU.h:60</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_a2ad1f5eed64497f9e7f3121d4e971454"><div class="ttname"><a href="classgf2_1_1BitMat.html#a2ad1f5eed64497f9e7f3121d4e971454">gf2::BitMat::right_rotation</a></div><div class="ttdeci">static BitMat right_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-right by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:469</div></div>
<div class="ttc" id="aclassgf2_1_1BitMat_html_ab0adf92ca051399749f63c431f40e419"><div class="ttname"><a href="classgf2_1_1BitMat.html#ab0adf92ca051399749f63c431f40e419">gf2::BitMat::left_rotation</a></div><div class="ttdeci">static BitMat left_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-left by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMat.h:450</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ea6e1f38f9f05e3139613219262df31" name="a6ea6e1f38f9f05e3139613219262df31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea6e1f38f9f05e3139613219262df31">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the linear system <span class="tt">A.X_for = B</span> for any <span class="tt">B</span> where <span class="tt">A</span> is the matrix used to construct the <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> object. </p>
<p>This methods returns <span class="tt">std::nullopt</span> if the matrix is singular.</p>
<p>Each column of <span class="tt">X</span> is a solution to the linear system <span class="tt">A.x_for = b</span> where <span class="tt">b</span> is the corresponding column of <span class="tt">B</span>.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix <span class="tt">B</span> has a different number of rows than the number of row swap instructions.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-87"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab0adf92ca051399749f63c431f40e419">BitMat&lt;&gt;::left_rotation</a>(100, 5);</div>
<div class="line"><span class="keyword">auto</span> B = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab960f06474a7dcce924632e50dcc376b">BitMat&lt;&gt;::random</a>(100, 12);</div>
<div class="line"><span class="keyword">auto</span> lu = A.LU();</div>
<div class="line"><span class="keyword">auto</span> X = lu(B).value();</div>
<div class="line">assert_eq(A * X, B);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9502464ab5ce9b6d7ae38a4127c8a328" name="a9502464ab5ce9b6d7ae38a4127c8a328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9502464ab5ce9b6d7ae38a4127c8a328">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires (std::same_as&lt;typename Store::word_type, Word&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitVec.html">BitVec</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the linear system <span class="tt">A.x_for = b</span> for any <span class="tt">b</span> where <span class="tt">A</span> is the matrix used to construct the <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> object. </p>
<p>This methods returns <span class="tt">std::nullopt</span> if the matrix is singular.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the bit-matrix <span class="tt">b</span> has a different number of rows than the number of row swap instructions.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-86"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> n = 100uz;</div>
<div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab0adf92ca051399749f63c431f40e419">BitMat&lt;&gt;::left_rotation</a>(n, 1);</div>
<div class="line"><span class="keyword">auto</span> lu = A.LU();</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="classgf2_1_1BitVec.html#ab57ee9beea8e50d4671758c20e544215">BitVec&lt;&gt;::random</a>(n);</div>
<div class="line"><span class="keyword">auto</span> x = lu(b).value();</div>
<div class="line">assert_eq(A * x, b);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ab57ee9beea8e50d4671758c20e544215"><div class="ttname"><a href="classgf2_1_1BitVec.html#ab57ee9beea8e50d4671758c20e544215">gf2::BitVec::random</a></div><div class="ttdeci">static BitVec random(usize len, double p=0.5, u64 seed=0)</div><div class="ttdoc">Factory method to generate a bit-vector of size len where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitVec.h:345</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a63728f5e57f796f304a950f83b42ecd5" name="a63728f5e57f796f304a950f83b42ecd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63728f5e57f796f304a950f83b42ecd5">&#9670;&#160;</a></span>permutation_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::permutation_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the permutation matrix as a vector of showing the index positions of the non-zero entries. </p>
<p>A permutation matrix is just some row permutation of the identity matrix, so it has a single non-zero, 1, entry in each row or column. You don't need to store the entire matrix but instead store the locations of those 1's.</p>
<p>In the literature, the permutation vector is often given as a permutation of the index vector. For example, the permutation vector <span class="tt">[0,2,1,4,3]</span> tells you that elements/rows 1 and 2 are swapped, as are elements/rows 3 and 4. This form is easy to interpret at a glance and is returned by the <span class="tt">P_vector</span> method.</p>
<p>See the <span class="tt"><a class="el" href="#a948aa259cb7aa563f0fc0daff914fc5c" title="Returns a reference to the row swap instructions in LAPACK form.">swaps</a></span> method for an alternative form of the permutation matrix that is more convenient for executing the permutations in place. </p>

</div>
</div>
<a id="a36dfccacabf8937863685c6c47e4d875" name="a36dfccacabf8937863685c6c47e4d875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dfccacabf8937863685c6c47e4d875">&#9670;&#160;</a></span>permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitMat.html">BitMat</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes the rows of the input matrix <span class="tt">B</span> in-place using our row-swap instruction vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the dimensions of <span class="tt">B</span> and the row-swap instruction vector do not match. </dd></dl>

</div>
</div>
<a id="a76c6104824f5bdb8eaf2e2e5f06890f8" name="a76c6104824f5bdb8eaf2e2e5f06890f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c6104824f5bdb8eaf2e2e5f06890f8">&#9670;&#160;</a></span>permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires (std::same_as&lt;typename Store::word_type, Word&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::permute </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute the rows of the input vector <span class="tt">b</span> in-place using our row-swap instruction vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the dimensions of <span class="tt">b</span> and the row-swap instruction vector do not match. </dd></dl>

</div>
</div>
<a id="a7e8d5f21a8b7b0d5daedead86523152b" name="a7e8d5f21a8b7b0d5daedead86523152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8d5f21a8b7b0d5daedead86523152b">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::rank </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-85"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="classgf2_1_1BitMat.html#ab0adf92ca051399749f63c431f40e419">BitMat&lt;&gt;::left_rotation</a>(100, 1);</div>
<div class="line"><span class="keyword">auto</span> lu = A.LU();</div>
<div class="line">assert_eq(lu.rank(), 100);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a948aa259cb7aa563f0fc0daff914fc5c" name="a948aa259cb7aa563f0fc0daff914fc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948aa259cb7aa563f0fc0daff914fc5c">&#9670;&#160;</a></span>swaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; &amp; <a class="el" href="classgf2_1_1BitLU.html">gf2::BitLU</a>&lt; Word &gt;::swaps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the row swap instructions in <a href="https://en.wikipedia.org/wiki/LAPACK"><span class="tt">LAPACK</span></a> form. </p>
<p>A permutation matrix is just some row permutation of the identity matrix, so it has a single non-zero, 1, entry in each row or column. You don't need to store the entire matrix but instead store the locations of those 1's.</p>
<p>In the literature, the permutation vector is often given as a permutation of the index vector. For example, the permutation vector <span class="tt">[0,2,1,4,3]</span> tells you that elements/rows 1 and 2 are swapped, as are elements/rows 3 and 4. This form is easy to interpret at a glance. However, it is tedious to use as a guide to actually executing the permutations in place.</p>
<p>The <span class="tt">LAPACK</span> style <span class="tt"><a class="el" href="#a948aa259cb7aa563f0fc0daff914fc5c" title="Returns a reference to the row swap instructions in LAPACK form.">swaps</a></span> vector is an alternate, equally compact, form of the permutation matrix. Our previous example becomes <span class="tt">[0,2,2,4,4]</span>. This is interpreted as follows:</p>
<ul>
<li>No swap for row 0.</li>
<li>Swap row 1 with row 2.</li>
<li>No swap for row 2.</li>
<li>Swap row 3 with row 4.</li>
<li>No swap for row 4. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitLU.html">BitLU</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
