// This combined test file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `BitArray.h`, `BitGauss.h`, `BitLU.h`, `BitMatrix.h`, `BitPolynomial.h`, `BitRef.h`, `BitSpan.h`, `BitStore.h`, `BitVector.h`, `Iterators.h`, `Unsigned.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-26 16:50:00

#include "../include/gf2/BitArray.h"
#include "../include/gf2/BitGauss.h"
#include "../include/gf2/BitLU.h"
#include "../include/gf2/BitMatrix.h"
#include "../include/gf2/BitPolynomial.h"
#include "../include/gf2/BitRef.h"
#include "../include/gf2/BitSpan.h"
#include "../include/gf2/BitStore.h"
#include "../include/gf2/BitVector.h"
#include "../include/gf2/Iterators.h"
#include "../include/gf2/Unsigned.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    auto header_count = 11;
    std::size_t test_count = 489;
    std::println(stderr, "Running {} tests extracted from {} input files.", test_count, header_count);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::string_view header_file;
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for the combined test file:", doxy::max_fails);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    header_file = "BitArray.h";
    // Run the tests ...
    header_line = 42;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.size(), 10);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 53;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v0;
        assert_eq(v0.words(), 2);
        BitArray<10, u16> v1;
        assert_eq(v1.words(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 69;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        assert_eq(v.to_string(), "0000000000");
        v.set_all();
        assert_eq(v.to_string(), "1111111111");
        assert_eq(v.words(), 2);
        assert_eq(v.word(0), 0b1111'1111);
        assert_eq(v.word(1), 0b0000'0011);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 91;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        assert_eq(v.to_string(), "0000000000");
        v.set_word(1, 0b1111'1111);
        assert_eq(v.to_string(), "0000000011");
        assert_eq(v.count_ones(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 109;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.set_all();
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 122;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.set_all();
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 142;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<0> u;
        assert_eq(u.to_string(), "");
        BitArray<10, u8> v;
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 157;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v{u8{0b0101'0101}};
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 174;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10, u8>::zeros();
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 183;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10, u8>::ones();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 192;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10>::constant(true);
        assert_eq(v.to_string(), "1111111111");
        auto w = BitArray<10>::constant(false);
        assert_eq(w.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 205;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitArray<10>::unit(0).to_string(), "1000000000");
        assert_eq(BitArray<10>::unit(9).to_string(), "0000000001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 219;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10, u8>::alternating();
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 244;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        auto v = BitArray<10>::from(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 260;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10, u8>::from([](usize i) { return i % 2 == 0; });
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 285;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitArray<10>::random(0.5, seed);
        auto v = BitArray<10>::random(0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 307;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitArray<10>::seeded_random(seed);
        auto v = BitArray<10>::seeded_random(seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 321;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitArray<10>::biased_random(0.3);
        auto v = BitArray<10>::biased_random(0.3);
        assert_eq(u.size(), v.size());
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 338;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 352;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert(v[2] == false);
        v[2] = true;
        assert(v[2] == true);
        assert(v.to_string() == "0010000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 367;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.front(), false);
        v.set_all();
        assert_eq(v.front(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 381;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.back(), false);
        v.set_all();
        assert_eq(v.back(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 400;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v[0], false);
        v.set(0);
        assert_eq(v[0], true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 422;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v[2] = true;
        assert(v.to_string() == "0010000000");
        BitArray<10> w;
        w.set_all();
        v[3] = w[3];
        assert(v.to_string() == "0011000000");
        v[4] |= w[4];
        assert(v.to_string() == "0011100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 441;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitArray<10, u8>::ones();
        v.flip(0);
        assert_eq(v.to_string(), "0111111111");
        v.flip(1);
        assert_eq(v.to_string(), "0011111111");
        v.flip(9);
        assert_eq(v.to_string(), "0011111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 461;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "0100000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 9);
        assert_eq(v.to_string(), "0000000001");
        v.swap(0, 9);
        assert_eq(v.to_string(), "1000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 486;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<0> v;
        assert_eq(v.is_empty(), true);
        BitArray<10> u;
        assert_eq(u.is_empty(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 499;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.any(), false);
        v.set(0);
        assert_eq(v.any(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 512;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<3> v;
        assert_eq(v.all(), false);
        v.set(0);
        v.set(1);
        v.set(2);
        assert_eq(v.all(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 527;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.none(), true);
        v.set(0);
        assert_eq(v.none(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 544;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.set_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 557;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.flip_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 582;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<16, u8> v;
        u16 src = 0b1010101010101010;
        v.copy(src);
        assert_eq(v.to_string(), "0101010101010101");
        BitArray<16, u32> w;
        w.copy(src);
        assert_eq(w.to_string(), "0101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 609;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u64> v;
        assert_eq(v.to_string(), "0000000000");
        v.copy(BitVector<u8>::alternating(10));
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 631;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitArray<10> v;
        v.copy(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 649;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 670;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> u, v;
        u64 seed = 1234567890;
        u.fill_random(0.5, seed);
        v.fill_random(0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 689;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.count_ones(), 0);
        v.set(0);
        assert_eq(v.count_ones(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 700;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.count_zeros(), 10);
        v.set(0);
        assert_eq(v.count_zeros(), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 711;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v;
        assert_eq(v.leading_zeros(), 37);
        v.set(27);
        assert_eq(v.leading_zeros(), 27);
        BitArray<10, u8> w;
        w.set_all();
        assert_eq(w.leading_zeros(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 725;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<27, u8> v;
        assert_eq(v.trailing_zeros(), 27);
        v.set(0);
        assert_eq(v.trailing_zeros(), 26);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 740;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v;
        assert(v.first_set() == std::optional<usize>{});
        v.set(2);
        assert(v.first_set() == std::optional<usize>{2});
        v.set(2, false);
        assert(v.first_set() == std::optional<usize>{});
        v.set(27);
        assert(v.first_set() == std::optional<usize>{27});
        BitArray<0> empty;
        assert(empty.first_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 757;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v;
        assert(v.last_set() == std::optional<usize>{});
        v.set(2);
        assert(v.last_set() == std::optional<usize>{2});
        v.set(27);
        assert(v.last_set() == std::optional<usize>{27});
        BitArray<0> empty;
        assert(empty.last_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 772;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v;
        assert(v.next_set(0) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.next_set(0) == std::optional<usize>{2});
        assert(v.next_set(2) == std::optional<usize>{27});
        assert(v.next_set(27) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 786;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v;
        assert(v.previous_set(36) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.previous_set(36) == std::optional<usize>{27});
        assert(v.previous_set(27) == std::optional<usize>{2});
        assert(v.previous_set(2)  == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 804;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v; v.set_all();
        assert(v.first_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.first_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.first_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.first_unset() == std::optional<usize>{27});
        BitArray<0> empty;
        assert(empty.first_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 821;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v; v.set_all();
        assert(v.last_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.last_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.last_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.last_unset() == std::optional<usize>{27});
        BitArray<0> empty;
        assert(empty.last_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 838;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v; v.set_all();
        assert(v.next_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.next_unset(0) == std::optional<usize>{2});
        assert(v.next_unset(2) == std::optional<usize>{27});
        assert(v.next_unset(27) == std::optional<usize>{});
        BitArray<0> empty;
        assert(empty.next_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 854;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v; v.set_all();
        assert(v.previous_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.previous_unset(36) == std::optional<usize>{27});
        assert(v.previous_unset(27) == std::optional<usize>{2});
        assert(v.previous_unset(2) == std::optional<usize>{});
        BitArray<0> empty;
        assert(empty.previous_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 880;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<37, u8> v; v.set_all();
        for (auto&& bit : v.bits()) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 895;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        for (auto&& bit : v.bits()) bit = true;
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 907;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.set_bits());
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 921;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.unset_bits());
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 936;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v; v.set_all();
        assert_eq(v.to_string(), "1111111111");
        auto words = std::ranges::to<std::vector>(v.store_words());
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 949;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v; v.set_all();
        auto words = v.to_words();
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 968;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.copy([](usize i) { return i % 2 == 0; });
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 984;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.copy([](usize i) { return i % 2 == 0; });
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1111101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1005;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.copy([](usize i) { return i % 2 == 0; });
        auto s = v.sub(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1034;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.copy([](usize i) { return i % 2 == 0; });
        BitVector<u8> left, right;
        v.split_at(5, left, right);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1058;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        v.copy([](usize i) { return i % 2 == 0; });
        auto [left, right] = v.split_at(5);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1080;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v; v.set_all();
        BitVector<u8> dst;
        v.riffled(dst);
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1095;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v; v.set_all();
        auto dst = v.riffled();
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1115;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        assert_eq(v.to_binary_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_binary_string(), "1000000000");
        assert_eq(v.to_binary_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1136;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10, u8> v;
        assert_eq(v.to_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        assert_eq(v.to_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1153;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<10> v;
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.to_pretty_string(), "[1,0,1,0,1,0,1,0,1,0]");
        BitArray<0> empty;
        assert_eq(empty.to_pretty_string(), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1181;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitArray<0> v0;
        assert_eq(v0.to_hex_string(), "");
        BitArray<4> v1; v1.set_all();
        assert_eq(v1.to_hex_string(), "F");
        BitArray<5> v2; v2.set_all();
        assert_eq(v2.to_hex_string(), "F1.2");
        BitArray<8> v3;
        v3.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v3.to_binary_string(), "10101010");
        assert_eq(v3.to_hex_string(), "AA");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitGauss.h";
    // Run the tests ...
    header_line = 34;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.rank(), 1);
        assert_eq(solver.free_count(), 2);
        assert_eq(solver.solution_count(), 4);
        assert_eq(solver.is_underdetermined(), true);
        assert_eq(solver.is_consistent(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 60;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        BitGauss solver{A, b};
        assert_eq(solver.rank(), 1);
        assert_eq(solver.is_underdetermined(), true);
        assert_eq(solver.is_consistent(), true);
        assert_eq(solver.free_count(), 2);
        assert_eq(solver.solution_count(), 4);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 123;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.rank(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 134;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.free_count(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 145;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.is_underdetermined(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 158;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.is_consistent(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 174;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.solution_count(), 4);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 189;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::identity(3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver().value().to_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 218;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.solution_count(), 4);
        assert_eq(solver(0).value().to_string(), "100");
        assert_eq(solver(1).value().to_string(), "010");
        assert_eq(solver(2).value().to_string(), "001");
        assert_eq(solver(3).value().to_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitLU.h";
    // Run the tests ...
    header_line = 54;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<u8>::random(100, 100);
        auto lu = A.LU();
        auto LU = lu.L() * lu.U();
        auto PA = A;
        lu.permute(PA);
        assert_eq(PA, LU);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 105;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::left_rotation(100, 1);
        auto lu = A.LU();
        assert_eq(lu.rank(), 100);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 202;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto n = 100uz;
        auto A = BitMatrix<>::left_rotation(n, 1);
        auto lu = A.LU();
        auto b = BitVector<>::random(n);
        auto x = lu(b).value();
        assert_eq(A * x, b);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 249;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::left_rotation(100, 5);
        auto B = BitMatrix<>::random(100, 12);
        auto lu = A.LU();
        auto X = lu(B).value();
        assert_eq(A * X, B);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 290;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::left_rotation(100, 1);
        BitLU lu{A};
        auto A_inv = lu.inverse().value();
        assert_eq(A_inv, BitMatrix<>::right_rotation(100, 1));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitMatrix.h";
    // Run the tests ...
    header_line = 51;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.to_compact_binary_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 62;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m{3};
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 75;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m{3, 4};
        assert_eq(m.to_compact_binary_string(), "0000 0000 0000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 89;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto rows = std::vector{BitVector<>::zeros(3), BitVector<>::ones(3)};
        BitMatrix m{rows};
        assert_eq(m.to_compact_binary_string(), "000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 107;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto rows = std::vector{BitVector<>::zeros(3), BitVector<>::ones(3)};
        BitMatrix m{std::move(rows)};
        assert_eq(m.to_compact_binary_string(), "000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 123;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 4);
        assert_eq(m.to_compact_binary_string(), "0000 0000 0000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 132;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3);
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 141;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 4);
        assert_eq(m.to_compact_binary_string(), "1111 1111 1111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 153;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3);
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 162;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::alternating(3, 4);
        assert_eq(m.to_compact_binary_string(), "1010 0101 1010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 176;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::alternating(3);
        assert_eq(m.to_compact_binary_string(), "101 010 101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 185;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::from_string("101").value();
        auto v = BitVector<>::from_string("110").value();
        auto m = BitMatrix<>::from_outer_product(u, v);
        assert_eq(m.to_compact_binary_string(), "110 000 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 205;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::from_string("101").value();
        auto v = BitVector<>::from_string("110").value();
        auto m = BitMatrix<>::from_outer_sum(u, v);
        assert_eq(m.to_compact_binary_string(), "001 110 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 225;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::from(3, 2, [](usize i, usize) { return i % 2 == 0; });
        assert_eq(m.to_compact_binary_string(), "11 00 11");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 258;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::random(3, 2, 0.5, seed);
        auto v = BitMatrix<>::random(3, 2, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 308;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::seeded_random(3, 2, seed);
        auto v = BitMatrix<>::seeded_random(3, 2, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 327;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::seeded_random(3, seed);
        auto v = BitMatrix<>::seeded_random(3, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 343;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitMatrix<>::biased_random(10, 7, 0.3);
        auto v = BitMatrix<>::biased_random(10, 7, 0.3);
        assert_eq(u.size(), v.size());
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 357;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitMatrix<>::biased_random(10, 0.3);
        assert_eq(u.size(), 100);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 370;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 379;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 395;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto top_row = BitVector<>::ones(5);
        auto m = BitMatrix<>::companion(top_row);
        assert_eq(m.to_compact_binary_string(), "11111 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 416;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::left_shift(5, 2);
        auto v = BitVector<>::ones(5);
        assert_eq(dot(m, v).to_string(), "11100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 432;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::right_shift(5, 2);
        auto v = BitVector<>::ones(5);
        assert_eq(dot(m, v).to_string(), "00111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 448;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::left_rotation(5, 2);
        auto v = BitVector<>::from_binary_string("11100").value();
        assert_eq(dot(m, v).to_string(), "00111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 467;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::right_rotation(5, 2);
        auto v = BitVector<>::from_binary_string("11100").value();
        assert_eq(dot(m, v).to_string(), "10011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 488;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(15);
        auto m1 = BitMatrix<>::from_row_store(v, 3).value();
        assert_eq(m1.to_compact_binary_string(), "11111 11111 11111");
        auto m2 = BitMatrix<>::from_row_store(v, 5).value();
        assert_eq(m2.to_compact_binary_string(), "111 111 111 111 111");
        auto m3 = BitMatrix<>::from_row_store(v, 15).value();
        assert_eq(m3.to_compact_binary_string(), "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 525;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(15);
        auto m1 = BitMatrix<>::from_col_store(v, 3).value();
        assert_eq(m1.to_compact_binary_string(), "111 111 111 111 111");
        auto m2 = BitMatrix<>::from_col_store(v, 5).value();
        assert_eq(m2.to_compact_binary_string(), "11111 11111 11111");
        auto m3 = BitMatrix<>::from_col_store(v, 15).value();
        assert_eq(m3.to_compact_binary_string(), "111111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 574;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m1 = BitMatrix<>::from_string("111   111\n111").value();
        assert_eq(m1.to_compact_binary_string(), "111 111 111");
        auto m2 = BitMatrix<>::from_string("0XAA; 0b1111_0000").value();
        assert_eq(m2.to_compact_binary_string(), "10101010 11110000");
        auto m3 = BitMatrix<>::from_string("0x7.8 000").value();
        assert_eq(m3.to_compact_binary_string(), "111 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 647;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.is_square(), false);
        m.resize(3, 3);
        assert_eq(m.is_square(), true);
        m.resize(3, 4);
        assert_eq(m.is_square(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 660;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.is_zero(), false);
        m.resize(3, 3);
        assert_eq(m.is_zero(), true);
        m.resize(3, 4);
        assert_eq(m.is_zero(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 673;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.is_identity(), true);
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 691;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.is_symmetric(), true);
        m.row(0).set_all();
        assert_eq(m.is_symmetric(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 714;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.count_ones(), 0);
        m.set_all();
        assert_eq(m.count_ones(), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 729;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.count_zeros(), 6);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 741;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.count_ones_on_diagonal(), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 761;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m1 = BitMatrix<>::identity(3);
        assert_eq(m1.trace(), true);
        auto m2 = BitMatrix<>::zero(4);
        assert_eq(m2.trace(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 778;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.any(), false);
        m.set(0, 0);
        assert_eq(m.any(), true);
        m.clear();
        assert_eq(m.any(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 797;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.all(), false);
        m.set_all();
        assert_eq(m.all(), true);
        m.clear();
        assert_eq(m.all(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 816;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.none(), true);
        m.set_all();
        assert_eq(m.none(), false);
        m.clear();
        assert_eq(m.none(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 840;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.get(0, 0), false);
        m.set(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 858;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m(0, 0), false);
        m.set(0, 0);
        assert_eq(m(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 877;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 894;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m(0,0), false);
        m(0,0) = true;
        assert_eq(m(0,0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 912;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 933;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.row(0).to_binary_string(), "100");
        assert_eq(m.row(1).to_binary_string(), "010");
        assert_eq(m.row(2).to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 950;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.row(0).set(1);
        assert_eq(m.row(0).to_binary_string(), "110");
        assert_eq(m.row(1).to_binary_string(), "010");
        assert_eq(m.row(2).to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 968;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m[0].to_binary_string(), "100");
        assert_eq(m[1].to_binary_string(), "010");
        assert_eq(m[2].to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 985;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m[0].set(1);
        assert_eq(m[0].to_binary_string(), "110");
        assert_eq(m[1].to_binary_string(), "010");
        assert_eq(m[2].to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1009;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto col = m.col(1);
        assert_eq(col.to_string(), "010");
        col.set(0);
        col.set(2);
        assert_eq(col.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1036;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set_all();
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1048;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip_all();
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1067;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set_diagonal();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1083;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip_diagonal();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1101;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.set_super_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "01000 00100 00010 00001 00000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1119;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.flip_super_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "01000 00100 00010 00001 00000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1137;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.set_sub_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "00000 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1155;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.flip_sub_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "00000 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1177;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        m.resize(10, 10);
        assert_eq(m.rows(), 10);
        assert_eq(m.cols(), 10);
        m.resize(3, 7);
        assert_eq(m.rows(), 3);
        assert_eq(m.cols(), 7);
        m.resize(0, 10);
        assert_eq(m.rows(), 0);
        assert_eq(m.cols(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1204;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.clear();
        assert_eq(m.rows(), 0);
        assert_eq(m.cols(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1217;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::from_string("111 111 111 111").value();
        m.make_square(3);
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1235;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto row = BitVector<>::ones(3);
        m.append_row(row);
        assert_eq(m.to_compact_binary_string(), "000 000 000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1259;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.append_row(BitVector<>::ones(3));
        assert_eq(m.to_compact_binary_string(), "000 000 000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1279;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto src = BitMatrix<>::ones(3, 3);
        m.append_rows(src);
        assert_eq(m.to_compact_binary_string(), "000 000 000 111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1301;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.append_rows(BitMatrix<>::ones(3, 3));
        assert_eq(m.to_compact_binary_string(), "000 000 000 111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1320;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto col = BitVector<>::ones(3);
        m.append_col(col);
        assert_eq(m.to_compact_binary_string(), "0001 0001 0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1341;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto src = BitMatrix<>::ones(3, 2);
        m.append_cols(src);
        assert_eq(m.to_compact_binary_string(), "00011 00011 00011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1360;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto row = m.remove_row();
        assert_eq(row->to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1377;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto popped = m.remove_rows(2);
        assert_eq(popped->to_compact_binary_string(), "111 111");
        assert_eq(m.to_compact_binary_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1396;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto col = m.remove_col();
        assert_eq(col->to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "11 11 11");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1421;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(5);
        auto sub1 = m.sub_matrix(1, 4, 1, 4);
        assert_eq(sub1.to_compact_binary_string(), "100 010 001");
        auto sub2 = m.sub_matrix(1, 1, 1, 1);
        assert_eq(sub2.to_compact_binary_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1455;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(5);
        m.replace_sub_matrix(1, 1, BitMatrix<>::ones(3, 3));
        assert_eq(m.to_compact_binary_string(), "10000 01110 01110 01110 00001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1475;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.lower();
        assert_eq(sub_m.to_compact_binary_string(), "100 110 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1499;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.upper();
        assert_eq(sub_m.to_compact_binary_string(), "111 011 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1525;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.strictly_lower();
        assert_eq(sub_m.to_compact_binary_string(), "000 100 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1541;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.strictly_upper();
        assert_eq(sub_m.to_compact_binary_string(), "011 001 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1557;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 3);
        auto sub_m = m.unit_lower();
        assert_eq(sub_m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1573;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 3);
        auto sub_m = m.unit_upper();
        assert_eq(sub_m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1594;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.swap_rows(0, 1);
        assert_eq(m.to_compact_binary_string(), "010 100 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1611;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.swap_cols(0, 1);
        assert_eq(m.to_compact_binary_string(), "010 100 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1628;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.add_identity();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1647;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 2);
        m.row(0).set_all();
        assert_eq(m.to_compact_binary_string(), "11 00 00");
        auto n = m.transposed();
        assert_eq(n.to_compact_binary_string(), "100 100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1672;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.row(0).set_all();
        assert_eq(m.to_compact_binary_string(), "111 000 000");
        m.transpose();
        assert_eq(m.to_compact_binary_string(), "100 100 100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1704;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::random(100, 100);
        auto p1 = m.to_the(3);
        auto o1 = m * m * m;
        assert_eq(p1, o1);
        auto p2 = m.to_the(2, true);
        auto o2 = m * o1;
        assert_eq(p2, o2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1765;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.set(2, 1, false);
        auto has_pivot = m.to_echelon_form();
        assert_eq(has_pivot.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1823;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.set(2, 1, false);
        auto pivots = m.to_reduced_echelon_form();
        assert_eq(pivots.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1856;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.inverse().value().to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1889;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::probability_invertible(10);
        assert(abs(p - 0.289) < 1e-3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1920;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::probability_singular(10);
        assert(abs(p - 0.711) < 1e-3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1933;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto lu = m.LU();
        assert_eq(lu.LU().to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1947;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.rank(), 1);
        assert_eq(solver.free_count(), 2);
        assert_eq(solver.solution_count(), 4);
        assert_eq(solver.is_underdetermined(), true);
        assert_eq(solver.is_consistent(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1966;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::identity(3);
        auto b = BitVector<>::ones(3);
        auto x = A.x_for(b).value();
        assert_eq(x.to_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1992;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m2 = BitMatrix<>::identity(2);
        assert_eq(m2.characteristic_polynomial().to_string(), "1 + x^2");
        auto m3 = BitMatrix<>::identity(3);
        assert_eq(m3.characteristic_polynomial().to_string(), "1 + x + x^2 + x^3");
        auto m100 = BitMatrix<>::random(100, 100);
        auto p = m100.characteristic_polynomial();
        assert_eq(p(m100).is_zero(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2036;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto top_row = BitVector<>::from_binary_string("101").value();
        assert_eq(BitMatrix<>::companion_matrix_characteristic_polynomial(top_row).to_string(), "1 + x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2094;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs ^= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2113;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs &= rhs;
        assert_eq(lhs.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2132;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs |= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2151;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs ^ rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2172;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs & rhs;
        assert_eq(result.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2193;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs | rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2211;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto result = ~m;
        assert_eq(result.to_compact_binary_string(), "011 101 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2232;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs += rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2247;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs -= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2262;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs - rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2281;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs + rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2308;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_binary_string(), "1000\n0100\n0010\n0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2336;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_compact_binary_string(), "1000 0100 0010 0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2347;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_string(), "1000\n0100\n0010\n0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2360;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(3);
        auto bar = "\u2502";
        auto expected = std::format("{0}1 0 0{0}\n{0}0 1 0{0}\n{0}0 0 1{0}", bar);
        assert_eq(I.to_pretty_string(), expected);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2385;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m0;
        assert_eq(m0.to_hex_string(), "");
        auto m1 = BitMatrix<>::zero(4);
        m1.set_all();
        assert_eq(m1.to_hex_string(), "F\nF\nF\nF");
        auto m2 = BitMatrix<>::zero(5);
        m2.flip_all();
        assert_eq(m2.to_hex_string(), "F1.2\nF1.2\nF1.2\nF1.2\nF1.2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2430;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m0;
        assert_eq(m0.to_compact_hex_string(), "");
        auto m1 = BitMatrix<>::zero(4);
        m1.set_all();
        assert_eq(m1.to_compact_hex_string(), "F F F F");
        auto m2 = BitMatrix<>::zero(5);
        m2.flip_all();
        assert_eq(m2.to_compact_hex_string(), "F1.2 F1.2 F1.2 F1.2 F1.2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2452;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::identity(3);
        auto q = BitMatrix<>::identity(3);
        assert(p == q);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2820;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<u8>::zero(4);
        m.set_all();
        auto ms = std::format("{}", m);
        auto mp = std::format("{:p}", m);
        auto mx = std::format("{:x}", m);
        assert_eq(ms, "1111\n1111\n1111\n1111");
        assert_eq(mp, "\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502");
        assert_eq(mx, "F\nF\nF\nF");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitPolynomial.h";
    // Run the tests ...
    header_line = 22;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        p[0] = true;
        p[1] = false;
        p[2] = true;
        assert_eq(p.to_string(), "1 + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 49;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 60;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p{BitVector<>::ones(10)};
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 77;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::ones(10);
        BitPolynomial p{std::move(coeffs)};
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 91;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zero();
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 100;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::one();
        assert_eq(p.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 109;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::constant(true);
        assert_eq(p.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 122;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_full_string(), "0 + 0x + 0x^2 + 0x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 133;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(4);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 142;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 154;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::from(10, [](usize i) { return i % 2 == 0; });
        assert_eq(p.to_string(), "1 + x^2 + x^4 + x^6 + x^8 + x^10");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 187;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 42;
        auto p1 = BitPolynomial<>::seeded_random(3311, seed);
        auto p2 = BitPolynomial<>::seeded_random(3311, seed);
        assert_eq(p1, p2, "BitPolys with the same seed should be equal");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 213;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("10101000").value();
        BitPolynomial p{coeffs};
        assert_eq(p.degree(), 4);
        assert_eq(p.size(), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 226;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("10101000").value();
        BitPolynomial p{coeffs};
        assert_eq(p.degree(), 4);
        assert_eq(p.size(), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 261;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p[2], false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 272;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_string(), "0");
        p[2] = true;
        assert_eq(p.to_string(), "x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 285;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(3);
        auto c = p.coefficients();
        assert_eq(c.to_string(), "1111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 297;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_string(), "0");
        auto& c = p.coefficients();
        c.set_all();
        assert_eq(p.to_string(), "1 + x + x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 311;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
        auto c = BitVector<u8>::ones(3);
        p.copy_coefficients(c);
        assert_eq(c.to_string(), "111");
        assert_eq(p.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 332;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
        auto coeffs = BitVector<>::ones(3);
        p.copy_coefficients(std::move(coeffs));
        assert_eq(p.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 348;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.clear();
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 366;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("111010").value();
        assert_eq(coeffs.to_string(), "111010");
        BitPolynomial p{coeffs};
        assert_eq(p.to_string(), "1 + x + x^2 + x^4");
        assert_eq(p.to_full_string(), "1 + x + x^2 + 0x^3 + x^4 + 0x^5");
        p.resize(2);
        assert_eq(p.to_string(), "1 + x");
        p.resize(4);
        assert_eq(p.to_full_string(), "1 + x + 0x^2 + 0x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 385;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.shrink_to_fit();
        assert_eq(p.to_string(), "x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 402;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.is_monic(), false);
        p.make_monic();
        assert_eq(p.is_monic(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 421;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(2);
        auto q = BitPolynomial<>::x_to_the(3);
        p += q;
        assert_eq(p.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 453;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(2);
        auto q = BitPolynomial<>::x_to_the(3);
        p -= q;
        assert_eq(p.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 466;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(1);
        assert_eq(p.to_string(), "1 + x");
        auto q = BitPolynomial<>::ones(2);
        assert_eq(q.to_string(), "1 + x + x^2");
        p *= q;
        assert_eq(p.to_string(), "1 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 494;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p + q;
        assert_eq(r.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 518;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p - q;
        assert_eq(r.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 532;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p * q;
        assert_eq(r.to_string(), "x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 553;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("111").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_string(), "1 + x + x^2");
        BitPolynomial q;
        p.squared(q);
        assert_eq(q.to_string(), "1 + x^2 + x^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 578;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        auto q = p.squared();
        assert_eq(q.to_string(), "x^6");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 595;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.times_x_to_the(2);
        assert_eq(p.to_string(), "x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 617;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        BitPolynomial q;
        p.sub(4, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4");
        p.sub(6, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        p.sub(16, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        p.sub(0, q);
        assert_eq(q.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 644;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(4).to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(p.sub(6).to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(16).to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(0).to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 662;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        BitPolynomial low, high;
        p.split(4, low, high);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(high.to_string(), "1 + x");
        p.split(6, low, high);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(high.to_string(), "0");
        p.split(0, low, high);
        assert_eq(low.to_string(), "1");
        assert_eq(high.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 693;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(7);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7");
        auto [low, high] = p.split(4);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(high.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 713;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p(true), true);
        assert_eq(p(false), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 739;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(6);
        BitPolynomial p1{BitVector<>::alternating(12)};
        assert_eq(p1(m), BitMatrix<>::zeros(6, 6));
        BitPolynomial p2{BitVector<>::alternating(6)};
        assert_eq(p2(m), BitMatrix<>::identity(6));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 793;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto r = p.reduce_x_to_the(2);
        assert_eq(r.to_string(), "x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 909;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_string("M"), "1 + M^2 + M^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 947;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_full_string("M"), "1 + 0M + M^2 + 0M^3 + M^4 + 0M^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 989;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::zeros(1000);
        q[3] = true;
        assert(p == q);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1033;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(2);
        auto px = std::format("{}", p);
        auto py = std::format("{:y}", p);
        assert_eq(px, "1 + x + x^2");
        assert_eq(py, "1 + y + y^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitRef.h";
    // Run the tests ...
    header_line = 24;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        assert_eq(v.to_string(), "000");
        v[1] = true;
        assert_eq(v.to_string(), "010");
        v[2] = 1;
        assert_eq(v.to_string(), "011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 54;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        auto bit = ref(v, 0);
        assert_eq(static_cast<bool>(bit), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 64;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        ref(v, 0) = true;
        assert_eq(to_string(v), "100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 77;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(3);
        auto w = BitVector<>::ones(3);
        ref(v, 0) = ref(w, 0);
        assert_eq(to_string(v), "100");
        ref(v, 1) = ref(w, 1);
        assert_eq(to_string(v), "110");
        ref(v, 2) = ref(w, 2);
        assert_eq(to_string(v), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 95;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(3);
        ref(v, 0).flip();
        assert_eq(to_string(v), "100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 108;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(3);
        ref(v, 0) &= false;
        assert_eq(to_string(v), "011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 121;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(3);
        auto w = BitVector<>::zeros(3);
        ref(v, 0) &= ref(w, 0);
        assert_eq(to_string(v), "011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 135;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(3);
        ref(v, 0) |= true;
        assert_eq(to_string(v), "100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 148;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(3);
        auto w = BitVector<>::ones(3);
        ref(v, 0) |= ref(w, 0);
        assert_eq(to_string(v), "100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 162;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(3);
        ref(v, 0) ^= true;
        assert_eq(to_string(v), "011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 175;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(3);
        auto w = BitVector<>::ones(3);
        ref(v, 0) ^= ref(w, 0);
        assert_eq(to_string(v), "011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitSpan.h";
    // Run the tests ...
    header_line = 70;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::vector<u8> words{0b1010'1010, 0b1100'1100};
        BitSpan s{words.data(), 0, 16};
        assert_eq(s.to_string(), "0101010100110011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 95;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::vector<u8> words{0b1010'1010, 0b1100'1100};
        BitSpan s{words.data(), 0, 16};
        assert_eq(s.size(), 16);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 110;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(18);
        assert_eq(v.words(), 3);
        auto s = v.span(4, 12);     // The span covers words 0 and 1 in the span underlying v.
        assert_eq(s.words(), 1);    // However, it can be fitted into a single synthetic word!
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 127;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::from_string("0000'0000'1111'1111").value();
        auto s = v.span(4, 12);     // The span covers words 0 and 1 in the span underlying v.
        assert_eq(s.words(), 1);    // However, it can be fitted into a single synthetic word!
        assert_eq(s.word(0), 0b1111'0000);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 162;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::from_string("0000_0000_1111_1111").value();
        auto s = v.span(4, 12);     // The span covers words 0 and 1 in the span underlying v.
        assert_eq(s.words(), 1);    // However, it can be fitted into a single synthetic word!
        assert_eq(s.word(0), 0b1111'0000);
        s.set_word(0, 0b1111'1111);
        assert_eq(v.to_string(), "0000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 209;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10};
        auto v = u.span(0,2);
        assert_eq(v.get(0), false);
        u.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 224;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10};
        auto v = u.span(1, 4);
        assert_eq(v[0], false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 237;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::ones(10);
        auto v = u.span(0,3);
        assert_eq(v.front(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 250;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::ones(10);
        auto v = u.span(0,3);
        assert_eq(v.back(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 268;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(0,3);
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
        assert_eq(u.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 291;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(0,5);
        v[2] = true;
        assert_eq(v.to_string(), "00100");
        assert_eq(u.to_string(), "0010000000");
        auto w = BitVector<>::ones(10);
        v[3] = w[3];
        assert_eq(v.to_string(), "00110");
        v[4] |= w[4];
        assert_eq(v.to_string(), "00111");
        assert_eq(u.to_string(), "0011100000")
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 312;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::ones(10);
        auto v = u.span(1,5);
        assert_eq(v.to_string(), "1111");
        v.flip(0);
        assert_eq(v.to_string(), "0111");
        assert_eq(u.to_string(), "1011111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 331;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(1,5);
        v.set(0);
        assert_eq(v.to_string(), "1000");
        assert_eq(u.to_string(), "0100000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "0100");
        assert_eq(u.to_string(), "0010000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 353;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(1,1);
        assert_eq(v.is_empty(), true);
        auto w = u.span(0,1);
        assert_eq(w.is_empty(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 367;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(1,3);
        assert_eq(v.any(), false);
        v.set(0);
        assert_eq(v.any(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 381;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(1,3);
        assert_eq(v.all(), false);
        v.set(0);
        v.set(1);
        assert_eq(v.all(), true);
        assert_eq(u.all(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 397;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(1,3);
        assert_eq(v.none(), true);
        v.set(0);
        assert_eq(v.none(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 415;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(5,10);
        v.set_all();
        assert_eq(v.to_string(), "11111");
        assert_eq(u.to_string(), "0000011111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 427;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::zeros(10);
        auto v = u.span(5,10);
        v.flip_all();
        assert_eq(v.to_string(), "11111");
        assert_eq(u.to_string(), "0000011111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 451;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u8> v{26};
        auto s = v.span(3, 19);
        u16 src = 0b1010101010101010;
        s.copy(src);
        assert_eq(s.to_string(), "0101010101010101");
        assert_eq(v.to_string(), "00001010101010101010000000");
        BitVector<u32> w{26};
        auto t = w.span(3, 19);
        t.copy(src);
        assert_eq(t.to_string(), "0101010101010101");
        assert_eq(w.to_string(), "00001010101010101010000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 481;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(16);
        assert_eq(v.to_string(), "1111111111111111");
        auto s = v.span(0,10);
        s.copy(BitVector<u8>::alternating(10));
        assert_eq(v.to_string(), "1010101010111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 504;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        auto v = BitVector<u8>::ones(16);
        auto s = v.span(0,10);
        s.copy(src);
        assert_eq(s.to_string(), "0101010101");
        assert_eq(v.to_string(), "0101010101111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 526;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(16);
        auto s = v.span(0,10);
        s.copy([](usize i) { return i % 2 == 0; });
        assert_eq(s.to_string(), "1010101010");
        assert_eq(v.to_string(), "1010101010111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 548;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10}, v{10};
        auto s = u.span(2,10);
        auto t = v.span(2,10);
        u64 seed = 1234567890;
        s.fill_random(0.5, seed);
        t.fill_random(0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 569;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        auto s = v.span(2,10);
        assert_eq(s.count_ones(), 0);
        v.set(2);
        assert_eq(s.count_ones(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 581;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        auto s = v.span(2,10);
        assert_eq(s.count_zeros(), 8);
        v.set(2);
        assert_eq(s.count_zeros(), 7);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 593;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{37};
        auto s = v.span(2,10);
        assert_eq(s.leading_zeros(), 8);
        v.set(11);
        assert_eq(s.leading_zeros(), 8);
        v.set(2);
        assert_eq(s.leading_zeros(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 607;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(27);
        auto s = v.span(2,10);
        assert_eq(s.trailing_zeros(), 8);
        v.set(11);
        assert_eq(s.trailing_zeros(), 8);
        v.set(2);
        assert_eq(s.trailing_zeros(), 7);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 625;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        auto s = v.span(4,12);
        assert(s.first_set() == std::optional<usize>{});
        v.set(2);
        assert(s.first_set() == std::optional<usize>{});
        v.set(4);
        assert(s.first_set() == std::optional<usize>{0});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 639;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        auto s = v.span(4,12);
        assert(s.last_set() == std::optional<usize>{});
        v.set(27);
        assert(s.last_set() == std::optional<usize>{});
        v.set(11);
        assert_eq(s.to_string(), "00000001");
        assert(s.last_set() == std::optional<usize>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 654;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        auto s = v.span(4,12);
        assert(s.next_set(0) == std::optional<usize>{});
        v.set(5);
        v.set(6);
        assert(s.next_set(0) == std::optional<usize>{1});
        assert(s.next_set(1) == std::optional<usize>{2});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 668;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        auto s = v.span(4,12);
        assert(s.previous_set(s.size()) == std::optional<usize>{});
        v.set(5);
        v.set(6);
        assert(s.previous_set(s.size()) == std::optional<usize>{2});
        assert(s.previous_set(2) == std::optional<usize>{1});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 686;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        auto s = v.span(4,12);
        assert(s.first_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(s.first_unset() == std::optional<usize>{});
        v.set(4, false);
        assert(s.first_unset() == std::optional<usize>{0});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 700;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        auto s = v.span(4,12);
        assert(s.last_unset() == std::optional<usize>{});
        v.set(27);
        assert(s.last_unset() == std::optional<usize>{});
        v.set(4, false);
        assert_eq(s.to_string(), "01111111");
        assert(s.last_unset() == std::optional<usize>{0});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 715;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        auto s = v.span(4,12);
        assert(s.last_unset() == std::optional<usize>{});
        v.set(27);
        assert(s.last_unset() == std::optional<usize>{});
        v.set(11, false);
        assert_eq(s.to_string(), "11111110");
        assert(s.last_unset() == std::optional<usize>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 730;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        auto s = v.span(4,12);
        assert(s.previous_unset(s.size()) == std::optional<usize>{});
        v.set(5, false);
        v.set(6, false);
        assert(s.previous_unset(s.size()) == std::optional<usize>{2});
        assert(s.previous_unset(2) == std::optional<usize>{1});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 754;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(14);
        auto s = u.span(4,12);
        for (auto&& bit : s.bits()) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 770;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(14);
        auto s = u.span(4,12);
        for (auto&& bit : s.bits()) bit = false;
        assert_eq(s.to_string(), "00000000")
        assert_eq(u.to_string(), "11110000000011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 784;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(19);
        auto s = v.span(4,12);
        assert_eq(s.to_string(), "10101010");
        auto indices = std::ranges::to<std::vector>(s.set_bits());
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 798;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(19);
        auto s = v.span(4,12);
        assert_eq(s.to_string(), "10101010");
        auto indices = std::ranges::to<std::vector>(s.unset_bits());
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 819;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(100);
        auto s = v.span(4,14);
        assert_eq(s.to_string(), "1111111111");
        auto words = std::ranges::to<std::vector>(s.store_words());
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 833;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(100);
        auto s = v.span(4,14);
        assert_eq(s.to_string(), "1111111111");
        auto words = s.to_words();
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 854;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        const auto v = BitVector<u8>::alternating(14);
        const auto s0 = v.span(4,12);
        assert_eq(s0.to_string(), "10101010");
        auto s1 = s0.span(4,8);
        assert_eq(s1.to_string(), "1010")
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 871;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(14);
        auto s0 = v.span(4,12);
        assert_eq(s0.to_string(), "10101010");
        auto s1 = s0.span(4,8);
        assert_eq(s1.to_string(), "1010")
        s1.set_all();
        assert_eq(s1.to_string(), "1111")
        assert_eq(s0.to_string(), "10101111");
        assert_eq(v.to_string(), "10101010111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 894;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::alternating(14);
        auto s = u.span(4,12);
        auto v = s.sub(0,4);
        assert_eq(v.to_string(), "1010");
        s.set_all();
        assert_eq(s.to_string(), "11111111");
        assert_eq(u.to_string(), "10101111111110");
        assert_eq(v.to_string(), "1010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 924;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::alternating(14);
        auto s = u.span(4,12);
        BitVector left, right;
        s.split_at(5, left, right);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "010");
        assert_eq(u.to_string(), "10101010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 948;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::alternating(14);
        auto s = u.span(4,12);
        auto [left, right] = s.split_at(5);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "010");
        assert_eq(u.to_string(), "10101010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 970;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        BitVector<u8> dst;
        v.span(4,14).riffled(dst);
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 985;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        auto dst = v.span(4,14).riffled();
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1005;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{14};
        auto s = v.span(2,12);
        assert_eq(s.to_binary_string(), "0000000000");
        s.set(0);
        assert_eq(s.to_binary_string(), "1000000000");
        assert_eq(v.to_binary_string(",", "[", "]"), "[0,0,1,0,0,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1027;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{14};
        auto s = v.span(2,12);
        assert_eq(s.to_binary_string(), "0000000000");
        s.set(0);
        assert_eq(s.to_binary_string(), "1000000000");
        assert_eq(v.to_binary_string(",", "[", "]"), "[0,0,1,0,0,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1045;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(14);
        auto s = v.span(2,12);
        assert_eq(s.to_pretty_string(), "[1,0,1,0,1,0,1,0,1,0]");
        auto empty = v.span(3,3);
        assert_eq(empty.to_pretty_string(), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1073;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        assert_eq(v.span(4,4).to_hex_string(), "");
        assert_eq(v.span(4,8).to_hex_string(), "F");
        assert_eq(v.span(4,9).to_hex_string(), "F1.2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitStore.h";
    // Run the tests ...
    header_line = 160;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(get(v, 0), false);
        set(v, 0);
        assert_eq(get(v, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 185;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        ref(v, 2) = true;
        assert(to_string(v) == "0010000000");
        auto w = BitVector<>::ones(10);
        ref(v, 3) = get(w, 3);
        assert(to_string(v) == "0011000000");
        ref(v, 4) |= get(w, 4);
        assert(to_string(v) == "0011100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 208;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(front(v), true);
        set_all(v, false);
        assert_eq(front(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 227;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(back(v), true);
        set_all(v, false);
        assert_eq(back(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 246;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(get(v, 0), false);
        set(v, 0);
        assert_eq(get(v, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 268;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        flip(v, 0);
        assert_eq(to_string(v), "0111111111");
        flip(v, 1);
        assert_eq(to_string(v), "0011111111");
        flip(v, 9);
        assert_eq(to_string(v), "0011111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 292;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(10);
        set(v, 0);
        assert_eq(to_string(v), "1000000000");
        swap(v, 0, 1);
        assert_eq(to_string(v), "0100000000");
        swap(v, 0, 1);
        assert_eq(to_string(v), "1000000000");
        swap(v, 0, 9);
        assert_eq(to_string(v), "0000000001");
        swap(v, 0, 9);
        assert_eq(to_string(v), "1000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 337;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        assert_eq(is_empty(v), true);
        BitVector u{10};
        assert_eq(is_empty(u), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 355;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(any(v), false);
        set(v, 0);
        assert_eq(any(v), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 375;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        assert_eq(all(v), false);
        set(v, 0);
        set(v, 1);
        set(v, 2);
        assert_eq(all(v), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 411;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(none(v), true);
        set(v,0);
        assert_eq(none(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 432;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        set_all(v);
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 448;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        flip_all(v);
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 474;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u8> v{16};
        u16 src = 0b1010101010101010;
        copy(src, v);
        assert_eq(to_string(v), "0101010101010101");
        BitVector<u32> w{16};
        copy(src, w);
        assert_eq(to_string(w), "0101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 516;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u64>::ones(10);
        assert_eq(to_string(v), "1111111111");
        copy(BitVector<u8>::alternating(10), v);
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 591;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVector v{10};
        copy(src, v);
        assert_eq(to_string(v), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 612;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        copy(v, [](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 636;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10}, v{10};
        u64 seed = 1234567890;
        fill_random(u, 0.5, seed);
        fill_random(v, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 685;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(count_ones(v), 0);
        set(v, 0);
        assert_eq(count_ones(v), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 702;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(count_zeros(v), 10);
        set(v, 0);
        assert_eq(count_zeros(v), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 717;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{37};
        assert_eq(leading_zeros(v), 37);
        set(v, 27);
        assert_eq(leading_zeros(v), 27);
        auto w = BitVector<u8>::ones(10);
        assert_eq(leading_zeros(w), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 740;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(27);
        assert_eq(trailing_zeros(v), 27);
        set(v, 0);
        assert_eq(trailing_zeros(v), 26);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 775;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(first_set(v) == std::optional<usize>{});
        set(v, 2);
        assert(first_set(v) == std::optional<usize>{2});
        set(v, 2, false);
        assert(first_set(v) == std::optional<usize>{});
        set(v, 27);
        assert(first_set(v) == std::optional<usize>{27});
        BitVector empty;
        assert(first_set(empty) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 802;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(last_set(v) == std::optional<usize>{});
        set(v, 2);
        assert(last_set(v) == std::optional<usize>{2});
        set(v, 27);
        assert(last_set(v) == std::optional<usize>{27});
        BitVector empty;
        assert(last_set(empty) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 827;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(next_set(v,0) == std::optional<usize>{});
        set(v,2);
        set(v,27);
        assert(next_set(v,0) == std::optional<usize>{2});
        assert(next_set(v,2) == std::optional<usize>{27});
        assert(next_set(v,27) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 865;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(previous_set(v,36) == std::optional<usize>{});
        set(v,2);
        set(v,27);
        assert(previous_set(v,36) == std::optional<usize>{27});
        assert(previous_set(v,27) == std::optional<usize>{2});
        assert(previous_set(v,2)  == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 908;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(first_unset(v) == std::optional<usize>{});
        set(v,2,false);
        assert(first_unset(v) == std::optional<usize>{2});
        set(v,2);
        assert(first_unset(v) == std::optional<usize>{});
        set(v,27,false);
        assert(first_unset(v) == std::optional<usize>{27});
        BitVector empty;
        assert(empty.first_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 941;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(last_unset(v) == std::optional<usize>{});
        set(v,2, false);
        assert(last_unset(v) == std::optional<usize>{2});
        set(v,2);
        assert(last_unset(v) == std::optional<usize>{});
        set(v,27, false);
        assert(last_unset(v) == std::optional<usize>{27});
        BitVector empty;
        assert(empty.last_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 974;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.next_unset(0) == std::optional<usize>{});
        set(v,2, false);
        set(v,27, false);
        assert(v.next_unset(0) == std::optional<usize>{2});
        assert(v.next_unset(2) == std::optional<usize>{27});
        assert(v.next_unset(27) == std::optional<usize>{});
        BitVector empty;
        assert(empty.next_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1019;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.previous_unset(0) == std::optional<usize>{});
        set(v,2, false);
        set(v,27, false);
        assert(v.previous_unset(36) == std::optional<usize>{27});
        assert(v.previous_unset(27) == std::optional<usize>{2});
        assert(v.previous_unset(2) == std::optional<usize>{});
        BitVector empty;
        assert(empty.previous_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1075;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(10);
        for (auto&& bit : bits(u)) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1094;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        for (auto&& bit : bits(v)) bit = true;
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1110;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto indices = std::ranges::to<std::vector>(set_bits(v));
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1127;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto indices = std::ranges::to<std::vector>(unset_bits(v));
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1151;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        assert_eq(to_string(v), "1111111111");
        auto words = std::ranges::to<std::vector>(store_words(v));
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1169;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto words = to_words(v);
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1193;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        const auto v = BitVector<>::alternating(10);
        auto s = span(v, 1, 5);
        assert_eq(to_string(s), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1231;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        const auto v = BitVector<>::alternating(10);
        auto s = span(v, 1, 5);
        assert_eq(to_string(s), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1269;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto s = sub(v,1,5);
        assert_eq(to_string(s), "0101");
        s.set_all();
        assert_eq(to_string(s), "1111");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1300;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        BitVector left, right;
        split(v, 5, left, right);
        assert_eq(to_string(left), "10101");
        assert_eq(to_string(right), "01010");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1330;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto [left, right] = split(v, 5);
        assert_eq(to_string(left), "10101");
        assert_eq(to_string(right), "01010");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1351;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitVector<u16>::zeros(12);
        auto rhs = BitVector<u8>::ones(12);
        auto v = join(lhs, rhs);
        assert_eq(to_string(v), "000000000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1383;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        BitVector<u8> dst;
        riffle(v, dst);
        assert_eq(to_string(dst), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1424;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto dst = riffle(v);
        assert_eq(to_string(dst), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1451;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(to_binary_string(v), "0000000000");
        set(v, 0);
        assert_eq(to_binary_string(v), "1000000000");
        assert_eq(to_binary_string(v, ",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1502;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(to_string(v), "0000000000");
        set(v, 0);
        assert_eq(to_string(v), "1000000000");
        assert_eq(to_string(v, ",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1521;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        assert_eq(to_pretty_string(v), "[1,0,1,0,1,0,1,0,1,0]");
        BitVector empty;
        assert_eq(to_pretty_string(empty), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1552;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(to_hex_string(v0), "");
        auto v1 = BitVector<>::ones(4);
        assert_eq(to_hex_string(v1), "F");
        auto v2 = BitVector<>::ones(5);
        assert_eq(to_hex_string(v2), "F1.2");
        auto v3 = BitVector<>::alternating(8);
        assert_eq(to_binary_string(v3), "10101010");
        assert_eq(to_hex_string(v3), "AA");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1647;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(55);
        auto v = BitVector<u8>::ones(55);
        assert(u == v);
        v.set(23, false);
        assert(u != v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1678;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        v <<= 8;
        assert_eq(to_string(v), "11111111111100000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1739;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        v >>= 8;
        assert_eq(to_string(v), "00000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1801;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        auto w = v << 8;
        assert_eq(to_string(w), "11111111111100000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1822;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        auto w = v >> 8;
        assert_eq(to_string(w), "00000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1844;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 ^= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1863;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 &= ~v1;
        assert_eq(to_string(v1), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1882;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 |= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1902;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto w = ~v;
        assert_eq(to_string(w), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1922;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 ^ v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1943;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 & v2;
        assert_eq(to_string(v3), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1964;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 | v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1991;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 += ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2011;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 -= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2035;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 + v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2058;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 - v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2087;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        assert_eq(dot(v1, v1), true);
        assert_eq(dot(v1, v2), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2114;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        assert_eq(v1*v1, true);
        assert_eq(v1*v2, false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2137;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitVector<>::ones(3);
        auto rhs = BitVector<>::ones(2);
        auto result = convolve(lhs, rhs);
        assert_eq(to_string(result), "1001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "BitVector.h";
    // Run the tests ...
    header_line = 44;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(v0.size(), 0);
        BitVector<u8> v1(10);
        assert_eq(v1.size(), 10);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 57;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(v0.words(), 0);
        BitVector<u8> v1(10);
        assert_eq(v1.words(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 73;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        assert_eq(v.words(), 2);
        assert_eq(v.word(0), 0b1111'1111);
        assert_eq(v.word(1), 0b0000'0011);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 93;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        assert_eq(v.to_string(), "0000000000");
        v.set_word(1, 0b1111'1111);
        assert_eq(v.to_string(), "0000000011");
        assert_eq(v.count_ones(), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 111;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 123;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto ptr = v.store();
        assert_eq(*ptr, 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 144;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u;
        assert_eq(u.to_string(), "");
        BitVector<u8> v{10};
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 161;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u8> v{10, u8{0b0101'0101}};
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 178;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::with_capacity(10);
        assert_eq(v.size(), 0);
        assert(v.capacity() >=10);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 192;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(10);
        assert_eq(v.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 201;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVector<>::ones(10).to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 209;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::constant(10, true);
        assert_eq(v.to_string(), "1111111111");
        auto w = BitVector<>::constant(10, false);
        assert_eq(w.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 222;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVector<>::unit(10, 0).to_string(), "1000000000");
        assert_eq(BitVector<>::unit(10, 9).to_string(), "0000000001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 236;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BitVector<u8>::alternating(10).to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 245;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 s8 = 0b01010101;
        auto u = BitVector<u8>::from(s8);
        assert_eq(u.size(), 8);
        assert_eq(u.to_string(), "10101010");
        u16 s16 = 0b0101010101010101;
        auto v = BitVector<u8>::from(s16);
        assert_eq(v.size(), 16);
        assert_eq(v.to_string(), "1010101010101010");
        auto w = BitVector<u32>::from(s8);
        assert_eq(w.size(), 8);
        assert_eq(w.to_string(), "10101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 273;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::from(BitVector<u8>::ones(10));
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1111111111");
        auto w = BitVector<u8>::from(BitVector<u16>::ones(20));
        assert_eq(w.size(), 20);
        assert_eq(w.to_string(), "11111111111111111111");
        auto x = BitVector<u8>::from(BitVector<u32>::zeros(10));
        assert_eq(x.size(), 10);
        assert_eq(x.to_string(), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 297;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        auto v = BitVector<>::from(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 315;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::from(10, [](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 342;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitVector<>::random(10, 0.5, seed);
        auto v = BitVector<>::random(10, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 365;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u64 seed = 1234567890;
        auto u = BitVector<>::seeded_random(10, seed);
        auto v = BitVector<>::seeded_random(10, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 380;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::biased_random(10, 0.3);
        auto v = BitVector<>::biased_random(10, 0.3);
        assert_eq(u.size(), v.size());
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 401;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<>::from_string("0b1010_1010_10").value();
        assert_eq(v1.to_string(), "1010101010");
        auto v2 = BitVector<>::from_string("AA").value();
        assert_eq(v2.to_string(), "10101010");
        auto v3 = BitVector<>::from_string("1010'1010").value();
        assert_eq(v3.to_string(), "10101010");
        auto v4 = BitVector<>::from_string("0x1.8").value();
        assert_eq(v4.to_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 442;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::from_binary_string("0b1010'1010'10").value();
        assert_eq(v.to_string(), "1010101010");
        auto u = BitVector<u8>::from_binary_string("").value();
        assert_eq(u.to_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 477;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = gf2::BitVector<>::from_hex_string("0xAA").value();
        assert_eq(v1.to_string(), "10101010");
        auto v2 = gf2::BitVector<>::from_hex_string("0x1").value();
        assert_eq(v2.to_string(), "0001");
        auto v3 = gf2::BitVector<>::from_hex_string("0x1.8").value();
        assert_eq(v3.to_string(), "001");
        auto v4 = gf2::BitVector<>::from_hex_string("0x1.4").value();
        assert_eq(v4.to_string(), "01");
        auto v5 = gf2::BitVector<>::from_hex_string("0x1.2").value();
        assert_eq(v5.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 538;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(v0.capacity(), 0);
        BitVector<u64> v1(10);
        assert_eq(v1.capacity(), 64);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 549;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u64> v1(10);
        assert_eq(v1.remaining_capacity(), 54);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 560;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(1000);
        v.resize(15);
        v.shrink_to_fit();
        assert_eq(v.capacity(), 16);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 587;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(1000);
        v.resize(10);
        assert_eq(v.to_string(), "1111111111");
        v.resize(15);
        assert_eq(v.to_string(), "111111111100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 624;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        v.push(1);
        assert(v.to_string() == "1");
        v.push(0);
        assert(v.to_string() == "10");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 640;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        v.push(1);
        v.push(0);
        assert(v.to_string() == "10");
        auto b1 = v.pop();
        assert_eq(*b1, false);
        assert(v.to_string() == "1");
        auto b2 = v.pop();
        assert_eq(*b2, true);
        assert(v.to_string() == "");
        auto b3 = v.pop();
        assert(b3 == std::nullopt);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 670;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(4);
        u16 src = 0b1010101010101010;
        v.append(src);
        assert_eq(v.to_string(), "11110101010101010101");
        auto w = BitVector<u32>::ones(4);
        w.append(src);
        assert_eq(w.to_string(), "11110101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 694;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        auto w = BitVector<u16>::ones(10);
        v.append(w);
        assert_eq(v.size(), 20);
        assert_eq(v.to_string(), "00000000001111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 712;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVector v;
        v.append(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 733;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        v.append_digit('A', 16);
        assert_eq(v.to_string(), "1010");
        v.append_digit('X', 16);
        assert_eq(v.to_string(), "1010");
        v.append_digit('1', 8);
        assert_eq(v.to_string(), "1010001");
        v.append_digit('1', 4);
        assert_eq(v.to_string(), "101000101");
        v.append_digit('1', 2);
        assert_eq(v.to_string(), "1010001011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 771;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        v.append_hex_digit('F');
        assert_eq(v.to_string(), "1111");
        v.append_hex_digit('X');
        assert_eq(v.to_string(), "1111");
        v.append_hex_digit('1');
        assert_eq(v.to_string(), "11110001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 805;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto w = v.split_off(5);
        assert_eq(v.to_string(), "10101");
        assert_eq(w.to_string(), "01010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 826;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        BitVector dst;
        v.split_off(5, dst);
        assert_eq(v.to_string(), "10101");
        assert_eq(dst.to_string(), "01010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 849;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(22);
        auto x16 = v.split_off_unsigned<u16>();
        assert_eq(*x16, 0b1111'1111'1111'1111);
        assert_eq(v.size(), 6);
        assert_eq(v.to_string(), "111111");
        auto w = BitVector<u8>::alternating(24);
        auto x8 = w.split_off_unsigned<u8>();
        assert_eq(*x8, 0b0101'0101);
        assert_eq(w.size(), 16);
        assert_eq(w.to_string(), "1010101010101010");
        w.append(*x8);
        assert_eq(w.to_string(), "101010101010101010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 916;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 930;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert(v[2] == false);
        v[2] = true;
        assert(v[2] == true);
        assert(v.to_string() == "0010000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 945;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(v.front(), true);
        v.set_all(false);
        assert_eq(v.front(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 959;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(v.back(), true);
        v.set_all(false);
        assert_eq(v.back(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 978;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.get(0), false);
        v.set(0);
        assert_eq(v.get(0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1000;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        v[2] = true;
        assert(v.to_string() == "0010000000");
        auto w = BitVector<>::ones(10);
        v[3] = w[3];
        assert(v.to_string() == "0011000000");
        v[4] |= w[4];
        assert(v.to_string() == "0011100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1018;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        v.flip(0);
        assert_eq(v.to_string(), "0111111111");
        v.flip(1);
        assert_eq(v.to_string(), "0011111111");
        v.flip(9);
        assert_eq(v.to_string(), "0011111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1038;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(10);
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "0100000000");
        v.swap(0, 1);
        assert_eq(v.to_string(), "1000000000");
        v.swap(0, 9);
        assert_eq(v.to_string(), "0000000001");
        v.swap(0, 9);
        assert_eq(v.to_string(), "1000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1063;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        assert_eq(v.is_empty(), true);
        BitVector u{10};
        assert_eq(u.is_empty(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1076;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.any(), false);
        v.set(0);
        assert_eq(v.any(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1089;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        assert_eq(v.all(), false);
        v.set(0);
        v.set(1);
        v.set(2);
        assert_eq(v.all(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1104;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.none(), true);
        v.set(0);
        assert_eq(v.none(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1121;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        v.set_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1134;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        v.flip_all();
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1160;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u8> v{16};
        u16 src = 0b1010101010101010;
        v.copy(src);
        assert_eq(v.to_string(), "0101010101010101");
        BitVector<u32> w{16};
        w.copy(src);
        assert_eq(w.to_string(), "0101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1188;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u64>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        v.copy(BitVector<u8>::alternating(10));
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1210;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVector v{10};
        v.copy(src);
        assert_eq(v.to_string(), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1229;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        v.copy([](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1250;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10}, v{10};
        u64 seed = 1234567890;
        u.fill_random(0.5, seed);
        v.fill_random(0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1269;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.count_ones(), 0);
        v.set(0);
        assert_eq(v.count_ones(), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1280;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.count_zeros(), 10);
        v.set(0);
        assert_eq(v.count_zeros(), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1291;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{37};
        assert_eq(v.leading_zeros(), 37);
        v.set(27);
        assert_eq(v.leading_zeros(), 27);
        auto w = BitVector<u8>::ones(10);
        assert_eq(w.leading_zeros(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1304;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(27);
        assert_eq(v.trailing_zeros(), 27);
        v.set(0);
        assert_eq(v.trailing_zeros(), 26);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1319;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(v.first_set() == std::optional<usize>{});
        v.set(2);
        assert(v.first_set() == std::optional<usize>{2});
        v.set(2, false);
        assert(v.first_set() == std::optional<usize>{});
        v.set(27);
        assert(v.first_set() == std::optional<usize>{27});
        BitVector empty;
        assert(empty.first_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1336;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(v.last_set() == std::optional<usize>{});
        v.set(2);
        assert(v.last_set() == std::optional<usize>{2});
        v.set(27);
        assert(v.last_set() == std::optional<usize>{27});
        BitVector empty;
        assert(empty.last_set() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1351;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(v.next_set(0) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.next_set(0) == std::optional<usize>{2});
        assert(v.next_set(2) == std::optional<usize>{27});
        assert(v.next_set(27) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1365;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(v.previous_set(36) == std::optional<usize>{});
        v.set(2);
        v.set(27);
        assert(v.previous_set(36) == std::optional<usize>{27});
        assert(v.previous_set(27) == std::optional<usize>{2});
        assert(v.previous_set(2)  == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1383;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.first_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.first_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.first_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.first_unset() == std::optional<usize>{27});
        BitVector empty;
        assert(empty.first_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1400;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.last_unset() == std::optional<usize>{});
        v.set(2, false);
        assert(v.last_unset() == std::optional<usize>{2});
        v.set(2);
        assert(v.last_unset() == std::optional<usize>{});
        v.set(27, false);
        assert(v.last_unset() == std::optional<usize>{27});
        BitVector empty;
        assert(empty.last_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1417;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.next_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.next_unset(0) == std::optional<usize>{2});
        assert(v.next_unset(2) == std::optional<usize>{27});
        assert(v.next_unset(27) == std::optional<usize>{});
        BitVector empty;
        assert(empty.next_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1434;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.previous_unset(0) == std::optional<usize>{});
        v.set(2, false);
        v.set(27, false);
        assert(v.previous_unset(36) == std::optional<usize>{27});
        assert(v.previous_unset(27) == std::optional<usize>{2});
        assert(v.previous_unset(2) == std::optional<usize>{});
        BitVector empty;
        assert(empty.previous_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1460;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(10);
        for (auto&& bit : u.bits()) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1475;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        for (auto&& bit : v.bits()) bit = true;
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1487;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.set_bits());
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1500;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.unset_bits());
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1514;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        auto words = std::ranges::to<std::vector>(v.store_words());
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1527;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto words = v.to_words();
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1546;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1561;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto s = v.span(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1111101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1581;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto s = v.sub(1,5);
        assert_eq(s.to_string(), "0101");
        s.set_all();
        assert_eq(s.to_string(), "1111");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1609;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        BitVector left, right;
        v.split_at(5, left, right);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1632;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto [left, right] = v.split_at(5);
        assert_eq(left.to_string(), "10101");
        assert_eq(right.to_string(), "01010");
        assert_eq(v.to_string(), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1653;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        BitVector<u8> dst;
        v.riffled(dst);
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1668;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto dst = v.riffled();
        assert_eq(dst.to_string(), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1688;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.to_binary_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_binary_string(), "1000000000");
        assert_eq(v.to_binary_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1709;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.to_string(), "0000000000");
        v.set(0);
        assert_eq(v.to_string(), "1000000000");
        assert_eq(v.to_string(",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1726;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        assert_eq(v.to_pretty_string(), "[1,0,1,0,1,0,1,0,1,0]");
        BitVector empty;
        assert_eq(empty.to_pretty_string(), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1753;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(v0.to_hex_string(), "");
        auto v1 = BitVector<>::ones(4);
        assert_eq(v1.to_hex_string(), "F");
        auto v2 = BitVector<>::ones(5);
        assert_eq(v2.to_hex_string(), "F1.2");
        auto v3 = BitVector<>::alternating(8);
        assert_eq(v3.to_binary_string(), "10101010");
        assert_eq(v3.to_hex_string(), "AA");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "Iterators.h";
    // Run the tests ...
    header_line = 31;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(v.to_string(), "0000000000");
        for (auto&& bit : v.bits()) bit = true;
        assert_eq(v.to_string(), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 114;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.set_bits());
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 196;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(v.to_string(), "1010101010");
        auto indices = std::ranges::to<std::vector>(v.unset_bits());
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 278;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        assert_eq(v.to_string(), "1111111111");
        auto words = std::ranges::to<std::vector>(v.store_words());
        assert_eq(words, (std::vector<std::uint8_t>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "Unsigned.h";
    // Run the tests ...
    header_line = 51;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(BITS<u16>, 16);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 60;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ZERO<u8>, 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 69;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ONE<u8>, 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 78;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(MAX<u8>, 255);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 87;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(ALTERNATING<u8>, 0b0101'0101);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 103;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(with_set_bits<u8>(0, 0), 0b0000'0000);
        assert_eq(with_set_bits<u8>(0, 1), 0b0000'0001);
        assert_eq(with_set_bits<u8>(0, 2), 0b0000'0011);
        assert_eq(with_set_bits<u8>(1, 3), 0b0000'0110);
        assert_eq(with_set_bits<u8>(0, 8), 0b1111'1111);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 124;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(with_unset_bits<u8>(0, 0), 0b1111'1111);
        assert_eq(with_unset_bits<u8>(0, 1), 0b1111'1110);
        assert_eq(with_unset_bits<u8>(0, 2), 0b1111'1100);
        assert_eq(with_unset_bits<u8>(1, 3), 0b1111'1001);
        assert_eq(with_unset_bits<u8>(0, 8), 0b0000'0000);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 150;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b0000'0000;
        set_bits(word, 1, 3);
        assert_eq(word, 0b0000'0110);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 169;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        reset_bits(word, 1, 3);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 192;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b0000'0000;
        set_except_bits(word, 1, 3);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 215;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        reset_except_bits(word, 1, 3);
        assert_eq(word, 0b000'0110);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 237;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u32  n32 = 0x12345678;
        auto m32 = reverse_bits(n32);
        assert_eq(m32, 0x1e6a2c48);
        u64  n64 = 0x1234567890123456;
        auto m64 = reverse_bits(n64);
        assert_eq(m64, 0x6a2c48091e6a2c48);
        u16 zero = 0;
        assert_eq(reverse_bits(zero), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 265;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        replace_bits(word, 1, 3, 0b0000'0000);
        assert_eq(word, 0b1111'1001);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 294;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        u8 word = 0b1111'1111;
        auto [lo, hi] = riffle(word);
        assert_eq(lo, 0b0101'0101);
        assert_eq(hi, 0b0101'0101);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 327;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(count_ones(u8{0b0000'0000}), 0);
        assert_eq(count_ones(u8{0b0000'0001}), 1);
        assert_eq(count_ones(u8{0b0000'0010}), 1);
        assert_eq(count_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 342;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(count_zeros(u8{0b0000'0000}), 8);
        assert_eq(count_zeros(u8{0b0000'0001}), 7);
        assert_eq(count_zeros(u8{0b0000'0010}), 7);
        assert_eq(count_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 357;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(trailing_zeros(u8{0b0000'0000}), 8);
        assert_eq(trailing_zeros(u8{0b0000'0001}), 0);
        assert_eq(trailing_zeros(u8{0b0000'0010}), 1);
        assert_eq(trailing_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 372;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(leading_zeros(u8{0b0000'0000}), 8);
        assert_eq(leading_zeros(u8{0b0000'0001}), 7);
        assert_eq(leading_zeros(u8{0b0000'0010}), 6);
        assert_eq(leading_zeros(u8{0b1111'1111}), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 387;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(trailing_ones(u8{0b0000'0000}), 0);
        assert_eq(trailing_ones(u8{0b0000'0001}), 1);
        assert_eq(trailing_ones(u8{0b0000'0010}), 0);
        assert_eq(trailing_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 402;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(leading_ones(u8{0b0000'0000}), 0);
        assert_eq(leading_ones(u8{0b0000'0001}), 0);
        assert_eq(leading_ones(u8{0b1000'0010}), 1);
        assert_eq(leading_ones(u8{0b1111'1111}), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 417;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(lowest_set_bit(u8{0b0000'0000}) == std::optional<u8>{});
        assert(lowest_set_bit(u8{0b0000'0001}) == std::optional<u8>{0});
        assert(lowest_set_bit(u8{0b0000'0010}) == std::optional<u8>{1});
        assert(lowest_set_bit(u8{0b1000'0000}) == std::optional<u8>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 437;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(highest_set_bit(u8{0b0000'0000}) == std::optional<u8>{});
        assert(highest_set_bit(u8{0b0000'0001}) == std::optional<u8>{0});
        assert(highest_set_bit(u8{0b0000'0010}) == std::optional<u8>{1});
        assert(highest_set_bit(u8{0b1000'0000}) == std::optional<u8>{7});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 453;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(lowest_unset_bit(u8{0b1111'1111}) == std::optional<u8>{});
        assert(lowest_unset_bit(u8{0b0001'1000}) == std::optional<u8>{0});
        assert(lowest_unset_bit(u8{0b0000'1001}) == std::optional<u8>{1});
        assert(lowest_unset_bit(u8{0b1000'1111}) == std::optional<u8>{4});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 469;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(highest_unset_bit(u8{0b1111'1111}) == std::optional<u8>{});
        assert(highest_unset_bit(u8{0b1100'0000}) == std::optional<u8>{5});
        assert(highest_unset_bit(u8{0b0001'0011}) == std::optional<u8>{7});
        assert(highest_unset_bit(u8{0b1000'0000}) == std::optional<u8>{6});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 489;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(to_binary_string(u8{0b0000'0011}), "00000011");
        assert_eq(to_binary_string(u8{0b1111'1111}), "11111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 504;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(to_hex_string(u8{0b0000'0011}), "03");
        assert_eq(to_hex_string(u8{0b1111'1111}), "FF");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 523;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(words_needed<u8>(0), 0);
        assert_eq(words_needed<u8>(8), 1);
        assert_eq(words_needed<u8>(19), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 540;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(word_index<u8>(0), 0);
        assert_eq(word_index<u8>(8), 1);
        assert_eq(word_index<u8>(19), 2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 556;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(bit_offset<u8>(0), 0);
        assert_eq(bit_offset<u8>(8), 0);
        assert_eq(bit_offset<u8>(19), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 573;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(index_and_offset<u8>(0), (std::pair{0, 0}));
        assert_eq(index_and_offset<u8>(8), (std::pair{1, 0}));
        assert_eq(index_and_offset<u8>(19), (std::pair{2, 3}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 590;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert_eq(index_and_mask<u8>(0), (std::pair{0, 1}));
        assert_eq(index_and_mask<u8>(8), (std::pair{1, 1}));
        assert_eq(index_and_mask<u8>(19), (std::pair{2, 1 << 3}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    if (fails == 0) {
        std::println(stderr, "Total tests: {}, all PASSED", test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Total tests: {}, PASSED: {}, FAILED: {}", test_count, test_count - fails, fails);
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}