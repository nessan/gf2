<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: The &lt;tt&gt;BitVec&lt;/tt&gt; Class</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2pages_2BitVec.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The <span class="tt">BitVec</span> Class </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="the-bitvec-class"></a></p>
<h1 class="doxsection"><a class="anchor" id="introduction-2"></a>
Introduction</h1>
<p>A <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> is a dynamically sized vector of bit elements stored compactly in an array of unsigned integer words.</p>
<p>The class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, which provides a rich API for manipulating the bits in the vector. The free functions defined for that concept are also pulled into the class as member functions. For example, if <span class="tt">v</span> is a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span>, you can call <span class="tt">v.count_ones()</span> to count the number of set bits in the vector instead of calling the free function <span class="tt">gf2::count_ones(v)</span>, though both forms are valid.</p>
<p>In addition to the many methods that mirror a corresponding utility function defined in <span class="tt"><a class="el" href="BitStore_8h.html" title="A concept for types that can access individual bits packed into contiguous primitive unsigned words,...">BitStore.h</a></span>, the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> class provides methods to construct bit-vectors in various ways, methods to resize a vector, and methods to append or remove elements from the end of a vector.</p>
<p>In mathematical terms, a bit-vector is a vector over <a href="https://en.wikipedia.org/wiki/GF(2)">GF2</a>, the simplest <a href="https://en.wikipedia.org/wiki/Galois_field">Galois-Field</a> with just two elements, usually denoted 0 &amp; 1, as the booleans true &amp; false, or as the bits set &amp; unset. Arithmetic over GF(2) is mod 2, so addition/subtraction becomes the <span class="tt">XOR</span> operation while multiplication/division becomes <span class="tt">AND</span>.</p>
<dl class="section note"><dt>Note</dt><dd>Operations on and between bit-vectors and other objects in the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> library are implemented using bitwise operations on whole underlying words at a time. These operations are highly optimised in modern CPUs, allowing for fast computation even on large bit-vectors. It also means we never have to worry about overflows or carries as we would with normal integer arithmetic.</dd></dl>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> class is a hybrid between a <a href="https://en.cppreference.com/w/cpp/container/vector"><span class="tt">std::vector</span></a> and a <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a>, along with extra mathematical features to facilitate numerical work, and in particular, linear algebra.</p>
<p>One can dynamically resize a <span class="tt">BitVec</span> as needed. Contrast this to a <span class="tt">std::bitset</span>, which has a <em>fixed</em> size determined at compile time. <em>Boost</em> provides the <a href="https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html"><span class="tt">boost::dynamic_bitset</span></a> class, which allows runtime resizing, as its name suggests. However, neither class supports algebraic operations.</p>
<p>It is worth noting that a <span class="tt">BitVec</span> is printed in <em>vector order</em>. For example, a bit-vector of size four will print as \(v_0 v_1 v_2 v_3\) with the elements in increasing index order, so the least significant vector element, \(v_0\), comes <b>first</b> on the <em>left</em>. Contrast that to a <span class="tt">std::bitset</span>, which always prints in <em>bit-order</em>. The equivalent <span class="tt">std::bitset</span> with four elements prints as \(b_3 b_2 b_1 b_0\) with the least significant bit \(b_0\) printed <b>last</b> on the <em>right</em>.</p>
<p>Of course, for many applications, printing in <em>bit-order</em> makes perfect sense. A bit-vector of four elements initialised to <span class="tt">0x1</span> will print <span class="tt">1000</span>. A <span class="tt">std::bitset</span> prints the same value as <span class="tt">0001</span>, which will be more natural in some settings.</p>
<p>However, our main aim is numerical work, where vector order is more natural. In particular, bit-order is unnatural for <em>matrices</em> over GF(2). It is too confusing to print a matrix in any order other than the one where the (0,0) element is at the top left, and proceed from there.</p>
<h1 class="doxsection"><a class="anchor" id="declaration-1"></a>
Declaration</h1>
<p>The declaration of the bit-vector class looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;Un<span class="keywordtype">signed</span> Word = usize&gt;</div>
<div class="line"><span class="keyword">class </span>BitVec {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>word_type = Word;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The <span class="tt">Word</span> template parameter specifies the underlying <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">gf2::Unsigned</a></span> integer type used to hold the vector's bits, and the default is usually the most efficient type for the target platform. On most modern platforms, that <a href="https://en.cppreference.com/w/cpp/types/size_t"><span class="tt">usize</span></a> will be a 64-bit unsigned integer. The choice of underlying word type is exposed via the public <span class="tt">word_type</span> type alias as required by the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept.</p>
<p>If your application calls for a vast number of bit-vectors with only a few bits each, you might consider using <span class="tt">std::uint8_t</span> as the <span class="tt">Word</span> type to save memory.</p>
<dl class="section note"><dt>Note</dt><dd>If you peruse the header files, you may notice that many of the <a href="https://nessan.github.io/doxytest/">doctests</a> in the library use 8-bit underlying words. The reason is we want to exercise the various functions across word boundaries for modest, easily readable bit-stores.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="methods-overview-1"></a>
Methods Overview</h1>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> class provides a rich set of methods for constructing, querying, and manipulating, bit-vectors. Here is an overview of the main methods available in the class:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-concept">Concept Methods</a>  </td><td class="markdownTableBodyNone">Methods needed to satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-constructors">Constructors</a>  </td><td class="markdownTableBodyNone">Methods to create bit-vectors of various sizes and initial values.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-factory">Factory Constructors</a>  </td><td class="markdownTableBodyNone">Class methods to create bit-vectors with specific properties or fills.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-strings">Construction from Strings</a>  </td><td class="markdownTableBodyNone">Class methods to create bit-vectors from string representations.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-resizing">Resizing</a>  </td><td class="markdownTableBodyNone">Methods to query and manipulate the size and capacity of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-append">Appending Elements</a>  </td><td class="markdownTableBodyNone">Methods to append bits from various sources to the end of a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-remove">Removing Elements</a>  </td><td class="markdownTableBodyNone">Methods to remove bits from the end of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-bit-access">Bit Access</a>  </td><td class="markdownTableBodyNone">Methods to access individual bit elements in a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-queries">Queries</a>  </td><td class="markdownTableBodyNone">Methods to query the overall state of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-mutators">Mutators</a>  </td><td class="markdownTableBodyNone">Methods to mutate the overall state of a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-fills">Fills</a>  </td><td class="markdownTableBodyNone">Methods to fill a bit-vector from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-span">Spans</a>  </td><td class="markdownTableBodyNone">Methods to create non-owning views over a part of a bit-vector &mdash; <em>bit-spans</em>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-sub-vectors">Sub-vectors</a>  </td><td class="markdownTableBodyNone">Methods to pull out a clone of piece of a bit-vector as new bit-vectors  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-riffling">Riffling</a>  </td><td class="markdownTableBodyNone">Methods to create vectors that copy a bit-vector with interleaved zeros.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-indices">Set/Unset Indices</a>  </td><td class="markdownTableBodyNone">Methods to find the indices of set &amp; unset bits in a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#vec-iterators">Iterators</a>  </td><td class="markdownTableBodyNone">Methods to create various iterators over a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#vec-stringification">Stringification</a>  </td><td class="markdownTableBodyNone">Methods to create string representations of a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-vectors for content equality.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-vectors left or right.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-vectors.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-concept"></a>
Concept Methods</h1>
<p>Bit-vectors satisfy the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept and forwards many method calls to free functions defined for that concept. The concept requires us to provide the following methods:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">gf2::BitVec::size</a></span>  </td><td class="markdownTableBodyNone">Returns the number of bit elements in the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abfc4befce710a6af1421985116e96633" title="Returns a const pointer to the underlying store of words .">gf2::BitVec::store</a> const</span>  </td><td class="markdownTableBodyNone">Returns a const pointer to the first <span class="tt">Word</span> holding bits in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abfc4befce710a6af1421985116e96633" title="Returns a const pointer to the underlying store of words .">gf2::BitVec::store</a></span>  </td><td class="markdownTableBodyNone">Returns a non-const pointer to the first <span class="tt">Word</span> holding bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a5aeba2cd4fa570743723c3ef3bbd8ac4" title="Returns the offset (in bits) of the first bit in the store within the first word.">gf2::BitVec::offset</a></span>  </td><td class="markdownTableBodyNone">For bit-vectors, this always returns 0.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a87103730819743af8ff170fb5ca13185" title="Returns the number of words in the bit-vector&#39;s underlying word store.">gf2::BitVec::words</a></span>  </td><td class="markdownTableBodyNone">Returns the number of <span class="tt">Word</span>s needed to vector those elements.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a1d6e74f511ed45d28b2b918107eff1ef" title="Returns word i from the bit-vector&#39;s underlying word store.">gf2::BitVec::word</a></span>  </td><td class="markdownTableBodyNone">Returns the word for the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#acb878752cc181ef833e9dafbb059cb8c" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVec::set_word</a></span>  </td><td class="markdownTableBodyNone">Sets the word at the passed index to the passed value.  </td></tr>
</table>
<p>These methods are trivial to implement for bit-vectors.</p>
<p>The one place where care is needed is in the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#acb878752cc181ef833e9dafbb059cb8c" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVec::set_word</a></span> method, which must ensure that any bits beyond the size of the bit-vector remain set to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>While the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abfc4befce710a6af1421985116e96633" title="Returns a const pointer to the underlying store of words .">gf2::BitVec::store</a></span> method provides write access to the underlying words, you must be careful when modifying them directly. You must ensure that any bits beyond the bit-vector's size remain zero. The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#acb878752cc181ef833e9dafbb059cb8c" title="Sets word i in the bit-vector&#39;s underlying word store to value (masked if necessary).">gf2::BitVec::set_word</a></span> method takes care of this for you, so prefer using that method when possible.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-constructors"></a>
Constructors</h1>
<p>The default constructor for a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> creates an <em>empty</em> bit-vector with zero size. You can also create a bit-vector of a given size using the following constructors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec(usize)</a></span>  </td><td class="markdownTableBodyNone">Constructs a bit-vector of the given length where all the elements are zero.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec(usize, Word)</a></span>  </td><td class="markdownTableBodyNone">Constructs a bit-vector by repeatedly copying the bits from the <span class="tt">Word</span>  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-factory"></a>
Factory Constructors</h1>
<p>There are also many static factory construction functions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a89d721629c0bd3546fc77a1448a3185c" title="Factory method to construct an empty bit-vector with at least the specified capacity.">gf2::BitVec::with_capacity</a></span>  </td><td class="markdownTableBodyNone">Returns a zero-sized bit-vector that can add some elements without any extra allocations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a9cbdc533df0b2efeca27daaee792b081" title="Factory method to generate a bit-vector of length n where the elements are all 0.">gf2::BitVec::zeros</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are 0.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abe88a62254e18559eaa3a5bdc8eec2c7" title="Factory method to generate a bit-vector of length n where the elements are all 1.">gf2::BitVec::ones</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are 1.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a703114f6dcdfbe1bb7fded1650c31e29" title="Factory method to generate a bit-vector of length n where the elements are set to value.">gf2::BitVec::constant</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are whatever is passed as a <span class="tt">value</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#af8291af2e5ead48379b0ab5eeee87ef8" title="Factory method to generate a &quot;unit&quot; bit-vector of length n where only element i is set.">gf2::BitVec::unit</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements are zero except for a single 1.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aa2a913940a592ccc49ed6754f606c411" title="Factory method to generate a bit-vector of length n looking like 101010....">gf2::BitVec::alternating</a></span>  </td><td class="markdownTableBodyNone">Returns a bit-vector where all the elements follow the pattern <span class="tt">101010...</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#adff516a657e2c3f2c703fbf778572148" title="Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....">gf2::BitVec::from</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVec</span> filled with bits from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ab57ee9beea8e50d4671758c20e544215" title="Factory method to generate a bit-vector of size len where the elements are picked at random.">gf2::BitVec::random</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVec</span> with a random fill seeded from entropy.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac162f922f382c8607410e40ea3661771" title="Factory method to generate a bit-vector of size len where the elements are from independent fair coin...">gf2::BitVec::seeded_random</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">BitVec</span> with a reproducible random fill.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a0c45315e29f7cfc66e7e18d5a42f9876" title="Factory method to generate a bit-vector of size len where the elements are from independent fair coin...">gf2::BitVec::biased_random</a></span>  </td><td class="markdownTableBodyNone">Returns a random <span class="tt">BitVec</span> where you set the probability of bits being 1.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#adff516a657e2c3f2c703fbf778572148" title="Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....">gf2::BitVec::from</a></span> factory method is overloaded to allow construction from:</p>
<ul>
<li><em>Any</em> other <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> object. The source object need not share the same underlying storage type. <br  />
 This allows conversions from bit-stores based on a different word type.</li>
<li><em>Any</em> unsigned integer type, where we copy the bits corresponding to the value.<br  />
 The source type need not be the same as the underlying <span class="tt">Word</span> type used by the bit-vector. The size of the resulting vector is determined by the number of bits in the source type.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> where we copy the bits over.</li>
<li>A callable object (a function of some sort) that generates bits on demand when passed an index.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="vec-strings"></a>
Construction from Strings</h1>
<p>We can construct a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> from strings &mdash; these methods can fail, so they return a <span class="tt">std::optional&lt;<a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a>&gt;</span> and <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><span class="tt">std::nullopt</span></a> if the string cannot be parsed.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a19b6684f4fa06d3f003029850da307f1" title="Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.">gf2::BitVec::from_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from an arbitrary string.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac8baf5a5cf90bb23038a3c97b6a9686c" title="Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.">gf2::BitVec::from_binary_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from a <em>binary</em> string.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a018d880a7c150488379b03951c9fbb00" title="Factory method to construct a bit-vector from a hex string, returning std::nullopt on failure.">gf2::BitVec::from_hex_string</a></span>  </td><td class="markdownTableBodyNone">Tries to construct a bit-vector from a <em>hexadecimal</em> string.  </td></tr>
</table>
<p>Space, comma, single quote, and underscore characters are removed from the string.</p>
<p>If the string has an optional <span class="tt">"0b"</span> prefix, it is assumed to be binary. If it has an optional <span class="tt">"0x"</span> prefix, it is assumed to be hex. If there is no prefix and the string consists entirely of 0s and 1s, we assume it is binary; otherwise, we think it is hex.</p>
<dl class="section warning"><dt>Warning</dt><dd>This means the string <span class="tt">"0x11</span> is interpreted as the bit-vector of size 8 <span class="tt">"11110001"</span>, whereas the same string without a prefix, <span class="tt">"11"</span> is interpreted as the bit-vector of size 2 <span class="tt">"11"</span>. To avoid any ambiguity, it is best to use a prefix.</dd></dl>
<p>See the <a class="el" href="md_docs_2pages_2BitStore.html#string-encodings">string-encodings</a> section in the <span class="tt">BitStore</span> documentation for more details on the accepted string formats.</p>
<h1 class="doxsection"><a class="anchor" id="vec-resizing"></a>
Resizing</h1>
<p>We have methods to query and manipulate the size and capacity of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">gf2::BitVec::size</a></span>  </td><td class="markdownTableBodyNone">Returns the number of bit elements in the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a60eeedc53538281d5de6cc5cf556833b" title="Returns the current capacity of the bit-vector.">gf2::BitVec::capacity</a></span>  </td><td class="markdownTableBodyNone">Returns the total number of bits the vector can hold without allocating more memory.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a9cea0afd5df1aa626b1319c4897ac970" title="Returns the number of additional elements we can store in the bit-vector without reallocating.">gf2::BitVec::remaining_capacity</a></span>  </td><td class="markdownTableBodyNone">Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a86c9723397a5256e234fe7f9cebda6df" title="Shrinks the bit-vector&#39;s capacity as much as possible.">gf2::BitVec::shrink_to_fit</a></span>  </td><td class="markdownTableBodyNone">Tries to shrink the vector's capacity as much as possible.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac38c66028b0aa20333f1a26715c2aa5f" title="Removes all elements from the bit-vector so size()==0.">gf2::BitVec::clear</a></span>  </td><td class="markdownTableBodyNone">Sets the <span class="tt">size()</span> to zero. Leaves the capacity unaltered.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abac2ae23aebeffc85bce13f6e0528783" title="Resize the bit-vector so that its size() is n.">gf2::BitVec::resize</a></span>  </td><td class="markdownTableBodyNone">Resizes the bit-vector, either adding zeros, or truncating existing elements.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2a317450b6723ee4c8b00296966d14e3" title="Sets any unused bits in the last occupied word to 0.">gf2::BitVec::clean</a></span>  </td><td class="markdownTableBodyNone">Sets any unused bits in the <em>last</em> occupied word to 0.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2a317450b6723ee4c8b00296966d14e3" title="Sets any unused bits in the last occupied word to 0.">gf2::BitVec::clean</a></span> method is primarily used internally in the library.</p>
<h1 class="doxsection"><a class="anchor" id="vec-append"></a>
Appending Elements</h1>
<p>We have methods to append elements from various sources to the end of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a5843880584a61949af70e645f0db7d14" title="Pushes a single bit b onto the bit-vector.">gf2::BitVec::push</a></span>  </td><td class="markdownTableBodyNone">Pushes a single bit (0 or 1) onto the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#af9ff9479a5511c5c0725cb18bcef5b7a" title="Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...">gf2::BitVec::append</a></span>  </td><td class="markdownTableBodyNone">Appends bits from various sources to the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a3c7e98e4cae78d02f32dd8ea12c1eaf1" title="Appends a single character c onto the end of bit-vector and returns this for chaining.">gf2::BitVec::append_digit</a></span>  </td><td class="markdownTableBodyNone">Appends a "character's" worth of bits to the end of the bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#adea51e74e43feea1473e37e8ca487cb1" title="Appends a single hex digit character c onto the end of bit-vector and returns this for chaining.">gf2::BitVec::append_hex_digit</a></span>  </td><td class="markdownTableBodyNone">Appends four bits from a "hex-character" to the end of the bit-vector.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#af9ff9479a5511c5c0725cb18bcef5b7a" title="Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...">gf2::BitVec::append</a></span> method is overloaded to allow appending bits from:</p>
<ul>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> where we append the bits to the end of the bit-vector.</li>
<li><em>Any</em> unsigned integer type, where we append the bits corresponding to the value.<br  />
 The type need not be the same as the underlying <span class="tt">Word</span> type used by the bit-vector.</li>
<li><em>Any</em> other <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> object, which need not share the same underlying <span class="tt">Word</span> storage type.</li>
</ul>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a3c7e98e4cae78d02f32dd8ea12c1eaf1" title="Appends a single character c onto the end of bit-vector and returns this for chaining.">gf2::BitVec::append_digit</a></span> method appends bits from a character representing a digit in one of the bases 2, 4, 8, or 16. It does nothing if it fails to parse the character.</p>
<h1 class="doxsection"><a class="anchor" id="vec-remove"></a>
Removing Elements</h1>
<p>We have methods to remove elements from the end of a bit-vector:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Name  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a7ae048f5abad05cf4e62a3a36338a0cc" title="Removes the last bit from the bit-vector and returns it or std::nullopt if the bit-vector is empty.">gf2::BitVec::pop</a></span>  </td><td class="markdownTableBodyNone">Removes the last bit from the bit-vector and returns it.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ad2b7eb7f8f39597fe4ac171e9c6d3d27" title="Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or s...">gf2::BitVec::split_off_unsigned</a></span>  </td><td class="markdownTableBodyNone">Removes a single arbitrary-sized unsigned integer off the end of the bit-vector and returns it.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aa1ac4a0001c584bf0f384febd3ee3cc6" title="Splits a bit-vector into two at the given index, returning a new BitVec.">gf2::BitVec::split_off</a></span>  </td><td class="markdownTableBodyNone">Splits a bit-vector into two at a given index  </td></tr>
</table>
<p>The first two methods return the removed elements as a <a href="https://en.cppreference.com/w/cpp/utility/optional"><span class="tt">std::optional</span></a>, and as a <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><span class="tt">std::nullopt</span></a> if the vector is empty.</p>
<p>The two <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aa1ac4a0001c584bf0f384febd3ee3cc6" title="Splits a bit-vector into two at the given index, returning a new BitVec.">gf2::BitVec::split_off</a></span> methods complement the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aad2cdea9a00459c91c7183b3ac190712" title="Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVec::split_at</a></span> methods. These versions change the size of the bit-vector <em>in place</em>.</p>
<h1 class="doxsection"><a class="anchor" id="vec-bit-access"></a>
Bit Access</h1>
<p>The following methods provide access to individual bit elements in the bit-vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac682031cf75b027bc7ab6a54f767f819" title="Returns true if the bit at the given index i is set, false otherwise.">gf2::BitVec::get</a></span>  </td><td class="markdownTableBodyNone">Returns the value of a single bit element as a read-only boolean.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2d98eb19ca984d29e87fd750c2768f75" title="Returns the boolean value of the bit element i.">gf2::BitVec::operator[]()</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt">bool</span> in the const case and a <span class="tt">BitRef</span> with read-write access to a bit element in the non-const version.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#acd71df2577df7b16357fcaa6eeb1a24d" title="Returns true if the first bit element is set, false otherwise.">gf2::BitVec::front</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the first element in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aacc24b0f55492047c6765d643208ef48" title="Returns true if the last bit element is set, false otherwise.">gf2::BitVec::back</a></span>  </td><td class="markdownTableBodyNone">Returns the value of the last element in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a96e7eb01840c25b04c77e737d3629ed4" title="Sets the bit-element i to the specified boolean value &amp; returns this for chaining....">gf2::BitVec::set</a></span>  </td><td class="markdownTableBodyNone">Sets a bit to the given boolean value which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac5f4a8bd9959119bbb1e3c36f11a0bb5" title="Flips the value of the bit-element i and returns this for chaining.">gf2::BitVec::flip</a></span>  </td><td class="markdownTableBodyNone">Flips the value of the bit element at a given index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ae5b995b704e31fedcf979c57d470dfb8" title="Swaps the bits in the bit-store at indices i0 and i1 and returns this for chaining.">gf2::BitVec::swap</a></span>  </td><td class="markdownTableBodyNone">Swaps the values of bit elements at locations <span class="tt">i</span> and <span class="tt">j</span>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You can set the <span class="tt">DEBUG</span> flag at compile time to enable bounds checks on the index arguments.</dd></dl>
<p>The non-const version of <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2d98eb19ca984d29e87fd750c2768f75" title="Returns the boolean value of the bit element i.">gf2::BitVec::operator[]()</a></span> returns a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">gf2::BitRef</a></span>, which is "reference" to an individual bit in the vector. It is automatically converted to a boolean on reads, but it also allows writes, which means you can write natural-looking single-bit assignments:</p>
<div class="fragment"><div class="line">v[12] = <span class="keyword">true</span>;</div>
</div><!-- fragment --><p>This is equivalent to calling <span class="tt">v.set(12, true);</span>.</p>
<h1 class="doxsection"><a class="anchor" id="vec-queries"></a>
Queries</h1>
<p>The following methods let you query the overall state of a bit-vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a24e0f0c5127892b1f84e8f46260bd331" title="Returns true if the store is empty, false otherwise.">gf2::BitVec::is_empty</a></span>  </td><td class="markdownTableBodyNone">Returns true if the vector is empty  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a8172a1ae6e66073e1109c045cd6b962e" title="Returns true if at least one bit in the store is set, false otherwise.">gf2::BitVec::any</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>any</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a238a8a4ef81d267c8604a5f7a7ed6132" title="Returns true if all bits in the store are set, false otherwise.">gf2::BitVec::all</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>every</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#abc79128289adb4dd8d15f536cea6fb07" title="Returns true if no bits in the store are set, false otherwise.">gf2::BitVec::none</a></span>  </td><td class="markdownTableBodyNone">Returns true if <em>no</em> bit in the vector is set.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aa9f1faf3e7550d4c3bc3baf21c209d1e" title="Returns the number of set bits in the store.">gf2::BitVec::count_ones</a></span>  </td><td class="markdownTableBodyNone">Returns the number of set bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2d2935436b7ba76295b60345db420a61" title="Returns the number of unset bits in the store.">gf2::BitVec::count_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of unset bits in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#afc84d3c4f7a8304f52b28765475c3a8b" title="Returns the number of leading zeros in the store.">gf2::BitVec::leading_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of leading unset bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a3681bc0ae42792d49670789feb85a46d" title="Returns the number of trailing zeros in the store.">gf2::BitVec::trailing_zeros</a></span>  </td><td class="markdownTableBodyNone">Returns the number of trailing unset bits in the vector.  </td></tr>
</table>
<p>These methods efficiently operate on words at a time, so they are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="vec-mutators"></a>
Mutators</h1>
<p>The following methods let you mutate the entire vector in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a188e583de62ec470801b098249a044a0" title="Sets the bits in the store to the boolean value and returns a reference to this for chaining.">gf2::BitVec::set_all</a></span>  </td><td class="markdownTableBodyNone">Sets all the bits in the vector to the passed value, which defaults to <span class="tt">true</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#afda431c0fc232ab81d98e85088cb7cc1" title="Flips the value of the bits in the store and returns a reference to this for chaining.">gf2::BitVec::flip_all</a></span>  </td><td class="markdownTableBodyNone">Flips the values of all the bits in the vector.  </td></tr>
</table>
<p>The methods operate on words at a time, so are inherently parallel.</p>
<h1 class="doxsection"><a class="anchor" id="vec-fills"></a>
Copies &amp; Fills</h1>
<p>The following methods let you populate the entire vector in a single call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a164e532a5d4d63e04261f55c86c0af34" title="Copies the bits from an unsigned integral src value and returns a reference to this for chaining.">gf2::BitVec::copy</a></span>  </td><td class="markdownTableBodyNone">Makes the bits in this vector identical to those from various sources.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a7b46b8911038a43ff97c900d83e7fbed" title="Fill the store with random bits and returns a reference to this for chaining.">gf2::BitVec::fill_random</a></span>  </td><td class="markdownTableBodyNone">Fills the vector with random 0's and 1's.  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="copies-2"></a>
Copies</h2>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a164e532a5d4d63e04261f55c86c0af34" title="Copies the bits from an unsigned integral src value and returns a reference to this for chaining.">gf2::BitVec::copy</a></span> methods support copying bits from:</p>
<ul>
<li>Another bit-store of the same size but possibly a different underlying word type.</li>
<li>A <a href="https://en.cppreference.com/w/cpp/utility/bitset"><span class="tt">std::bitset</span></a> of the same size as the vector.</li>
<li>An unsigned integer that has the same number of bits as the vector. The integer type need not be the same as the underlying <span class="tt">Word</span> used by the bit-vector.</li>
<li>A function or callable object that takes a single <span class="tt">usize</span> index argument and returns a boolean value for that index.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In each case, the size of the source and destinations must match exactly and that condition is always checked unless the <span class="tt">NDEBUG</span> flag is set at compile time. You can always use a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> to copy a subset of bits if needed.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="random-fills-2"></a>
Random Fills</h2>
<p>By default, the random fill method uses a random number generator seeded with system entropy, so the results change from run to run. You can set a specific seed to get reproducible fills.</p>
<p>The default probability that a bit is set is 50%, but you can pass a different probability in the range <span class="tt">[0.0, 1.0]</span> if desired.</p>
<h1 class="doxsection"><a class="anchor" id="vec-span"></a>
Spans</h1>
<p>The following methods let you create a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span>, which is a non-owning view of some contiguous subset of bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a16b78eb9514437fd3ba23cfc28a31f19" title="Returns an immutable bit-span encompassing the store&#39;s bits in the half-open range [begin,...">gf2::BitVec::span</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a16b78eb9514437fd3ba23cfc28a31f19" title="Returns an immutable bit-span encompassing the store&#39;s bits in the half-open range [begin,...">gf2::BitVec::span</a></span> method &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> span(usize begin, usize end);        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> span(usize begin, usize end) <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that allows modification of the bits in the specified range.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> that does not allow modification of the bits in the specified range.</li>
</ol>
<p>In both cases, the <span class="tt">begin</span> and <span class="tt">end</span> arguments define a half-open range of bits in the vector.</p>
<p>Mutability/immutability of the returned <span class="tt">BitSpan</span> is <em>deep</em>. The span's mutability reflects that of the underlying vector, so if the vector is mutable, so is the span, and vice versa.</p>
<p>This is similar to the C++20 <a href="https://en.cppreference.com/w/cpp/container/span.html"><span class="tt">std::span</span></a> class for regular data collection types.</p>
<dl class="section note"><dt>Note</dt><dd>A <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">gf2::BitSpan</a></span> also satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> concept, so you can take a span of a span.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-sub-vectors"></a>
Sub-vectors</h1>
<p>The following methods create or fill <em>independent</em> bit-vectors with copies of some contiguous subset of the bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a66f22d5eb48cbd639e080bca8cae94c3" title="Returns a clone of the elements in the half-open range [begin, end) as a new bit-vector.">gf2::BitVec::sub</a></span>  </td><td class="markdownTableBodyNone">Returns a new <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> encompassing the bits in a half-open range <span class="tt">[begin, end)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aad2cdea9a00459c91c7183b3ac190712" title="Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVec::split_at</a></span>  </td><td class="markdownTableBodyNone">Fills two bit-vectors with the bits in the ranges <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span>.  </td></tr>
</table>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aad2cdea9a00459c91c7183b3ac190712" title="Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVec::split_at</a></span> method can optionally take two pre-existing bit-vectors to fill, thereby avoiding unnecessary allocations in some iterative algorithms that repeatedly use this method.</p>
<dl class="section note"><dt>Note</dt><dd>These methods do not alter the underlying vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="vec-riffling"></a>
Riffling</h1>
<p>We have methods that can interleave (<em>riffle</em>) the bits in a vector with zeros.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a16de7a2d5ab564306a2420545696a068" title="Interleaves the bits of this bit-store with zeros storing the result into the bit-vector dst.">gf2::BitVec::riffled</a></span>  </td><td class="markdownTableBodyNone">Fills a pre-existing bit-vector with the result of riffling this vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a16de7a2d5ab564306a2420545696a068" title="Interleaves the bits of this bit-store with zeros storing the result into the bit-vector dst.">gf2::BitVec::riffled</a></span>  </td><td class="markdownTableBodyNone">Returns a new bit-vector that is this vector with its bits interleaved with zeros.  </td></tr>
</table>
<p>If the vector looks like \(v_0 v_1 v_2 \ldots v_n\), then the riffling operation produces the vector \(v_0 0 v_1 0 v_2 0 \ldots v_n\) where a zero is interleaved <em>between</em> every bit in the original vector (there is no trailing zero at the end).</p>
<p>If you think of a bit-vector as representing the coefficients of a polynomial over GF(2), then riffling corresponds to squaring that polynomial. See the documentation for <span class="tt"><a class="el" href="classgf2_1_1BitPoly.html#abfa3f15a7f16328bd2f6a4f7a770e7fd" title="Fills dst with the square of this bit-polynomial.">gf2::BitPoly::squared</a></span> for more information.</p>
<h1 class="doxsection"><a class="anchor" id="vec-indices"></a>
Set/Unset Bit Indices</h1>
<p>The following methods find the indices of set or unset bits in the vector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#ac5e0764e73414967b27a7325bcfd581a" title="Returns the index of the first set bit in the bit-store or {} if no bits are set.">gf2::BitVec::first_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first set bit in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#af193a47251b36284c46424524b904c0a" title="Returns the index of the last set bit in the bit-store or {} if no bits are set.">gf2::BitVec::last_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last set bit in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#acd6d60650865955b829d11de55199219" title="Returns the index of the next set bit after index in the store or {} if no more set bits exist.">gf2::BitVec::next_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next set bit in the vector <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aca2b1afc660ff95d8ec775cbc2689dcc" title="Returns the index of the previous set bit before index in the store or {} if there are none.">gf2::BitVec::previous_set</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous set bit in the vector <em>before</em> the passed index.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aab9955f248d42cff47e9a415db5d5f7b" title="Returns the index of the first unset bit in the bit-store or {} if no bits are unset.">gf2::BitVec::first_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the first unset bit in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a9f6b9b21f5c72b05db1739fcff74ca8f" title="Returns the index of the last unset bit in the bit-store or {} if no bits are unset.">gf2::BitVec::last_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the last unset bit in the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a01ff64db71253037f7990494190d132e" title="Returns the index of the next unset bit after index in the store or {} if no more unset bits exist.">gf2::BitVec::next_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the next unset bit in the vector <em>after</em> the passed index.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a35581d0c84cca8d385abd42e963cb69e" title="Returns the index of the previous unset bit before index in the store or {} if no more unset bits exi...">gf2::BitVec::previous_unset</a></span>  </td><td class="markdownTableBodyNone">Returns the index of the previous unset bit in the vector <em>before</em> the passed index.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="vec-iterators"></a>
Iterators</h1>
<p>The following methods create iterators for traversing the bits or underlying words in the vector:</p>
<ul>
<li>Read-only iteration through the individual bits.</li>
<li>Read-write iteration through the individual bits.</li>
<li>Read-only iteration through the indices of the set bits.</li>
<li>Read-only iteration through the indices of the unset bits.</li>
<li>Read-write iteration through the underlying vector words.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a56f5a25e9e7a389aef207416667cd606" title="Returns a const iterator over the bool values of the bits in the const bit-store.">gf2::BitVec::bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> iterator over the bits in the vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aac4e0bcb2be911a8bd590932e28fcb31" title="Returns an iterator over the indices of any set bits in the bit-store.">gf2::BitVec::set_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1SetBits.html" title="An iterator over the index locations of the set bits in a bit-store.   You get this iterator by calli...">gf2::SetBits</a></span> iterator to view the indices of all the set bits.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#afdc9bdd91c2640a600ab38540483f5ed" title="Returns an iterator over the indices of any unset bits in the bit-store.">gf2::BitVec::unset_bits</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1UnsetBits.html" title="An iterator over the index locations of the unset bits in a bit-store.  You get this iterator by call...">gf2::UnsetBits</a></span> iterator to view the indices of all the unset bits.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a59995a46ced1daef94f1f5ec3e34a97f" title="Returns a const iterator over all the words underlying the bit-store.">gf2::BitVec::store_words</a></span>  </td><td class="markdownTableBodyNone">Returns a <span class="tt"><a class="el" href="classgf2_1_1Words.html" title="An iterator over the &quot;words&quot; underlying a bit-store.  You get this iterator by calling the BitStore::...">gf2::Words</a></span> iterator to view the "words" underlying the vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a8b8920fb3faa73171f9e1e8ae8e90953" title="Returns a copy of the words underlying this bit-store.">gf2::BitVec::to_words</a></span>  </td><td class="markdownTableBodyNone">Returns a copy of the "words" underlying the bit-vector.  </td></tr>
</table>
<p>There are two overloads of the <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a56f5a25e9e7a389aef207416667cd606" title="Returns a const iterator over the bool values of the bits in the const bit-store.">gf2::BitVec::bits</a></span> method &mdash; one for <span class="tt">const</span> bit-stores and one for non-<span class="tt">const</span> bit-stores:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bits();        <span class="comment">// &lt;1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> bits() <span class="keyword">const</span>;  <span class="comment">// &lt;2&gt;</span></div>
</div><!-- fragment --><ol type="1">
<li>Returns a mutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that allows modification of the bits in the vector.</li>
<li>Returns an immutable <span class="tt"><a class="el" href="classgf2_1_1Bits.html" title="Two iterators over all the bits in a bit-store  one const and the other non-const....">gf2::Bits</a></span> that only allows one to view the bits in the vector.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="vec-stringification"></a>
Stringification</h1>
<p>The following methods return a string representation for a bit-vector. The string can be in the obvious binary format or a more compact hex format.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a2c17d2d2fb6d1f9f13828e2d8c085d4a" title="Returns a binary string representation of the store.">gf2::BitVec::to_string</a></span>  </td><td class="markdownTableBodyNone">Returns a default string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a80600ca582bde198ecea6b9d2c2dda57" title="Returns a &quot;pretty&quot; string representation of the store.">gf2::BitVec::to_pretty_string</a></span>  </td><td class="markdownTableBodyNone">Returns a "pretty" string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#af4276ca5b45a8020549679b55ce4b41c" title="Returns a binary string representation of the store.">gf2::BitVec::to_binary_string</a></span>  </td><td class="markdownTableBodyNone">Returns a binary string representation for a bit-vector.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt"><a class="el" href="classgf2_1_1BitVec.html#a795cf2bcc162662e2b1c845d87e57d55" title="Returns the &quot;hex&quot; string representation of the bits in the bit-store.">gf2::BitVec::to_hex_string</a></span>  </td><td class="markdownTableBodyNone">Returns a compact hex string representation for a bit-vector.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="other-operators-and-functions-1"></a>
Other Operators and Functions</h1>
<p>There are many operators and free functions defined for any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">gf2::BitStore</a></span> compatible class, including:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#equality-operator">Equality Operator</a>  </td><td class="markdownTableBodyNone">Operator to compare bit-stores, including bit-vectors for content equality.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-shifts">Bit Shifts</a>  </td><td class="markdownTableBodyNone">Operators to shift the bits in bit-vectors left or right.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#bit-wise-operators">Bit-wise Operators</a>  </td><td class="markdownTableBodyNone">Operators to combine bit-stores using logical operations.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#arithmetic-operators">Arithmetic Operators</a>  </td><td class="markdownTableBodyNone">Operators to add or subtract bit-stores.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_docs_2pages_2BitStore.html#other-functions">Other Functions</a>  </td><td class="markdownTableBodyNone">Dot products, convolutions, concatenation etc. for bit-vectors.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="see-also-2"></a>
See Also</h1>
<ul>
<li><span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">gf2::BitVec</a></span> reference for detailed documentation with examples for each method.</li>
<li><a class="el" href="md_docs_2pages_2BitStore.html"><span class="tt">BitStore</span></a> for the concept API shared by all bit-stores.</li>
<li><a class="el" href="md_docs_2pages_2BitArray.html"><span class="tt">BitArray</span></a> for fixed-size vectors of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitSpan.html"><span class="tt">BitSpan</span></a> for non-owning views of some of the bits in a bit-vector.</li>
<li><a class="el" href="md_docs_2pages_2BitMat.html"><span class="tt">BitMat</span></a> for matrices of bits.</li>
<li><a class="el" href="md_docs_2pages_2BitPoly.html"><span class="tt">BitPoly</span></a> for polynomials over GF(2). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
