<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacegf2.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2</div></div>
</div><!--header-->
<div class="contents">

<p>The namespace for the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BitArray" id="r_BitArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitArray.html">BitArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size "vector" over GF(2) with <span class="tt">N</span> bit elements compactly stored in a standard array of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. The elements in a bit-array are initially all set to 0.  <a href="classgf2_1_1BitArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitGauss" id="r_BitGauss"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitGauss.html">BitGauss</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt"><a class="el" href="classgf2_1_1BitGauss.html" title="The BitGauss class is a Gaussian elimination solver for systems of linear equations over GF(2)....">BitGauss</a></span> class is a Gaussian elimination solver for systems of linear equations over GF(2). <br  />
 It solves systems of the form \(A \cdot x = b\) where <span class="tt">A</span> is a square matrix, <span class="tt">x</span> is a vector of unknowns, and <span class="tt">b</span> is the known right-hand side vector.  <a href="classgf2_1_1BitGauss.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitLU" id="r_BitLU"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitLU.html">BitLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt"><a class="el" href="classgf2_1_1BitLU.html" title="The BitLU class provides the LU decomposition for bit-matrices.">BitLU</a></span> class provides the <span class="tt"><a class="el" href="classgf2_1_1BitLU.html#a70b65617eea5d01c4e061069eb9ebddd" title="Read-only access to the LU form of the bit-matrix where A -&gt; [L\U].">LU</a></span> decomposition for bit-matrices.  <a href="classgf2_1_1BitLU.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitMatrix" id="r_BitMatrix"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the matrix. The row elements are compactly stored in standard vectors of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  <a href="classgf2_1_1BitMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitPolynomial" id="r_BitPolynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">BitPolynomial</a></span> represents a polynomial over GF(2) where we store the polynomial coefficients in a bit-vector. <br  />
 The template parameter <span class="tt">Word</span> sets the unsigned word type used by the <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a></span> that stores the coefficients.  <a href="classgf2_1_1BitPolynomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitRef" id="r_BitRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitRef.html">BitRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is a <em>proxy</em> class to reference a single bit in a bit-store.  <a href="classgf2_1_1BitRef.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitSpan" id="r_BitSpan"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitSpan.html">BitSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>bit_span</em> is a non-owning view of contiguous bits in a bit-store. <br  />
.  <a href="classgf2_1_1BitSpan.html#details">More...</a><br /></td></tr>
<tr class="memitem:BitVector" id="r_BitVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  <a href="classgf2_1_1BitVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:Bits" id="r_Bits"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1Bits.html">Bits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two iterators over <em>all</em> the bits in a bit-store &mdash; one const and the other non-const. <br  />
 The <span class="tt">BitStore::bits()</span> &amp; <span class="tt">BitStore::bits() const</span> methods return the appropriate iterator type.  <a href="classgf2_1_1Bits.html#details">More...</a><br /></td></tr>
<tr class="memitem:SetBits" id="r_SetBits"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1SetBits.html">SetBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the <em>index locations</em> of the set bits in a bit-store. <br  />
 You get this iterator by calling the <span class="tt">BitStore::set_bits()</span> method.  <a href="classgf2_1_1SetBits.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnsetBits" id="r_UnsetBits"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1UnsetBits.html">UnsetBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the <em>index locations</em> of the unset bits in a bit-store.<br  />
 You get this iterator by calling the <span class="tt">BitStore::unset_bits()</span> method.  <a href="classgf2_1_1UnsetBits.html#details">More...</a><br /></td></tr>
<tr class="memitem:Words" id="r_Words"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf2_1_1Words.html">Words</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the "words" underlying a bit-store.<br  />
 You get this iterator by calling the <span class="tt">BitStore::store_words()</span> method.  <a href="classgf2_1_1Words.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:BitStore" id="r_BitStore"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptgf2_1_1BitStore.html">BitStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concept that is satisfied by all bit-vector-like types, which we refer to as <em>bit-stores</em>. <br /></td></tr>
<tr class="memitem:Unsigned" id="r_Unsigned"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptgf2_1_1Unsigned.html">Unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt">Unsigned</span> concept is the same as <span class="tt">std::unsigned_integral</span>. It is satisfied by all primitive unsigned integer types. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr id="typedef-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Shorthand Type Aliases.</div></td></tr>
<tr class="memitem:a872a69469085fcdddf299ae4adc3c940" id="r_a872a69469085fcdddf299ae4adc3c940"><td class="memItemLeft" align="right" valign="top"><a id="a872a69469085fcdddf299ae4adc3c940" name="a872a69469085fcdddf299ae4adc3c940"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u8</b> = std::uint8_t</td></tr>
<tr class="memdesc:a872a69469085fcdddf299ae4adc3c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word type alias for an 8-bit unsigned integer. <br /></td></tr>
<tr class="memitem:ae858164ae3b877b1f9ea2606fae215a0" id="r_ae858164ae3b877b1f9ea2606fae215a0"><td class="memItemLeft" align="right" valign="top"><a id="ae858164ae3b877b1f9ea2606fae215a0" name="ae858164ae3b877b1f9ea2606fae215a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16</b> = std::uint16_t</td></tr>
<tr class="memdesc:ae858164ae3b877b1f9ea2606fae215a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word type alias for a 16-bit unsigned integer. <br /></td></tr>
<tr class="memitem:ad1e43953e374bea8222087e4aba6c74a" id="r_ad1e43953e374bea8222087e4aba6c74a"><td class="memItemLeft" align="right" valign="top"><a id="ad1e43953e374bea8222087e4aba6c74a" name="ad1e43953e374bea8222087e4aba6c74a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32</b> = std::uint32_t</td></tr>
<tr class="memdesc:ad1e43953e374bea8222087e4aba6c74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word type alias for a 32-bit unsigned integer. <br /></td></tr>
<tr class="memitem:a770302128133591da0ca93ded6abf8aa" id="r_a770302128133591da0ca93ded6abf8aa"><td class="memItemLeft" align="right" valign="top"><a id="a770302128133591da0ca93ded6abf8aa" name="a770302128133591da0ca93ded6abf8aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u64</b> = std::uint64_t</td></tr>
<tr class="memdesc:a770302128133591da0ca93ded6abf8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word type alias for a 64-bit unsigned integer. <br /></td></tr>
<tr class="memitem:abed1a83530f112d069e809d8883c13a8" id="r_abed1a83530f112d069e809d8883c13a8"><td class="memItemLeft" align="right" valign="top"><a id="abed1a83530f112d069e809d8883c13a8" name="abed1a83530f112d069e809d8883c13a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>usize</b> = std::size_t</td></tr>
<tr class="memdesc:abed1a83530f112d069e809d8883c13a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word type alias for the platform's "native"-sized unsigned integer. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a612727967670558acfd0fd2adc99eccf" id="r_a612727967670558acfd0fd2adc99eccf"><td class="memTemplParams" colspan="2"><a id="a612727967670558acfd0fd2adc99eccf" name="a612727967670558acfd0fd2adc99eccf"></a>
template&lt;Unsigned Word, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a612727967670558acfd0fd2adc99eccf template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a612727967670558acfd0fd2adc99eccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-matrix, bit-store multiplication, <span class="tt">M * v</span>, returning a new bit-vector. <br /></td></tr>
<tr class="memitem:a287f8e09de01d9f8db3ad6363ee55088" id="r_a287f8e09de01d9f8db3ad6363ee55088"><td class="memTemplParams" colspan="2"><a id="a287f8e09de01d9f8db3ad6363ee55088" name="a287f8e09de01d9f8db3ad6363ee55088"></a>
template&lt;Unsigned Word, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a287f8e09de01d9f8db3ad6363ee55088 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a287f8e09de01d9f8db3ad6363ee55088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form for bit-matrix, bit-store multiplication, <span class="tt">M * v</span>, returning a new bit-vector. <br /></td></tr>
<tr class="memitem:aa0b17d68d248e21905835ba3f43e6d81" id="r_aa0b17d68d248e21905835ba3f43e6d81"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word, BitStore Lhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt;</td></tr>
<tr class="memitem:aa0b17d68d248e21905835ba3f43e6d81 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b17d68d248e21905835ba3f43e6d81">dot</a> (Lhs const &amp;lhs, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aa0b17d68d248e21905835ba3f43e6d81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt">Bit-vector, bit-matrix multiplication, </span>v * M`, returning a new bit-vector.  <br /></td></tr>
<tr class="memitem:ac94607ff1ae0693b1beac65dd6356000" id="r_ac94607ff1ae0693b1beac65dd6356000"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word, BitStore Lhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt;</td></tr>
<tr class="memitem:ac94607ff1ae0693b1beac65dd6356000 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94607ff1ae0693b1beac65dd6356000">operator*</a> (Lhs const &amp;lhs, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ac94607ff1ae0693b1beac65dd6356000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form for bit-vector, bit-matrix multiplication, <span class="tt">v * M</span>, returning a new bit-vector.  <br /></td></tr>
<tr class="memitem:a5aa46c9317574c33d79b310ba22e9d85" id="r_a5aa46c9317574c33d79b310ba22e9d85"><td class="memTemplParams" colspan="2"><a id="a5aa46c9317574c33d79b310ba22e9d85" name="a5aa46c9317574c33d79b310ba22e9d85"></a>
template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a5aa46c9317574c33d79b310ba22e9d85 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;lhs, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a5aa46c9317574c33d79b310ba22e9d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-matrix, bit-matrix multiplication, <span class="tt">M * N</span>, returning a new bit-matrix. <br /></td></tr>
<tr class="memitem:a4cb099d499256c10b88c1909247489fc" id="r_a4cb099d499256c10b88c1909247489fc"><td class="memTemplParams" colspan="2"><a id="a4cb099d499256c10b88c1909247489fc" name="a4cb099d499256c10b88c1909247489fc"></a>
template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a4cb099d499256c10b88c1909247489fc template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;lhs, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a4cb099d499256c10b88c1909247489fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form for bit-matrix, bit-matrix multiplication, <span class="tt">M * N</span>, returning a new bit-matrix. <br /></td></tr>
<tr class="memitem:a3bf52ecd232f4356a3a6ec1579319c51" id="r_a3bf52ecd232f4356a3a6ec1579319c51"><td class="memTemplParams" colspan="2"><a id="a3bf52ecd232f4356a3a6ec1579319c51" name="a3bf52ecd232f4356a3a6ec1579319c51"></a>
template&lt;Unsigned Word, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a3bf52ecd232f4356a3a6ec1579319c51 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_for</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;A, Rhs const &amp;b)</td></tr>
<tr class="memdesc:a3bf52ecd232f4356a3a6ec1579319c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that shows a bit-matrix and a bit-vector side-by-side. <br /></td></tr>
<tr class="memitem:a7643d4731912b343bdfd0d732def477b" id="r_a7643d4731912b343bdfd0d732def477b"><td class="memTemplParams" colspan="2"><a id="a7643d4731912b343bdfd0d732def477b" name="a7643d4731912b343bdfd0d732def477b"></a>
template&lt;Unsigned Word, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a7643d4731912b343bdfd0d732def477b template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_for</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;A, Rhs const &amp;b, Rhs const &amp;c)</td></tr>
<tr class="memdesc:a7643d4731912b343bdfd0d732def477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that shows a bit-matrix and two bit-vectors side-by-side. <br /></td></tr>
<tr class="memitem:a61ac088981e7f319767e47164c64f647" id="r_a61ac088981e7f319767e47164c64f647"><td class="memTemplParams" colspan="2"><a id="a61ac088981e7f319767e47164c64f647" name="a61ac088981e7f319767e47164c64f647"></a>
template&lt;Unsigned Word, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a61ac088981e7f319767e47164c64f647 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_for</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;A, Rhs const &amp;b, Rhs const &amp;c, Rhs const &amp;d)</td></tr>
<tr class="memdesc:a61ac088981e7f319767e47164c64f647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that shows a bit-matrix and three bit-vectors side-by-side. <br /></td></tr>
<tr class="memitem:aa3fb699448e52aff2133caf520cebb9a" id="r_aa3fb699448e52aff2133caf520cebb9a"><td class="memTemplParams" colspan="2"><a id="aa3fb699448e52aff2133caf520cebb9a" name="aa3fb699448e52aff2133caf520cebb9a"></a>
template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:aa3fb699448e52aff2133caf520cebb9a template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_for</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;A, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;B)</td></tr>
<tr class="memdesc:aa3fb699448e52aff2133caf520cebb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that shows two bit-matrices side-by-side. <br /></td></tr>
<tr class="memitem:a354942f9092f474500859e6e76b0c9c5" id="r_a354942f9092f474500859e6e76b0c9c5"><td class="memTemplParams" colspan="2"><a id="a354942f9092f474500859e6e76b0c9c5" name="a354942f9092f474500859e6e76b0c9c5"></a>
template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a354942f9092f474500859e6e76b0c9c5 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_for</b> (<a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;A, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;B, <a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;C)</td></tr>
<tr class="memdesc:a354942f9092f474500859e6e76b0c9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that shows three bit-matrices side-by-side. <br /></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Access Functions:</div></td></tr>
<tr class="memitem:a690f9210e98f6a9615fc5b9cabd67cd3" id="r_a690f9210e98f6a9615fc5b9cabd67cd3"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a690f9210e98f6a9615fc5b9cabd67cd3 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a690f9210e98f6a9615fc5b9cabd67cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bool value of the bit at index <span class="tt">i</span> in the given bit-store.  <br /></td></tr>
<tr class="memitem:a44a358ee6c3e8f2c57c85745d37f867f" id="r_a44a358ee6c3e8f2c57c85745d37f867f"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a44a358ee6c3e8f2c57c85745d37f867f template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44a358ee6c3e8f2c57c85745d37f867f">ref</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a44a358ee6c3e8f2c57c85745d37f867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "reference" to the bit element <span class="tt">i</span> in the given bit-store.  <br /></td></tr>
<tr class="memitem:abd42e52e9163fa845d30cc5ff02d7a7c" id="r_abd42e52e9163fa845d30cc5ff02d7a7c"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:abd42e52e9163fa845d30cc5ff02d7a7c template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd42e52e9163fa845d30cc5ff02d7a7c">front</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:abd42e52e9163fa845d30cc5ff02d7a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a6ea9570ad5ef2845429ce2e5aa2faa52" id="r_a6ea9570ad5ef2845429ce2e5aa2faa52"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a6ea9570ad5ef2845429ce2e5aa2faa52 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea9570ad5ef2845429ce2e5aa2faa52">back</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a6ea9570ad5ef2845429ce2e5aa2faa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the final bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a0185d340520fd8519443cff59ddbe8a2" id="r_a0185d340520fd8519443cff59ddbe8a2"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a0185d340520fd8519443cff59ddbe8a2 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0185d340520fd8519443cff59ddbe8a2">set</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i, bool value=true)</td></tr>
<tr class="memdesc:a0185d340520fd8519443cff59ddbe8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit-element at the given <span class="tt">index</span> to the specified boolean <span class="tt">value</span> (default <span class="tt">value</span> is <span class="tt">true</span>).  <br /></td></tr>
<tr class="memitem:aa424649d48359d85a30260dc0de4835a" id="r_aa424649d48359d85a30260dc0de4835a"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aa424649d48359d85a30260dc0de4835a template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa424649d48359d85a30260dc0de4835a">flip</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:aa424649d48359d85a30260dc0de4835a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bit-element at the given <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a23cbb1ad7a7a0ce5c2f8835564cc21ec" id="r_a23cbb1ad7a7a0ce5c2f8835564cc21ec"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a23cbb1ad7a7a0ce5c2f8835564cc21ec template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">swap</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i0, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i1)</td></tr>
<tr class="memdesc:a23cbb1ad7a7a0ce5c2f8835564cc21ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bits in the bit-store at indices <span class="tt">i0</span> and <span class="tt">i1</span>.  <br /></td></tr>
<tr id="func-members-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Queries:</div></td></tr>
<tr class="memitem:a2008016cc135d5c4738ac1cfbcb411a4" id="r_a2008016cc135d5c4738ac1cfbcb411a4"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a2008016cc135d5c4738ac1cfbcb411a4 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2008016cc135d5c4738ac1cfbcb411a4">is_empty</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a2008016cc135d5c4738ac1cfbcb411a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the store is empty, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ad419c2360bc8c7b34615ecde32abc746" id="r_ad419c2360bc8c7b34615ecde32abc746"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ad419c2360bc8c7b34615ecde32abc746 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad419c2360bc8c7b34615ecde32abc746">any</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:ad419c2360bc8c7b34615ecde32abc746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if at least one bit in the store is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a887e28712d4d2013d795f9ee560ff793" id="r_a887e28712d4d2013d795f9ee560ff793"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a887e28712d4d2013d795f9ee560ff793 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887e28712d4d2013d795f9ee560ff793">all</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a887e28712d4d2013d795f9ee560ff793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all bits in the store are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ac257bfdd661157913f820bcd96ced815" id="r_ac257bfdd661157913f820bcd96ced815"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ac257bfdd661157913f820bcd96ced815 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac257bfdd661157913f820bcd96ced815">none</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:ac257bfdd661157913f820bcd96ced815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no bits in the store are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="func-members-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Mutators:</div></td></tr>
<tr class="memitem:a03ce4352f6f0b4a759b7bb7d880928df" id="r_a03ce4352f6f0b4a759b7bb7d880928df"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a03ce4352f6f0b4a759b7bb7d880928df template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ce4352f6f0b4a759b7bb7d880928df">set_all</a> (Store &amp;store, bool value=true)</td></tr>
<tr class="memdesc:a03ce4352f6f0b4a759b7bb7d880928df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the store to the boolean <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a94314a30722546a006db2f38a2b8a054" id="r_a94314a30722546a006db2f38a2b8a054"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a94314a30722546a006db2f38a2b8a054 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94314a30722546a006db2f38a2b8a054">flip_all</a> (Store &amp;store)</td></tr>
<tr class="memdesc:a94314a30722546a006db2f38a2b8a054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bits in the store.  <br /></td></tr>
<tr id="func-members-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Fills:</div></td></tr>
<tr class="memitem:ab9a3ab2cfb7f67f6b195372d0e66e734" id="r_ab9a3ab2cfb7f67f6b195372d0e66e734"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src, BitStore Store&gt; </td></tr>
<tr class="memitem:ab9a3ab2cfb7f67f6b195372d0e66e734 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a> (Src src, Store &amp;store)</td></tr>
<tr class="memdesc:ab9a3ab2cfb7f67f6b195372d0e66e734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to an <em>equal-sized</em> bit-store.  <br /></td></tr>
<tr class="memitem:aa5f56a386e445b784b0cb9e59df06d1e" id="r_aa5f56a386e445b784b0cb9e59df06d1e"><td class="memTemplParams" colspan="2">template&lt;typename Iter, BitStore Store&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</td></tr>
<tr class="memitem:aa5f56a386e445b784b0cb9e59df06d1e template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f56a386e445b784b0cb9e59df06d1e">copy</a> (Iter src_begin, Iter src_end, Store &amp;store)</td></tr>
<tr class="memdesc:aa5f56a386e445b784b0cb9e59df06d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to an <em>equal-sized</em> bit-store.  <br /></td></tr>
<tr class="memitem:a8eb955c97a414b3b094534847cd75e97" id="r_a8eb955c97a414b3b094534847cd75e97"><td class="memTemplParams" colspan="2">template&lt;BitStore Src, BitStore Dst&gt; </td></tr>
<tr class="memitem:a8eb955c97a414b3b094534847cd75e97 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb955c97a414b3b094534847cd75e97">copy</a> (Src const &amp;src, Dst &amp;dst)</td></tr>
<tr class="memdesc:a8eb955c97a414b3b094534847cd75e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to another <em>equal-sized</em> <span class="tt">dst</span> bit-store.  <br /></td></tr>
<tr class="memitem:aa91135dc9362ddf9d47b1b9a6ec968da" id="r_aa91135dc9362ddf9d47b1b9a6ec968da"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> N, BitStore Store&gt; </td></tr>
<tr class="memitem:aa91135dc9362ddf9d47b1b9a6ec968da template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa91135dc9362ddf9d47b1b9a6ec968da">copy</a> (std::bitset&lt; N &gt; const &amp;src, Store &amp;store)</td></tr>
<tr class="memdesc:aa91135dc9362ddf9d47b1b9a6ec968da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the bits from a <span class="tt">std::bitset</span> to an <em>equal-sized</em> bit-store.  <br /></td></tr>
<tr class="memitem:a75cfaac28a1a498d1706808c3cfa6018" id="r_a75cfaac28a1a498d1706808c3cfa6018"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a75cfaac28a1a498d1706808c3cfa6018 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75cfaac28a1a498d1706808c3cfa6018">copy</a> (Store &amp;store, std::invocable&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a75cfaac28a1a498d1706808c3cfa6018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bits from enumerating calls <span class="tt">f(i)</span> for each index in the bit-store.  <br /></td></tr>
<tr class="memitem:ac6cf8bbef5f96104b2e770e54abdd08a" id="r_ac6cf8bbef5f96104b2e770e54abdd08a"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ac6cf8bbef5f96104b2e770e54abdd08a template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6cf8bbef5f96104b2e770e54abdd08a">fill_random</a> (Store &amp;store, double p=0.5, <a class="el" href="#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:ac6cf8bbef5f96104b2e770e54abdd08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the store with random bits based on an optional probability <span class="tt">p</span> and an optional <span class="tt">seed</span> for the RNG.  <br /></td></tr>
<tr id="func-members-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts:</div></td></tr>
<tr class="memitem:aa8fd09a196762464e1cffe2941779149" id="r_aa8fd09a196762464e1cffe2941779149"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aa8fd09a196762464e1cffe2941779149 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:aa8fd09a196762464e1cffe2941779149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in the store.  <br /></td></tr>
<tr class="memitem:a52986a212b068f596f525deb963d8f59" id="r_a52986a212b068f596f525deb963d8f59"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a52986a212b068f596f525deb963d8f59 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a52986a212b068f596f525deb963d8f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in the store.  <br /></td></tr>
<tr class="memitem:aa9ee66f54ef560ada72c85ce60ebab33" id="r_aa9ee66f54ef560ada72c85ce60ebab33"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aa9ee66f54ef560ada72c85ce60ebab33 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:aa9ee66f54ef560ada72c85ce60ebab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in the store.  <br /></td></tr>
<tr class="memitem:abdf2434cc208bb1633add06c3619bf06" id="r_abdf2434cc208bb1633add06c3619bf06"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:abdf2434cc208bb1633add06c3619bf06 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:abdf2434cc208bb1633add06c3619bf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in the store.  <br /></td></tr>
<tr class="memitem:ab494f3b9b86c795386c72e6480bba20d" id="r_ab494f3b9b86c795386c72e6480bba20d"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ab494f3b9b86c795386c72e6480bba20d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab494f3b9b86c795386c72e6480bba20d">count_ones</a> (Word word)</td></tr>
<tr class="memdesc:ab494f3b9b86c795386c72e6480bba20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:a6264be2f7bdac2305ba77b473294c801" id="r_a6264be2f7bdac2305ba77b473294c801"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a6264be2f7bdac2305ba77b473294c801 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6264be2f7bdac2305ba77b473294c801">count_zeros</a> (Word word)</td></tr>
<tr class="memdesc:a6264be2f7bdac2305ba77b473294c801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:abd96d700874211c947d7ca863fd8372e" id="r_abd96d700874211c947d7ca863fd8372e"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:abd96d700874211c947d7ca863fd8372e template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd96d700874211c947d7ca863fd8372e">trailing_zeros</a> (Word word)</td></tr>
<tr class="memdesc:abd96d700874211c947d7ca863fd8372e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:a730c7cf46f5de572063287be53c53e70" id="r_a730c7cf46f5de572063287be53c53e70"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a730c7cf46f5de572063287be53c53e70 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a730c7cf46f5de572063287be53c53e70">leading_zeros</a> (Word word)</td></tr>
<tr class="memdesc:a730c7cf46f5de572063287be53c53e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:adf0dbd78e459e1125e4fd7c636853e35" id="r_adf0dbd78e459e1125e4fd7c636853e35"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:adf0dbd78e459e1125e4fd7c636853e35 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf0dbd78e459e1125e4fd7c636853e35">trailing_ones</a> (Word word)</td></tr>
<tr class="memdesc:adf0dbd78e459e1125e4fd7c636853e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing ones in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:ad8a4b2b04947c9d1764cc5e64c7e18f9" id="r_ad8a4b2b04947c9d1764cc5e64c7e18f9"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ad8a4b2b04947c9d1764cc5e64c7e18f9 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">leading_ones</a> (Word word)</td></tr>
<tr class="memdesc:ad8a4b2b04947c9d1764cc5e64c7e18f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading ones in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>.  <br /></td></tr>
<tr class="memitem:aed00c8ab60ee9aa9e5783e8e9a224f99" id="r_aed00c8ab60ee9aa9e5783e8e9a224f99"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:aed00c8ab60ee9aa9e5783e8e9a224f99 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed00c8ab60ee9aa9e5783e8e9a224f99">lowest_set_bit</a> (Word word)</td></tr>
<tr class="memdesc:aed00c8ab60ee9aa9e5783e8e9a224f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the lowest set bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if no bits are set.  <br /></td></tr>
<tr id="func-members-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Set-bit indices:</div></td></tr>
<tr class="memitem:a1f962bf6ba97b31c476d19c37da8bd05" id="r_a1f962bf6ba97b31c476d19c37da8bd05"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a1f962bf6ba97b31c476d19c37da8bd05 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a1f962bf6ba97b31c476d19c37da8bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in the bit-store or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:afa87a762ead610d0d0e20e54e3380d7d" id="r_afa87a762ead610d0d0e20e54e3380d7d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:afa87a762ead610d0d0e20e54e3380d7d template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa87a762ead610d0d0e20e54e3380d7d">last_set</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:afa87a762ead610d0d0e20e54e3380d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last set bit in the bit-store or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:a84d33fc3ba98b78ab3ad44fba88df2c1" id="r_a84d33fc3ba98b78ab3ad44fba88df2c1"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a84d33fc3ba98b78ab3ad44fba88df2c1 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84d33fc3ba98b78ab3ad44fba88df2c1">next_set</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> index)</td></tr>
<tr class="memdesc:a84d33fc3ba98b78ab3ad44fba88df2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next set bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more set bits exist.  <br /></td></tr>
<tr class="memitem:a7acc8bbe9a3578c1d8b9e8659c2bd891" id="r_a7acc8bbe9a3578c1d8b9e8659c2bd891"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a7acc8bbe9a3578c1d8b9e8659c2bd891 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">previous_set</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> index)</td></tr>
<tr class="memdesc:a7acc8bbe9a3578c1d8b9e8659c2bd891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous set bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if there are none.  <br /></td></tr>
<tr id="func-members-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Unset-bit Indices:</div></td></tr>
<tr class="memitem:a044dac4df02b26e8d4713a39ce170e7d" id="r_a044dac4df02b26e8d4713a39ce170e7d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a044dac4df02b26e8d4713a39ce170e7d template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044dac4df02b26e8d4713a39ce170e7d">first_unset</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a044dac4df02b26e8d4713a39ce170e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:ad8089c96553359e761a5916ce39c420c" id="r_ad8089c96553359e761a5916ce39c420c"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ad8089c96553359e761a5916ce39c420c template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8089c96553359e761a5916ce39c420c">last_unset</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:ad8089c96553359e761a5916ce39c420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:a2253deaf8dec9af0a0b3e3f4af24f49d" id="r_a2253deaf8dec9af0a0b3e3f4af24f49d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a2253deaf8dec9af0a0b3e3f4af24f49d template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2253deaf8dec9af0a0b3e3f4af24f49d">next_unset</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> index)</td></tr>
<tr class="memdesc:a2253deaf8dec9af0a0b3e3f4af24f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next unset bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr class="memitem:aaee9a90d260c8210b965a7b9aaf54570" id="r_aaee9a90d260c8210b965a7b9aaf54570"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aaee9a90d260c8210b965a7b9aaf54570 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee9a90d260c8210b965a7b9aaf54570">previous_unset</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> index)</td></tr>
<tr class="memdesc:aaee9a90d260c8210b965a7b9aaf54570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous unset bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr id="func-members-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Iterators:</div></td></tr>
<tr class="memitem:a9505618cfe91d94fb220381ca468058e" id="r_a9505618cfe91d94fb220381ca468058e"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a9505618cfe91d94fb220381ca468058e template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9505618cfe91d94fb220381ca468058e">bits</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a9505618cfe91d94fb220381ca468058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-store.  <br /></td></tr>
<tr class="memitem:a23dcec6af2e6ea3a742511ee90f3ad2b" id="r_a23dcec6af2e6ea3a742511ee90f3ad2b"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a23dcec6af2e6ea3a742511ee90f3ad2b template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23dcec6af2e6ea3a742511ee90f3ad2b">bits</a> (Store &amp;store)</td></tr>
<tr class="memdesc:a23dcec6af2e6ea3a742511ee90f3ad2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const iterator over the values of the bits in the mutable bit-store.  <br /></td></tr>
<tr class="memitem:a6c46a7570efd21105aa42c7d14c997d1" id="r_a6c46a7570efd21105aa42c7d14c997d1"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a6c46a7570efd21105aa42c7d14c997d1 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c46a7570efd21105aa42c7d14c997d1">set_bits</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a6c46a7570efd21105aa42c7d14c997d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-store.  <br /></td></tr>
<tr class="memitem:a976e9da1d5515af13d3d805fa2339b58" id="r_a976e9da1d5515af13d3d805fa2339b58"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a976e9da1d5515af13d3d805fa2339b58 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976e9da1d5515af13d3d805fa2339b58">unset_bits</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a976e9da1d5515af13d3d805fa2339b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-store.  <br /></td></tr>
<tr class="memitem:a832a9327ac2dac0ce3ebe50f6fed021d" id="r_a832a9327ac2dac0ce3ebe50f6fed021d"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a832a9327ac2dac0ce3ebe50f6fed021d template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832a9327ac2dac0ce3ebe50f6fed021d">store_words</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a832a9327ac2dac0ce3ebe50f6fed021d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over all the <em>words</em> underlying the bit-store.  <br /></td></tr>
<tr class="memitem:abda627169916e771d25c9a1af8dad123" id="r_abda627169916e771d25c9a1af8dad123"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:abda627169916e771d25c9a1af8dad123 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda627169916e771d25c9a1af8dad123">to_words</a> (Store const &amp;store, std::output_iterator&lt; typename Store::word_type &gt; auto out)</td></tr>
<tr class="memdesc:abda627169916e771d25c9a1af8dad123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-store and puts them into the passed output iterator.  <br /></td></tr>
<tr class="memitem:a91d03fc055e7a9b1f082e80b34b30bbf" id="r_a91d03fc055e7a9b1f082e80b34b30bbf"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a91d03fc055e7a9b1f082e80b34b30bbf template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91d03fc055e7a9b1f082e80b34b30bbf">to_words</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a91d03fc055e7a9b1f082e80b34b30bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-store as new <span class="tt">std::vector</span>.  <br /></td></tr>
<tr id="func-members-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Spans:</div></td></tr>
<tr class="memitem:a91642aa97f8c3823b3630dde99574a8b" id="r_a91642aa97f8c3823b3630dde99574a8b"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a91642aa97f8c3823b3630dde99574a8b template"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91642aa97f8c3823b3630dde99574a8b">span</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:a91642aa97f8c3823b3630dde99574a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only bit-span over the const bit-store <span class="tt">store</span> for its bits in the range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr class="memitem:ade1775a262530e2cfd40b51256ad8b85" id="r_ade1775a262530e2cfd40b51256ad8b85"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ade1775a262530e2cfd40b51256ad8b85 template"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade1775a262530e2cfd40b51256ad8b85">span</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:ade1775a262530e2cfd40b51256ad8b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-span over the bit-store <span class="tt">store</span> for its bits in the range <span class="tt">[begin, end)</span>. This span allows modification of the underlying bits (unless its created from a span that is itself const).  <br /></td></tr>
<tr id="func-members-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-vectors:</div></td></tr>
<tr class="memitem:a8fe2ab8650590f082f800d223fdd6422" id="r_a8fe2ab8650590f082f800d223fdd6422"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a8fe2ab8650590f082f800d223fdd6422 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fe2ab8650590f082f800d223fdd6422">sub</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:a8fe2ab8650590f082f800d223fdd6422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector.  <br /></td></tr>
<tr id="func-members-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Splits and Joins:</div></td></tr>
<tr class="memitem:a56284774b49c6d8b626c41eb23c285db" id="r_a56284774b49c6d8b626c41eb23c285db"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a56284774b49c6d8b626c41eb23c285db template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56284774b49c6d8b626c41eb23c285db">split</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;left, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;right)</td></tr>
<tr class="memdesc:a56284774b49c6d8b626c41eb23c285db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span> respectively. Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>.  <br /></td></tr>
<tr class="memitem:a0838a227d5f2bfec59c69798f0692d31" id="r_a0838a227d5f2bfec59c69798f0692d31"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a0838a227d5f2bfec59c69798f0692d31 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0838a227d5f2bfec59c69798f0692d31">split</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> at)</td></tr>
<tr class="memdesc:a0838a227d5f2bfec59c69798f0692d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span> respectively. Clones of the parts are returned as a pair of new bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>].  <br /></td></tr>
<tr class="memitem:a10232b64eb69a81bc462f7b7cc18e0fc" id="r_a10232b64eb69a81bc462f7b7cc18e0fc"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; </td></tr>
<tr class="memitem:a10232b64eb69a81bc462f7b7cc18e0fc template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10232b64eb69a81bc462f7b7cc18e0fc">join</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a10232b64eb69a81bc462f7b7cc18e0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector formed by joining two bit-stores <span class="tt">lhs</span> and <span class="tt">rhs</span>.  <br /></td></tr>
<tr id="func-members-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Interleaving With Zeros:</div></td></tr>
<tr class="memitem:ac462028756047a28bd47ba5134841371" id="r_ac462028756047a28bd47ba5134841371"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ac462028756047a28bd47ba5134841371 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac462028756047a28bd47ba5134841371">riffle</a> (Store const &amp;store, <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;dst)</td></tr>
<tr class="memdesc:ac462028756047a28bd47ba5134841371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the bits of a bit-store with zeros storing the result into the passed bit-vector <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:ae70d7e49dce7447eeb6b66bbc03bb2a5" id="r_ae70d7e49dce7447eeb6b66bbc03bb2a5"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:ae70d7e49dce7447eeb6b66bbc03bb2a5 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae70d7e49dce7447eeb6b66bbc03bb2a5">riffle</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:ae70d7e49dce7447eeb6b66bbc03bb2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the result of riffling the bits in this bit-store with zeros.  <br /></td></tr>
<tr id="func-members-12" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations:</div></td></tr>
<tr class="memitem:af1900fd540d8f3670454d39b003d9667" id="r_af1900fd540d8f3670454d39b003d9667"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:af1900fd540d8f3670454d39b003d9667 template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a> (Store const &amp;store, std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;)</td></tr>
<tr class="memdesc:af1900fd540d8f3670454d39b003d9667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of a store.  <br /></td></tr>
<tr class="memitem:a355af2e0599965ef8d4eada941eee8e3" id="r_a355af2e0599965ef8d4eada941eee8e3"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a355af2e0599965ef8d4eada941eee8e3 template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a> (Store const &amp;store, std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;)</td></tr>
<tr class="memdesc:a355af2e0599965ef8d4eada941eee8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of a store.  <br /></td></tr>
<tr class="memitem:a75fa1cd092371f7093307f09dbd71c55" id="r_a75fa1cd092371f7093307f09dbd71c55"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a75fa1cd092371f7093307f09dbd71c55 template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75fa1cd092371f7093307f09dbd71c55">to_pretty_string</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a75fa1cd092371f7093307f09dbd71c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "pretty" string representation of a store.  <br /></td></tr>
<tr class="memitem:aa8641a61d375c82684b921764e373cce" id="r_aa8641a61d375c82684b921764e373cce"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aa8641a61d375c82684b921764e373cce template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:aa8641a61d375c82684b921764e373cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "hex" string representation of the bits in the bit-store.  <br /></td></tr>
<tr class="memitem:adf41367b95076973a2fa4d81822fcf4b" id="r_adf41367b95076973a2fa4d81822fcf4b"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:adf41367b95076973a2fa4d81822fcf4b template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf41367b95076973a2fa4d81822fcf4b">describe</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:adf41367b95076973a2fa4d81822fcf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detailed Description of a Bit-Store.  <br /></td></tr>
<tr class="memitem:a37a8a98a7488d5afa9cb8c0634cb31cb" id="r_a37a8a98a7488d5afa9cb8c0634cb31cb"><td class="memTemplParams" colspan="2"><a id="a37a8a98a7488d5afa9cb8c0634cb31cb" name="a37a8a98a7488d5afa9cb8c0634cb31cb"></a>
template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a37a8a98a7488d5afa9cb8c0634cb31cb template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Store const &amp;store, std::ostream &amp;s)</td></tr>
<tr class="memdesc:a37a8a98a7488d5afa9cb8c0634cb31cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usual output stream operator for a bit-store. <br /></td></tr>
<tr id="func-members-13" class="groupHeader"><td colspan="2"><div class="groupHeader">The Equality Operator:</div></td></tr>
<tr class="memitem:a13bccb650d933d19ec4c91bbfe7f0ef8" id="r_a13bccb650d933d19ec4c91bbfe7f0ef8"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; </td></tr>
<tr class="memitem:a13bccb650d933d19ec4c91bbfe7f0ef8 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13bccb650d933d19ec4c91bbfe7f0ef8">operator==</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a13bccb650d933d19ec4c91bbfe7f0ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that any pair of bit-stores are equal in content.  <br /></td></tr>
<tr id="func-members-14" class="groupHeader"><td colspan="2"><div class="groupHeader">In-place Bit Shifts:</div></td></tr>
<tr class="memitem:a0e049b3d556045b8d38bf64ef5ae48ba" id="r_a0e049b3d556045b8d38bf64ef5ae48ba"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a0e049b3d556045b8d38bf64ef5ae48ba template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e049b3d556045b8d38bf64ef5ae48ba">operator&lt;&lt;=</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> shift)</td></tr>
<tr class="memdesc:a0e049b3d556045b8d38bf64ef5ae48ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place left shift of a bit-store by <span class="tt">shift</span> bits.  <br /></td></tr>
<tr class="memitem:aa074227777980943f4e0a52c2abb2e3e" id="r_aa074227777980943f4e0a52c2abb2e3e"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:aa074227777980943f4e0a52c2abb2e3e template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa074227777980943f4e0a52c2abb2e3e">operator&gt;&gt;=</a> (Store &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> shift)</td></tr>
<tr class="memdesc:aa074227777980943f4e0a52c2abb2e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place right shift of a store by <span class="tt">shift</span> bits.  <br /></td></tr>
<tr id="func-members-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Out-of-place Bit Shifts:</div></td></tr>
<tr class="memitem:af4e6d9629201dc37d74a7bc90e8ed975" id="r_af4e6d9629201dc37d74a7bc90e8ed975"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:af4e6d9629201dc37d74a7bc90e8ed975 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4e6d9629201dc37d74a7bc90e8ed975">operator&lt;&lt;</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> shift)</td></tr>
<tr class="memdesc:af4e6d9629201dc37d74a7bc90e8ed975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the store shifted left by <span class="tt">shift</span> bits.  <br /></td></tr>
<tr class="memitem:a23dd3d7f7ef4a78f9ab65d54e5d394ad" id="r_a23dd3d7f7ef4a78f9ab65d54e5d394ad"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a23dd3d7f7ef4a78f9ab65d54e5d394ad template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23dd3d7f7ef4a78f9ab65d54e5d394ad">operator&gt;&gt;</a> (Store const &amp;store, <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> shift)</td></tr>
<tr class="memdesc:a23dd3d7f7ef4a78f9ab65d54e5d394ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is <span class="tt">lhs</span> shifted right by <span class="tt">shift</span> bits.  <br /></td></tr>
<tr id="func-members-16" class="groupHeader"><td colspan="2"><div class="groupHeader">In-place Bitwise Operations:</div></td></tr>
<tr class="memitem:a39ac1c9c4e8d925816d2bc5ff12e0711" id="r_a39ac1c9c4e8d925816d2bc5ff12e0711"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a39ac1c9c4e8d925816d2bc5ff12e0711 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ac1c9c4e8d925816d2bc5ff12e0711">operator^=</a> (Lhs &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a39ac1c9c4e8d925816d2bc5ff12e0711"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">XOR</span> of one bit-store with an equal-sized bit-store.  <br /></td></tr>
<tr class="memitem:ae1fee012a210fa3a0cbdc95c0129b789" id="r_ae1fee012a210fa3a0cbdc95c0129b789"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:ae1fee012a210fa3a0cbdc95c0129b789 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1fee012a210fa3a0cbdc95c0129b789">operator&amp;=</a> (Lhs &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:ae1fee012a210fa3a0cbdc95c0129b789"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">AND</span> of one bit-store with an equal-sized bit-store.  <br /></td></tr>
<tr class="memitem:a266cc1d698afa04717e29bf09bf94935" id="r_a266cc1d698afa04717e29bf09bf94935"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a266cc1d698afa04717e29bf09bf94935 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a266cc1d698afa04717e29bf09bf94935">operator|=</a> (Lhs &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a266cc1d698afa04717e29bf09bf94935"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">OR</span> of one bit-store with an equal-sized bit-store.  <br /></td></tr>
<tr id="func-members-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Out-of-place Bitwise Operations:</div></td></tr>
<tr class="memitem:a63cdbdaf058edb19748525579aaa0118" id="r_a63cdbdaf058edb19748525579aaa0118"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; </td></tr>
<tr class="memitem:a63cdbdaf058edb19748525579aaa0118 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63cdbdaf058edb19748525579aaa0118">operator~</a> (Store const &amp;store)</td></tr>
<tr class="memdesc:a63cdbdaf058edb19748525579aaa0118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that has the same bits as a bit-store but with all the bits flipped.  <br /></td></tr>
<tr class="memitem:a1687ef8e4f015f7387912bd013500584" id="r_a1687ef8e4f015f7387912bd013500584"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a1687ef8e4f015f7387912bd013500584 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1687ef8e4f015f7387912bd013500584">operator^</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a1687ef8e4f015f7387912bd013500584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <span class="tt">XOR</span> of two equal-sized bit-stores as a new bit-vector.  <br /></td></tr>
<tr class="memitem:a262d78bc376e61bb7993c6cbb62c7f13" id="r_a262d78bc376e61bb7993c6cbb62c7f13"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a262d78bc376e61bb7993c6cbb62c7f13 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262d78bc376e61bb7993c6cbb62c7f13">operator&amp;</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a262d78bc376e61bb7993c6cbb62c7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <span class="tt">AND</span> of two equal-sized bit-stores as a new bit-vector.  <br /></td></tr>
<tr class="memitem:afb56bf15d46a0f53489a06a88ea0f96c" id="r_afb56bf15d46a0f53489a06a88ea0f96c"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:afb56bf15d46a0f53489a06a88ea0f96c template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb56bf15d46a0f53489a06a88ea0f96c">operator|</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:afb56bf15d46a0f53489a06a88ea0f96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <span class="tt">OR</span> of two equal-sized bit-stores as a new bit-vector.  <br /></td></tr>
<tr id="func-members-18" class="groupHeader"><td colspan="2"><div class="groupHeader">In-place Arithmetic Operations:</div></td></tr>
<tr class="memitem:a7ea68d994ef5b413822fe67c735d452a" id="r_a7ea68d994ef5b413822fe67c735d452a"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a7ea68d994ef5b413822fe67c735d452a template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ea68d994ef5b413822fe67c735d452a">operator+=</a> (Lhs &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a7ea68d994ef5b413822fe67c735d452a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition of one bit-store with an equal-sized bit-store.  <br /></td></tr>
<tr class="memitem:a97b4bd320f0d11a6cb5ae25135034d47" id="r_a97b4bd320f0d11a6cb5ae25135034d47"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a97b4bd320f0d11a6cb5ae25135034d47 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b4bd320f0d11a6cb5ae25135034d47">operator-=</a> (Lhs &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a97b4bd320f0d11a6cb5ae25135034d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place difference of one bit-store with an equal-sized bit-store.  <br /></td></tr>
<tr id="func-members-19" class="groupHeader"><td colspan="2"><div class="groupHeader">Out-of-place Arithmetic Operations:</div></td></tr>
<tr class="memitem:ad15366027d99c7dbb1f02ffe1c8dd03d" id="r_ad15366027d99c7dbb1f02ffe1c8dd03d"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:ad15366027d99c7dbb1f02ffe1c8dd03d template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad15366027d99c7dbb1f02ffe1c8dd03d">operator+</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:ad15366027d99c7dbb1f02ffe1c8dd03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two equal-sized bit-stores and returns the result as a new bit-vector.  <br /></td></tr>
<tr class="memitem:a92d7eb66f490d301485d15466635edda" id="r_a92d7eb66f490d301485d15466635edda"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a92d7eb66f490d301485d15466635edda template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d7eb66f490d301485d15466635edda">operator-</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a92d7eb66f490d301485d15466635edda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two equal-sized bit-stores and returns the result as a new bit-vector.  <br /></td></tr>
<tr id="func-members-20" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3b25bbe4b0a598204faaaaed9614a91" id="r_ab3b25bbe4b0a598204faaaaed9614a91"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:ab3b25bbe4b0a598204faaaaed9614a91 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b25bbe4b0a598204faaaaed9614a91">dot</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:ab3b25bbe4b0a598204faaaaed9614a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot Products:  <br /></td></tr>
<tr class="memitem:a20bb9b68837d5556f2f34127365679fa" id="r_a20bb9b68837d5556f2f34127365679fa"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a20bb9b68837d5556f2f34127365679fa template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20bb9b68837d5556f2f34127365679fa">operator*</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a20bb9b68837d5556f2f34127365679fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <span class="tt">*</span> returns the dot product of <span class="tt">lhs</span> and <span class="tt">rhs</span> as a boolean value.  <br /></td></tr>
<tr id="func-members-21" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3b0ea5c405d2ed08ce9fa5bbbb2cc169" id="r_a3b0ea5c405d2ed08ce9fa5bbbb2cc169"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</td></tr>
<tr class="memitem:a3b0ea5c405d2ed08ce9fa5bbbb2cc169 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b0ea5c405d2ed08ce9fa5bbbb2cc169">convolve</a> (Lhs const &amp;lhs, Rhs const &amp;rhs)</td></tr>
<tr class="memdesc:a3b0ea5c405d2ed08ce9fa5bbbb2cc169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutions:  <br /></td></tr>
<tr id="func-members-22" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors:</div></td></tr>
<tr class="memitem:ac0196c65fdb8ea5284bd28b74b1391ac" id="r_ac0196c65fdb8ea5284bd28b74b1391ac"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ac0196c65fdb8ea5284bd28b74b1391ac template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits</a> (<a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:ac0196c65fdb8ea5284bd28b74b1391ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> with the bits in the half-open range <span class="tt">[begin, end)</span> set to 1 and the others set to 0.  <br /></td></tr>
<tr class="memitem:a53af367ace4cb8292aef14a2338eefa7" id="r_a53af367ace4cb8292aef14a2338eefa7"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a53af367ace4cb8292aef14a2338eefa7 template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits</a> (<a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:a53af367ace4cb8292aef14a2338eefa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> with the bits in the half-open range <span class="tt">[begin, end)</span> set to 0 and the others set to 1.  <br /></td></tr>
<tr id="func-members-23" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit mutators:</div></td></tr>
<tr class="memitem:a39fa3e7982acfbab6caa685ce6310258" id="r_a39fa3e7982acfbab6caa685ce6310258"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a39fa3e7982acfbab6caa685ce6310258 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39fa3e7982acfbab6caa685ce6310258">set_bits</a> (Word &amp;word, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:a39fa3e7982acfbab6caa685ce6310258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the half-open range <span class="tt">[begin, end)</span> of <span class="tt">word</span> to one, leaving the others unchanged.  <br /></td></tr>
<tr class="memitem:a7e371a5f346a2c3830a8293d172aaa22" id="r_a7e371a5f346a2c3830a8293d172aaa22"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a7e371a5f346a2c3830a8293d172aaa22 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e371a5f346a2c3830a8293d172aaa22">reset_bits</a> (Word &amp;word, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:a7e371a5f346a2c3830a8293d172aaa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the bits in the half-open range <span class="tt">[begin, end)</span> of <span class="tt">word</span> to zero, leaving the others unchanged.  <br /></td></tr>
<tr class="memitem:a2e476cee5220beaaf11e0052f8980dc7" id="r_a2e476cee5220beaaf11e0052f8980dc7"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a2e476cee5220beaaf11e0052f8980dc7 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e476cee5220beaaf11e0052f8980dc7">set_except_bits</a> (Word &amp;word, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:a2e476cee5220beaaf11e0052f8980dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits of <span class="tt">word</span> to 1 <em>except</em> for those in the half-open range <span class="tt">[begin, end)</span> which are unchanged.  <br /></td></tr>
<tr class="memitem:adf5400c9f48fc978113d9ca054b03290" id="r_adf5400c9f48fc978113d9ca054b03290"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:adf5400c9f48fc978113d9ca054b03290 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf5400c9f48fc978113d9ca054b03290">reset_except_bits</a> (Word &amp;word, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end)</td></tr>
<tr class="memdesc:adf5400c9f48fc978113d9ca054b03290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits of <span class="tt">word</span> to 0 <em>except</em> for those in the half-open range <span class="tt">[begin, end)</span> which are unchanged.  <br /></td></tr>
<tr class="memitem:a4139e2fe17c87caf6ed958e228b79de9" id="r_a4139e2fe17c87caf6ed958e228b79de9"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a4139e2fe17c87caf6ed958e228b79de9 template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4139e2fe17c87caf6ed958e228b79de9">reverse_bits</a> (Word word)</td></tr>
<tr class="memdesc:a4139e2fe17c87caf6ed958e228b79de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <span class="tt">word</span> with all its bits reversed.  <br /></td></tr>
<tr class="memitem:a23f5a30c88d6d08c6751fb8cc6b747d6" id="r_a23f5a30c88d6d08c6751fb8cc6b747d6"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word, typename Other&gt; <br />
requires std::convertible_to&lt;Other, Word&gt;</td></tr>
<tr class="memitem:a23f5a30c88d6d08c6751fb8cc6b747d6 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f5a30c88d6d08c6751fb8cc6b747d6">replace_bits</a> (Word &amp;word, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> begin, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> end, Other other)</td></tr>
<tr class="memdesc:a23f5a30c88d6d08c6751fb8cc6b747d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the bits of <span class="tt">word</span> in the range <span class="tt">[begin, end)</span> with the bits from <span class="tt">other</span> leaving the rest unchanged.  <br /></td></tr>
<tr id="func-members-24" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Riffling:</div></td></tr>
<tr class="memitem:a1096406612c1629a626fbc9a083a4054" id="r_a1096406612c1629a626fbc9a083a4054"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a1096406612c1629a626fbc9a083a4054 template"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; Word, Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1096406612c1629a626fbc9a083a4054">riffle</a> (Word word)</td></tr>
<tr class="memdesc:a1096406612c1629a626fbc9a083a4054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Riffles an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> into a pair of others containing the bits in the original word interleaved with zeros.  <br /></td></tr>
<tr id="func-members-25" class="groupHeader"><td colspan="2"><div class="groupHeader">Searches:</div></td></tr>
<tr class="memitem:acd6d1d759f8496d8c2158208bcfde29e" id="r_acd6d1d759f8496d8c2158208bcfde29e"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:acd6d1d759f8496d8c2158208bcfde29e template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6d1d759f8496d8c2158208bcfde29e">highest_set_bit</a> (Word word)</td></tr>
<tr class="memdesc:acd6d1d759f8496d8c2158208bcfde29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the highest set bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:ac0de53666c9c94f325f36d8f5f0f8290" id="r_ac0de53666c9c94f325f36d8f5f0f8290"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ac0de53666c9c94f325f36d8f5f0f8290 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0de53666c9c94f325f36d8f5f0f8290">lowest_unset_bit</a> (Word word)</td></tr>
<tr class="memdesc:ac0de53666c9c94f325f36d8f5f0f8290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the lowest unset bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if there are no unset bits.  <br /></td></tr>
<tr class="memitem:aff9eea4f2c110bd80b9a086d7cb8a08b" id="r_aff9eea4f2c110bd80b9a086d7cb8a08b"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:aff9eea4f2c110bd80b9a086d7cb8a08b template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff9eea4f2c110bd80b9a086d7cb8a08b">highest_unset_bit</a> (Word word)</td></tr>
<tr class="memdesc:aff9eea4f2c110bd80b9a086d7cb8a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the highest unset bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if there are none.  <br /></td></tr>
<tr id="func-members-26" class="groupHeader"><td colspan="2"><div class="groupHeader">Stringification:</div></td></tr>
<tr class="memitem:a8e4d17607e82f5392f9c52b57cefbbda" id="r_a8e4d17607e82f5392f9c52b57cefbbda"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a8e4d17607e82f5392f9c52b57cefbbda template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4d17607e82f5392f9c52b57cefbbda">to_binary_string</a> (Word word)</td></tr>
<tr class="memdesc:a8e4d17607e82f5392f9c52b57cefbbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binary string representation of an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> showing <em>all</em> the bits.  <br /></td></tr>
<tr class="memitem:afe64e61826101a505216e9c18ff2564a" id="r_afe64e61826101a505216e9c18ff2564a"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:afe64e61826101a505216e9c18ff2564a template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe64e61826101a505216e9c18ff2564a">to_hex_string</a> (Word word)</td></tr>
<tr class="memdesc:afe64e61826101a505216e9c18ff2564a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hex string representation of an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> showing <em>all</em> the bits.  <br /></td></tr>
<tr id="func-members-27" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Locations:</div></td></tr>
<tr class="memitem:addc2c0a44d96155e38c2ad788bbd3d15" id="r_addc2c0a44d96155e38c2ad788bbd3d15"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:addc2c0a44d96155e38c2ad788bbd3d15 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addc2c0a44d96155e38c2ad788bbd3d15">words_needed</a> (<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> n_bits)</td></tr>
<tr class="memdesc:addc2c0a44d96155e38c2ad788bbd3d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>s needed to store <span class="tt">n_bits</span> bits.  <br /></td></tr>
<tr class="memitem:aaf2ed88c6da45988348d97b3b209a210" id="r_aaf2ed88c6da45988348d97b3b209a210"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:aaf2ed88c6da45988348d97b3b209a210 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2ed88c6da45988348d97b3b209a210">word_index</a> (<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:aaf2ed88c6da45988348d97b3b209a210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> word holding bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a2f80c44fd588d487a83e265202de69e9" id="r_a2f80c44fd588d487a83e265202de69e9"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a2f80c44fd588d487a83e265202de69e9 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f80c44fd588d487a83e265202de69e9">bit_offset</a> (<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a2f80c44fd588d487a83e265202de69e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit position within the containing word for bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:a296a376731b5bbb8601659fda1f230c4" id="r_a296a376731b5bbb8601659fda1f230c4"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a296a376731b5bbb8601659fda1f230c4 template"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a296a376731b5bbb8601659fda1f230c4">index_and_offset</a> (<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:a296a376731b5bbb8601659fda1f230c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of the index of the word and the bit position within the word for bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:ab29bbe0565dac39f445fcd73fd83cad7" id="r_ab29bbe0565dac39f445fcd73fd83cad7"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ab29bbe0565dac39f445fcd73fd83cad7 template"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>, Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29bbe0565dac39f445fcd73fd83cad7">index_and_mask</a> (<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:ab29bbe0565dac39f445fcd73fd83cad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of the index of the word and a mask isolating bit element <span class="tt">i</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a994fbcb200aa8df4c1ebec86f4f49df3" id="r_a994fbcb200aa8df4c1ebec86f4f49df3"><td class="memItemLeft" align="right" valign="top"><a id="a994fbcb200aa8df4c1ebec86f4f49df3" name="a994fbcb200aa8df4c1ebec86f4f49df3"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>exit_on_assert_failure</b> = true</td></tr>
<tr class="memdesc:a994fbcb200aa8df4c1ebec86f4f49df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, all failed confirmations exit the program. <br  />
 You can set this variable to <span class="tt">false</span> to prevent this behavior (useful for unit tests). <br /></td></tr>
<tr id="var-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Variables:</div></td></tr>
<tr class="memitem:ad1d8969ed4ed705fbc26eec1eed8b6ae" id="r_ad1d8969ed4ed705fbc26eec1eed8b6ae"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:ad1d8969ed4ed705fbc26eec1eed8b6ae template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a> = std::numeric_limits&lt;Word&gt;::digits</td></tr>
<tr class="memdesc:ad1d8969ed4ed705fbc26eec1eed8b6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> returned as a <span class="tt"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a></span>.  <br /></td></tr>
<tr class="memitem:a171887ab6ae6dd7dd533d431f86b152c" id="r_a171887ab6ae6dd7dd533d431f86b152c"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a171887ab6ae6dd7dd533d431f86b152c template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171887ab6ae6dd7dd533d431f86b152c">ZERO</a> = Word{0}</td></tr>
<tr class="memdesc:a171887ab6ae6dd7dd533d431f86b152c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The zero value for an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> type.  <br /></td></tr>
<tr class="memitem:a3ac31b0679b7a7ad28fa9f7432e5761d" id="r_a3ac31b0679b7a7ad28fa9f7432e5761d"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a3ac31b0679b7a7ad28fa9f7432e5761d template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ac31b0679b7a7ad28fa9f7432e5761d">ONE</a> = Word{1}</td></tr>
<tr class="memdesc:a3ac31b0679b7a7ad28fa9f7432e5761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The one value for an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> type.  <br /></td></tr>
<tr class="memitem:acf1efd9e5621725420f4c5926573b376" id="r_acf1efd9e5621725420f4c5926573b376"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:acf1efd9e5621725420f4c5926573b376 template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1efd9e5621725420f4c5926573b376">MAX</a> = std::numeric_limits&lt;Word&gt;::max()</td></tr>
<tr class="memdesc:acf1efd9e5621725420f4c5926573b376"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance with all its bits set to 1.  <br /></td></tr>
<tr class="memitem:a25e0e45234996261621fe95ff6fd4c4e" id="r_a25e0e45234996261621fe95ff6fd4c4e"><td class="memTemplParams" colspan="2">template&lt;Unsigned Word&gt; </td></tr>
<tr class="memitem:a25e0e45234996261621fe95ff6fd4c4e template"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e0e45234996261621fe95ff6fd4c4e">ALTERNATING</a> = <a class="el" href="#acf1efd9e5621725420f4c5926573b376">MAX</a>&lt;Word&gt; / 3</td></tr>
<tr class="memdesc:a25e0e45234996261621fe95ff6fd4c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance with alternating bits set to 0 and 1.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for the <span class="tt"><a class="el" href="namespacegf2.html" title="The namespace for the gf2 library.">gf2</a></span> library. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a887e28712d4d2013d795f9ee560ff793" name="a887e28712d4d2013d795f9ee560ff793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887e28712d4d2013d795f9ee560ff793">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::all </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all bits in the store are set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="note-26"></a>
Note</h1>
<p>Empty stores have no set bits (logical connective for <span class="tt"><a class="el" href="#a887e28712d4d2013d795f9ee560ff793" title="Returns true if all bits in the store are set, false otherwise.">all</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-325"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{3};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a887e28712d4d2013d795f9ee560ff793">all</a>(v), <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 1);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 2);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a887e28712d4d2013d795f9ee560ff793">all</a>(v), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html"><div class="ttname"><a href="classgf2_1_1BitVector.html">gf2::BitVector</a></div><div class="ttdoc">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...</div><div class="ttdef"><b>Definition</b> BitVector.h:23</div></div>
<div class="ttc" id="anamespacegf2_html_a0185d340520fd8519443cff59ddbe8a2"><div class="ttname"><a href="#a0185d340520fd8519443cff59ddbe8a2">gf2::set</a></div><div class="ttdeci">constexpr void set(Store &amp;store, usize i, bool value=true)</div><div class="ttdoc">Sets the bit-element at the given index to the specified boolean value (default value is true).</div><div class="ttdef"><b>Definition</b> BitStore.h:254</div></div>
<div class="ttc" id="anamespacegf2_html_a887e28712d4d2013d795f9ee560ff793"><div class="ttname"><a href="#a887e28712d4d2013d795f9ee560ff793">gf2::all</a></div><div class="ttdeci">constexpr bool all(Store const &amp;store)</div><div class="ttdoc">Returns true if all bits in the store are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:385</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad419c2360bc8c7b34615ecde32abc746" name="ad419c2360bc8c7b34615ecde32abc746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad419c2360bc8c7b34615ecde32abc746">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::any </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if at least one bit in the store is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="note-25"></a>
Note</h1>
<p>Empty stores have no set bits (logical connective for <span class="tt"><a class="el" href="#ad419c2360bc8c7b34615ecde32abc746" title="Returns true if at least one bit in the store is set, false otherwise.">any</a></span> is <span class="tt">OR</span> with identity <span class="tt">false</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-324"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ad419c2360bc8c7b34615ecde32abc746">any</a>(v), <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ad419c2360bc8c7b34615ecde32abc746">any</a>(v), <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacegf2_html_ad419c2360bc8c7b34615ecde32abc746"><div class="ttname"><a href="#ad419c2360bc8c7b34615ecde32abc746">gf2::any</a></div><div class="ttdeci">constexpr bool any(Store const &amp;store)</div><div class="ttdoc">Returns true if at least one bit in the store is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:363</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ea9570ad5ef2845429ce2e5aa2faa52" name="a6ea9570ad5ef2845429ce2e5aa2faa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea9570ad5ef2845429ce2e5aa2faa52">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::back </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the final bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-96"></a>
Panics</h1>
<p>In debug mode the method panics if the store is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-319"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a6ea9570ad5ef2845429ce2e5aa2faa52">back</a>(v), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#a03ce4352f6f0b4a759b7bb7d880928df">set_all</a>(v, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a6ea9570ad5ef2845429ce2e5aa2faa52">back</a>(v), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_abcfb7a88f30c8faa177519571a76ba8d"><div class="ttname"><a href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">gf2::BitVector::ones</a></div><div class="ttdeci">static constexpr BitVector ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVector.h:204</div></div>
<div class="ttc" id="anamespacegf2_html_a03ce4352f6f0b4a759b7bb7d880928df"><div class="ttname"><a href="#a03ce4352f6f0b4a759b7bb7d880928df">gf2::set_all</a></div><div class="ttdeci">constexpr void set_all(Store &amp;store, bool value=true)</div><div class="ttdoc">Sets the bits in the store to the boolean value.</div><div class="ttdef"><b>Definition</b> BitStore.h:439</div></div>
<div class="ttc" id="anamespacegf2_html_a6ea9570ad5ef2845429ce2e5aa2faa52"><div class="ttname"><a href="#a6ea9570ad5ef2845429ce2e5aa2faa52">gf2::back</a></div><div class="ttdeci">constexpr bool back(Store const &amp;store)</div><div class="ttdoc">Returns true if the final bit element is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:235</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2f80c44fd588d487a83e265202de69e9" name="a2f80c44fd588d487a83e265202de69e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f80c44fd588d487a83e265202de69e9">&#9670;&#160;</a></span>bit_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::bit_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit position within the containing word for bit element <span class="tt">i</span>. </p>
<p>Assumes we are holding bits in a sequence of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> words.</p>
<h1 class="doxsection"><a class="anchor" id="example-505"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a2f80c44fd588d487a83e265202de69e9">bit_offset&lt;u8&gt;</a>(0), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a2f80c44fd588d487a83e265202de69e9">bit_offset&lt;u8&gt;</a>(8), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a2f80c44fd588d487a83e265202de69e9">bit_offset&lt;u8&gt;</a>(19), 3);</div>
<div class="ttc" id="anamespacegf2_html_a2f80c44fd588d487a83e265202de69e9"><div class="ttname"><a href="#a2f80c44fd588d487a83e265202de69e9">gf2::bit_offset</a></div><div class="ttdeci">constexpr u8 bit_offset(usize i)</div><div class="ttdoc">Returns the bit position within the containing word for bit element i.</div><div class="ttdef"><b>Definition</b> Unsigned.h:563</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23dcec6af2e6ea3a742511ee90f3ad2b" name="a23dcec6af2e6ea3a742511ee90f3ad2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dcec6af2e6ea3a742511ee90f3ad2b">&#9670;&#160;</a></span>bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::bits </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const iterator over the values of the bits in the mutable bit-store. </p>
<p>You can use this iterator to iterate over the bits in the store to get <em>or</em> set the value of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="note-33"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-348"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : <a class="code hl_function" href="#a9505618cfe91d94fb220381ca468058e">bits</a>(v)) bit = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a66ff1e24db7bf631af2d638dd0b620c1"><div class="ttname"><a href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">gf2::BitVector::zeros</a></div><div class="ttdeci">static constexpr BitVector zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVector.h:196</div></div>
<div class="ttc" id="anamespacegf2_html_a355af2e0599965ef8d4eada941eee8e3"><div class="ttname"><a href="#a355af2e0599965ef8d4eada941eee8e3">gf2::to_string</a></div><div class="ttdeci">static std::string to_string(Store const &amp;store, std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;)</div><div class="ttdoc">Returns a binary string representation of a store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1587</div></div>
<div class="ttc" id="anamespacegf2_html_a9505618cfe91d94fb220381ca468058e"><div class="ttname"><a href="#a9505618cfe91d94fb220381ca468058e">gf2::bits</a></div><div class="ttdeci">constexpr auto bits(Store const &amp;store)</div><div class="ttdoc">Returns a const iterator over the bool values of the bits in the const bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1133</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9505618cfe91d94fb220381ca468058e" name="a9505618cfe91d94fb220381ca468058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9505618cfe91d94fb220381ca468058e">&#9670;&#160;</a></span>bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::bits </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-store. </p>
<p>You can use this iterator to iterate over the bits in the store and get the values of each bit as a <span class="tt">bool</span>.</p>
<h1 class="doxsection"><a class="anchor" id="note-32"></a>
Note</h1>
<p>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</p>
<h1 class="doxsection"><a class="anchor" id="example-347"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : <a class="code hl_function" href="#a9505618cfe91d94fb220381ca468058e">bits</a>(u)) assert_eq(bit, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3b0ea5c405d2ed08ce9fa5bbbb2cc169" name="a3b0ea5c405d2ed08ce9fa5bbbb2cc169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0ea5c405d2ed08ce9fa5bbbb2cc169">&#9670;&#160;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::convolve </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolutions: </p>
<p>Returns the convolution of two bit-stores as a new bit-vector.</p>
<p>The <em>convolution</em> of \(u\) and \(v\) is a vector with the elements \( (u * v)_k = \sum_j u_j v_{k-j+1} \) where the sum is taken over all \(j\) such that the indices in the formula are valid.</p>
<h1 class="doxsection"><a class="anchor" id="example-383"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(2);</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="#a3b0ea5c405d2ed08ce9fa5bbbb2cc169">convolve</a>(lhs, rhs);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(result), <span class="stringliteral">&quot;1001&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a3b0ea5c405d2ed08ce9fa5bbbb2cc169"><div class="ttname"><a href="#a3b0ea5c405d2ed08ce9fa5bbbb2cc169">gf2::convolve</a></div><div class="ttdeci">auto convolve(Lhs const &amp;lhs, Rhs const &amp;rhs)</div><div class="ttdoc">Convolutions:</div><div class="ttdef"><b>Definition</b> BitStore.h:2222</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa5f56a386e445b784b0cb9e59df06d1e" name="aa5f56a386e445b784b0cb9e59df06d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f56a386e445b784b0cb9e59df06d1e">&#9670;&#160;</a></span>copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter, BitStore Store&gt; <br />
requires std::is_unsigned_v&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::copy </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>src_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from an iteration of <em>any</em> unsigned integral <span class="tt">src</span> values to an <em>equal-sized</em> bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="note-29"></a>
Note</h1>
<p>We allow <em>any</em> unsigned integral source, e.g. copying <span class="tt"><a class="el" href="#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> words into a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of the correct size.</p>
<h1 class="doxsection"><a class="anchor" id="panics-101"></a>
Panics</h1>
<p>Panics if the size of the store does not match the number of bits in the source iteration.</p>
<h1 class="doxsection"><a class="anchor" id="example-330"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> v{48};</div>
<div class="line">std::vector&lt;u16&gt; src = { 0b1010101010101010, 0b1010101010101010, 0b1111111111111111 };</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">gf2::copy</a>(src.begin(), src.end(), v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u32&gt;</a> w{48};</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">gf2::copy</a>(src.begin(), src.end(), w);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(w), <span class="stringliteral">&quot;010101010101010101010101010101011111111111111111&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ab9a3ab2cfb7f67f6b195372d0e66e734"><div class="ttname"><a href="#ab9a3ab2cfb7f67f6b195372d0e66e734">gf2::copy</a></div><div class="ttdeci">constexpr void copy(Src src, Store &amp;store)</div><div class="ttdoc">Copies all the bits from any unsigned integral src value to an equal-sized bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:485</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8eb955c97a414b3b094534847cd75e97" name="a8eb955c97a414b3b094534847cd75e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb955c97a414b3b094534847cd75e97">&#9670;&#160;</a></span>copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Src, BitStore Dst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::copy </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dst &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> <span class="tt">src</span> bit-store to another <em>equal-sized</em> <span class="tt">dst</span> bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="note-30"></a>
Note:</h1>
<p>This is one of the few methods in the library that <em>doesn't</em> require the two stores to have the same <span class="tt">word_type</span>. You can use it to convert between different <span class="tt">word_type</span> stores (e.g., from <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="#ad1e43953e374bea8222087e4aba6c74a" title="Word type alias for a 32-bit unsigned integer.">u32</a>&gt;</span> to <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>) as long as the sizes match.</p>
<h1 class="doxsection"><a class="anchor" id="panics-102"></a>
Panics</h1>
<p>Panics if the sizes of the two stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-331"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u64&gt;::ones</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a>(<a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10), v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aeed3a5c646dbc7c38b4298574734ae4a"><div class="ttname"><a href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">gf2::BitVector::alternating</a></div><div class="ttdeci">static constexpr BitVector alternating(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n looking like 101010....</div><div class="ttdef"><b>Definition</b> BitVector.h:239</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab9a3ab2cfb7f67f6b195372d0e66e734" name="ab9a3ab2cfb7f67f6b195372d0e66e734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a3ab2cfb7f67f6b195372d0e66e734">&#9670;&#160;</a></span>copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Src, BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::copy </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from <em>any</em> unsigned integral <span class="tt">src</span> value to an <em>equal-sized</em> bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="note-28"></a>
Note</h1>
<ol type="1">
<li>We allow <em>any</em> unsigned integral source, e.g. copying a single <span class="tt"><a class="el" href="#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitVector.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVector</a>&lt;<a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of size 64.</li>
<li>The least-significant bit of the source becomes the bit at index 0 in the store.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="panics-100"></a>
Panics</h1>
<p>Panics if the size of the store does not match the number of bits in the source integer type.</p>
<h1 class="doxsection"><a class="anchor" id="example-329"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> v{16};</div>
<div class="line"><a class="code hl_typedef" href="#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a>(src, v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line">BitVector&lt;u32&gt; w{16};</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a>(src, w);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(w), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ae858164ae3b877b1f9ea2606fae215a0"><div class="ttname"><a href="#ae858164ae3b877b1f9ea2606fae215a0">gf2::u16</a></div><div class="ttdeci">std::uint16_t u16</div><div class="ttdoc">Word type alias for a 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa91135dc9362ddf9d47b1b9a6ec968da" name="aa91135dc9362ddf9d47b1b9a6ec968da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91135dc9362ddf9d47b1b9a6ec968da">&#9670;&#160;</a></span>copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> N, BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::copy </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the bits from a <span class="tt">std::bitset</span> to an <em>equal-sized</em> bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="note-31"></a>
Note</h1>
<p>A <span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> which is the reverse of our convention.</p>
<h1 class="doxsection"><a class="anchor" id="panics-103"></a>
Panics</h1>
<p>Panics if the size of the store does not match the number of bits in the source <span class="tt">std::bitset</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-332"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line">BitVector v{10};</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a>(src, v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a75cfaac28a1a498d1706808c3cfa6018" name="a75cfaac28a1a498d1706808c3cfa6018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cfaac28a1a498d1706808c3cfa6018">&#9670;&#160;</a></span>copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::copy </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bits from enumerating calls <span class="tt">f(i)</span> for each index in the bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="example-333"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line"><a class="code hl_function" href="#ab9a3ab2cfb7f67f6b195372d0e66e734">copy</a>(v, [](<a class="code hl_typedef" href="#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="classgf2_1_1BitVector.html#a8b10006eb120ea7fafdeecf68adb53cb">size</a>(), 10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a8b10006eb120ea7fafdeecf68adb53cb"><div class="ttname"><a href="classgf2_1_1BitVector.html#a8b10006eb120ea7fafdeecf68adb53cb">gf2::BitVector::size</a></div><div class="ttdeci">constexpr usize size() const</div><div class="ttdoc">Returns the number of bit-elements in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVector.h:50</div></div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa8fd09a196762464e1cffe2941779149" name="aa8fd09a196762464e1cffe2941779149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fd09a196762464e1cffe2941779149">&#9670;&#160;</a></span>count_ones() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::count_ones </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-335"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(v), 0);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(v), 1);</div>
<div class="ttc" id="anamespacegf2_html_aa8fd09a196762464e1cffe2941779149"><div class="ttname"><a href="#aa8fd09a196762464e1cffe2941779149">gf2::count_ones</a></div><div class="ttdeci">constexpr usize count_ones(Store const &amp;store)</div><div class="ttdoc">Returns the number of set bits in the store.</div><div class="ttdef"><b>Definition</b> BitStore.h:745</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab494f3b9b86c795386c72e6480bba20d" name="ab494f3b9b86c795386c72e6480bba20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab494f3b9b86c795386c72e6480bba20d">&#9670;&#160;</a></span>count_ones() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::count_ones </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-491"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8fd09a196762464e1cffe2941779149">count_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 8);</div>
<div class="ttc" id="anamespacegf2_html_a872a69469085fcdddf299ae4adc3c940"><div class="ttname"><a href="#a872a69469085fcdddf299ae4adc3c940">gf2::u8</a></div><div class="ttdeci">std::uint8_t u8</div><div class="ttdoc">Word type alias for an 8-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:30</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a52986a212b068f596f525deb963d8f59" name="a52986a212b068f596f525deb963d8f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52986a212b068f596f525deb963d8f59">&#9670;&#160;</a></span>count_zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::count_zeros </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-336"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(v), 10);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(v), 9);</div>
<div class="ttc" id="anamespacegf2_html_a52986a212b068f596f525deb963d8f59"><div class="ttname"><a href="#a52986a212b068f596f525deb963d8f59">gf2::count_zeros</a></div><div class="ttdeci">constexpr usize count_zeros(Store const &amp;store)</div><div class="ttdoc">Returns the number of unset bits in the store.</div><div class="ttdef"><b>Definition</b> BitStore.h:762</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6264be2f7bdac2305ba77b473294c801" name="a6264be2f7bdac2305ba77b473294c801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6264be2f7bdac2305ba77b473294c801">&#9670;&#160;</a></span>count_zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::count_zeros </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-492"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 8);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 7);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}), 7);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a52986a212b068f596f525deb963d8f59">count_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf41367b95076973a2fa4d81822fcf4b" name="adf41367b95076973a2fa4d81822fcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf41367b95076973a2fa4d81822fcf4b">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::describe </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detailed Description of a Bit-Store. </p>
<p>This method is useful for debugging but you should not rely on the output format which may change. </p>

</div>
</div>
<a id="aa0b17d68d248e21905835ba3f43e6d81" name="aa0b17d68d248e21905835ba3f43e6d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b17d68d248e21905835ba3f43e6d81">&#9670;&#160;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word, BitStore Lhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::dot </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><span class="tt">Bit-vector, bit-matrix multiplication, </span>v * M`, returning a new bit-vector. </p>
<p><b>Note:</b> We store bit-matrices by rows so <span class="tt">dot(BitMatrix, BitVector)</span> will always be faster than this. </p>

</div>
</div>
<a id="ab3b25bbe4b0a598204faaaaed9614a91" name="ab3b25bbe4b0a598204faaaaed9614a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b25bbe4b0a598204faaaaed9614a91">&#9670;&#160;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::dot </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot Products: </p>
<p>Returns the dot product of <span class="tt">lhs</span> and <span class="tt">rhs</span> as a boolean value.</p>
<p>For any pair of vector-like types, the dot product is: \(u * v = \sum_i u_i v_i \) where the sum is over all the indices so the two operands must have the same length. In GF(2) the sum is modulo 2 and, by convention, the scalar output is a boolean value.</p>
<h1 class="doxsection"><a class="anchor" id="panics-118"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-381"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a612727967670558acfd0fd2adc99eccf">dot</a>(v1, v1), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a612727967670558acfd0fd2adc99eccf">dot</a>(v1, v2), <span class="keyword">false</span>);</div>
<div class="ttc" id="anamespacegf2_html_a612727967670558acfd0fd2adc99eccf"><div class="ttname"><a href="#a612727967670558acfd0fd2adc99eccf">gf2::dot</a></div><div class="ttdeci">constexpr auto dot(BitMatrix&lt; Word &gt; const &amp;lhs, Rhs const &amp;rhs)</div><div class="ttdoc">Bit-matrix, bit-store multiplication, M * v, returning a new bit-vector.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2573</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac6cf8bbef5f96104b2e770e54abdd08a" name="ac6cf8bbef5f96104b2e770e54abdd08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cf8bbef5f96104b2e770e54abdd08a">&#9670;&#160;</a></span>fill_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::fill_random </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the store with random bits based on an optional probability <span class="tt">p</span> and an optional <span class="tt">seed</span> for the RNG. </p>
<p>The default call <span class="tt"><a class="el" href="#ac6cf8bbef5f96104b2e770e54abdd08a" title="Fill the store with random bits based on an optional probability p and an optional seed for the RNG.">fill_random()</a></span> sets each bit to 1 with probability 0.5 (fair coin).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the fill is all zeros, if <span class="tt">p &gt; 1</span> then the fill is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-334"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> u{10}, v{10};</div>
<div class="line"><a class="code hl_typedef" href="#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><a class="code hl_function" href="#ac6cf8bbef5f96104b2e770e54abdd08a">fill_random</a>(u, 0.5, seed);</div>
<div class="line"><a class="code hl_function" href="#ac6cf8bbef5f96104b2e770e54abdd08a">fill_random</a>(v, 0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="anamespacegf2_html_a770302128133591da0ca93ded6abf8aa"><div class="ttname"><a href="#a770302128133591da0ca93ded6abf8aa">gf2::u64</a></div><div class="ttdeci">std::uint64_t u64</div><div class="ttdoc">Word type alias for a 64-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:39</div></div>
<div class="ttc" id="anamespacegf2_html_ac6cf8bbef5f96104b2e770e54abdd08a"><div class="ttname"><a href="#ac6cf8bbef5f96104b2e770e54abdd08a">gf2::fill_random</a></div><div class="ttdeci">constexpr void fill_random(Store &amp;store, double p=0.5, u64 seed=0)</div><div class="ttdoc">Fill the store with random bits based on an optional probability p and an optional seed for the RNG.</div><div class="ttdef"><b>Definition</b> BitStore.h:697</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1f962bf6ba97b31c476d19c37da8bd05" name="a1f962bf6ba97b31c476d19c37da8bd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f962bf6ba97b31c476d19c37da8bd05">&#9670;&#160;</a></span>first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::first_set </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first set bit in the bit-store or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-339"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 2);</div>
<div class="line">assert(<a class="code hl_function" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a>(v) == std::optional&lt;usize&gt;{2});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 2, <span class="keyword">false</span>);</div>
<div class="line">assert(<a class="code hl_function" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 27);</div>
<div class="line">assert(<a class="code hl_function" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a>(v) == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(<a class="code hl_function" href="#a1f962bf6ba97b31c476d19c37da8bd05">first_set</a>(empty) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_a1f962bf6ba97b31c476d19c37da8bd05"><div class="ttname"><a href="#a1f962bf6ba97b31c476d19c37da8bd05">gf2::first_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_set(Store const &amp;store)</div><div class="ttdoc">Returns the index of the first set bit in the bit-store or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitStore.h:841</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a044dac4df02b26e8d4713a39ce170e7d" name="a044dac4df02b26e8d4713a39ce170e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044dac4df02b26e8d4713a39ce170e7d">&#9670;&#160;</a></span>first_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::first_unset </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-343"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#a044dac4df02b26e8d4713a39ce170e7d">first_unset</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2,<span class="keyword">false</span>);</div>
<div class="line">assert(<a class="code hl_function" href="#a044dac4df02b26e8d4713a39ce170e7d">first_unset</a>(v) == std::optional&lt;usize&gt;{2});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2);</div>
<div class="line">assert(<a class="code hl_function" href="#a044dac4df02b26e8d4713a39ce170e7d">first_unset</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27,<span class="keyword">false</span>);</div>
<div class="line">assert(<a class="code hl_function" href="#a044dac4df02b26e8d4713a39ce170e7d">first_unset</a>(v) == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(empty.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_a044dac4df02b26e8d4713a39ce170e7d"><div class="ttname"><a href="#a044dac4df02b26e8d4713a39ce170e7d">gf2::first_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_unset(Store const &amp;store)</div><div class="ttdoc">Returns the index of the first unset bit in the bit-store or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitStore.h:974</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa424649d48359d85a30260dc0de4835a" name="aa424649d48359d85a30260dc0de4835a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa424649d48359d85a30260dc0de4835a">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::flip </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bit-element at the given <span class="tt">index</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-98"></a>
Panics</h1>
<p>In debug mode the method panics if the index is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-321"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><a class="code hl_function" href="#aa424649d48359d85a30260dc0de4835a">flip</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0111111111&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#aa424649d48359d85a30260dc0de4835a">flip</a>(v, 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0011111111&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#aa424649d48359d85a30260dc0de4835a">flip</a>(v, 9);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0011111110&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_aa424649d48359d85a30260dc0de4835a"><div class="ttname"><a href="#aa424649d48359d85a30260dc0de4835a">gf2::flip</a></div><div class="ttdeci">constexpr void flip(Store &amp;store, usize i)</div><div class="ttdoc">Flips the value of the bit-element at the given index.</div><div class="ttdef"><b>Definition</b> BitStore.h:279</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94314a30722546a006db2f38a2b8a054" name="a94314a30722546a006db2f38a2b8a054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94314a30722546a006db2f38a2b8a054">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::flip_all </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bits in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-328"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a94314a30722546a006db2f38a2b8a054">flip_all</a>(v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a94314a30722546a006db2f38a2b8a054"><div class="ttname"><a href="#a94314a30722546a006db2f38a2b8a054">gf2::flip_all</a></div><div class="ttdeci">constexpr void flip_all(Store &amp;store)</div><div class="ttdoc">Flips the value of the bits in the store.</div><div class="ttdef"><b>Definition</b> BitStore.h:455</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abd42e52e9163fa845d30cc5ff02d7a7c" name="abd42e52e9163fa845d30cc5ff02d7a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd42e52e9163fa845d30cc5ff02d7a7c">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::front </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="panics-95"></a>
Panics</h1>
<p>In debug mode the method panics if the store is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-318"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abd42e52e9163fa845d30cc5ff02d7a7c">front</a>(v), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#a03ce4352f6f0b4a759b7bb7d880928df">set_all</a>(v, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abd42e52e9163fa845d30cc5ff02d7a7c">front</a>(v), <span class="keyword">false</span>);</div>
<div class="ttc" id="anamespacegf2_html_abd42e52e9163fa845d30cc5ff02d7a7c"><div class="ttname"><a href="#abd42e52e9163fa845d30cc5ff02d7a7c">gf2::front</a></div><div class="ttdeci">constexpr bool front(Store const &amp;store)</div><div class="ttdoc">Returns true if the first bit element is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:216</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a690f9210e98f6a9615fc5b9cabd67cd3" name="a690f9210e98f6a9615fc5b9cabd67cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690f9210e98f6a9615fc5b9cabd67cd3">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::get </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bool value of the bit at index <span class="tt">i</span> in the given bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="panics-94"></a>
Panics</h1>
<p>In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-316"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(v, 0), <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(v, 0), <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacegf2_html_a690f9210e98f6a9615fc5b9cabd67cd3"><div class="ttname"><a href="#a690f9210e98f6a9615fc5b9cabd67cd3">gf2::get</a></div><div class="ttdeci">constexpr bool get(Store const &amp;store, usize i)</div><div class="ttdoc">Returns the bool value of the bit at index i in the given bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:168</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd6d1d759f8496d8c2158208bcfde29e" name="acd6d1d759f8496d8c2158208bcfde29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6d1d759f8496d8c2158208bcfde29e">&#9670;&#160;</a></span>highest_set_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt; gf2::highest_set_bit </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the highest set bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-498"></a>
Example</h1>
<div class="fragment"><div class="line">assert(<a class="code hl_function" href="#acd6d1d759f8496d8c2158208bcfde29e">highest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}) == std::optional&lt;u8&gt;{});</div>
<div class="line">assert(<a class="code hl_function" href="#acd6d1d759f8496d8c2158208bcfde29e">highest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}) == std::optional&lt;u8&gt;{0});</div>
<div class="line">assert(<a class="code hl_function" href="#acd6d1d759f8496d8c2158208bcfde29e">highest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}) == std::optional&lt;u8&gt;{1});</div>
<div class="line">assert(<a class="code hl_function" href="#acd6d1d759f8496d8c2158208bcfde29e">highest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1000&#39;0000}) == std::optional&lt;u8&gt;{7});</div>
<div class="ttc" id="anamespacegf2_html_acd6d1d759f8496d8c2158208bcfde29e"><div class="ttname"><a href="#acd6d1d759f8496d8c2158208bcfde29e">gf2::highest_set_bit</a></div><div class="ttdeci">constexpr std::optional&lt; u8 &gt; highest_set_bit(Word word)</div><div class="ttdoc">Returns the index of the highest set bit in an Unsigned or std::nullopt if no bits are set.</div><div class="ttdef"><b>Definition</b> Unsigned.h:445</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aff9eea4f2c110bd80b9a086d7cb8a08b" name="aff9eea4f2c110bd80b9a086d7cb8a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9eea4f2c110bd80b9a086d7cb8a08b">&#9670;&#160;</a></span>highest_unset_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt; gf2::highest_unset_bit </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the highest unset bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-500"></a>
Example</h1>
<div class="fragment"><div class="line">assert(<a class="code hl_function" href="#aff9eea4f2c110bd80b9a086d7cb8a08b">highest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}) == std::optional&lt;u8&gt;{});</div>
<div class="line">assert(<a class="code hl_function" href="#aff9eea4f2c110bd80b9a086d7cb8a08b">highest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1100&#39;0000}) == std::optional&lt;u8&gt;{5});</div>
<div class="line">assert(<a class="code hl_function" href="#aff9eea4f2c110bd80b9a086d7cb8a08b">highest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0001&#39;0011}) == std::optional&lt;u8&gt;{7});</div>
<div class="line">assert(<a class="code hl_function" href="#aff9eea4f2c110bd80b9a086d7cb8a08b">highest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1000&#39;0000}) == std::optional&lt;u8&gt;{6});</div>
<div class="ttc" id="anamespacegf2_html_aff9eea4f2c110bd80b9a086d7cb8a08b"><div class="ttname"><a href="#aff9eea4f2c110bd80b9a086d7cb8a08b">gf2::highest_unset_bit</a></div><div class="ttdeci">constexpr std::optional&lt; u8 &gt; highest_unset_bit(Word word)</div><div class="ttdoc">Returns the index of the highest unset bit in an Unsigned or std::nullopt if there are none.</div><div class="ttdef"><b>Definition</b> Unsigned.h:477</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab29bbe0565dac39f445fcd73fd83cad7" name="ab29bbe0565dac39f445fcd73fd83cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29bbe0565dac39f445fcd73fd83cad7">&#9670;&#160;</a></span>index_and_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>, Word &gt; gf2::index_and_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair of the index of the word and a mask isolating bit element <span class="tt">i</span>. </p>
<ul>
<li>Assumes we are holding bits in a sequence of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> words.</li>
<li>Use with structured binding e.g. <span class="tt">auto [index, mask] = <a class="el" href="#ab29bbe0565dac39f445fcd73fd83cad7" title="Returns a pair of the index of the word and a mask isolating bit element i.">gf2::index_and_mask</a>&lt;<a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">gf2::u8</a>&gt;(i);</span></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-507"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#ab29bbe0565dac39f445fcd73fd83cad7">index_and_mask&lt;u8&gt;</a>(0), (std::pair{0, 1}));</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ab29bbe0565dac39f445fcd73fd83cad7">index_and_mask&lt;u8&gt;</a>(8), (std::pair{1, 1}));</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ab29bbe0565dac39f445fcd73fd83cad7">index_and_mask&lt;u8&gt;</a>(19), (std::pair{2, 1 &lt;&lt; 3}));</div>
<div class="ttc" id="anamespacegf2_html_ab29bbe0565dac39f445fcd73fd83cad7"><div class="ttname"><a href="#ab29bbe0565dac39f445fcd73fd83cad7">gf2::index_and_mask</a></div><div class="ttdeci">constexpr std::pair&lt; usize, Word &gt; index_and_mask(usize i)</div><div class="ttdoc">Returns a pair of the index of the word and a mask isolating bit element i.</div><div class="ttdef"><b>Definition</b> Unsigned.h:597</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a296a376731b5bbb8601659fda1f230c4" name="a296a376731b5bbb8601659fda1f230c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296a376731b5bbb8601659fda1f230c4">&#9670;&#160;</a></span>index_and_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt; gf2::index_and_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair of the index of the word and the bit position within the word for bit element <span class="tt">i</span>. </p>
<ul>
<li>Assumes we are holding bits in a sequence of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> words.</li>
<li>Use with structured binding e.g. <span class="tt">auto [index, offset] = <a class="el" href="#a296a376731b5bbb8601659fda1f230c4" title="Returns a pair of the index of the word and the bit position within the word for bit element i.">gf2::index_and_offset</a>&lt;gf::u8&gt;(i);</span></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-506"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a296a376731b5bbb8601659fda1f230c4">index_and_offset&lt;u8&gt;</a>(0), (std::pair{0, 0}));</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a296a376731b5bbb8601659fda1f230c4">index_and_offset&lt;u8&gt;</a>(8), (std::pair{1, 0}));</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a296a376731b5bbb8601659fda1f230c4">index_and_offset&lt;u8&gt;</a>(19), (std::pair{2, 3}));</div>
<div class="ttc" id="anamespacegf2_html_a296a376731b5bbb8601659fda1f230c4"><div class="ttname"><a href="#a296a376731b5bbb8601659fda1f230c4">gf2::index_and_offset</a></div><div class="ttdeci">constexpr std::pair&lt; usize, u8 &gt; index_and_offset(usize i)</div><div class="ttdoc">Returns a pair of the index of the word and the bit position within the word for bit element i.</div><div class="ttdef"><b>Definition</b> Unsigned.h:580</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2008016cc135d5c4738ac1cfbcb411a4" name="a2008016cc135d5c4738ac1cfbcb411a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2008016cc135d5c4738ac1cfbcb411a4">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::is_empty </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the store is empty, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="example-323"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a2008016cc135d5c4738ac1cfbcb411a4">is_empty</a>(v), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> u{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a2008016cc135d5c4738ac1cfbcb411a4">is_empty</a>(u), <span class="keyword">false</span>);</div>
<div class="ttc" id="anamespacegf2_html_a2008016cc135d5c4738ac1cfbcb411a4"><div class="ttname"><a href="#a2008016cc135d5c4738ac1cfbcb411a4">gf2::is_empty</a></div><div class="ttdeci">constexpr bool is_empty(Store const &amp;store)</div><div class="ttdoc">Returns true if the store is empty, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:345</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a10232b64eb69a81bc462f7b7cc18e0fc" name="a10232b64eb69a81bc462f7b7cc18e0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10232b64eb69a81bc462f7b7cc18e0fc">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::join </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new bit-vector formed by joining two bit-stores <span class="tt">lhs</span> and <span class="tt">rhs</span>. </p>
<p>This is one of the few methods in library that allows the operands to have different word types. The returned bit-vector will use the same word type as <span class="tt">lhs</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-359"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u16&gt;::zeros</a>(12);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(12);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a10232b64eb69a81bc462f7b7cc18e0fc">join</a>(lhs, rhs);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;000000000000111111111111&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a10232b64eb69a81bc462f7b7cc18e0fc"><div class="ttname"><a href="#a10232b64eb69a81bc462f7b7cc18e0fc">gf2::join</a></div><div class="ttdeci">auto join(Lhs const &amp;lhs, Rhs const &amp;rhs)</div><div class="ttdoc">Returns a new bit-vector formed by joining two bit-stores lhs and rhs.</div><div class="ttdef"><b>Definition</b> BitStore.h:1435</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa87a762ead610d0d0e20e54e3380d7d" name="afa87a762ead610d0d0e20e54e3380d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa87a762ead610d0d0e20e54e3380d7d">&#9670;&#160;</a></span>last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::last_set </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last set bit in the bit-store or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-340"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#afa87a762ead610d0d0e20e54e3380d7d">last_set</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 2);</div>
<div class="line">assert(<a class="code hl_function" href="#afa87a762ead610d0d0e20e54e3380d7d">last_set</a>(v) == std::optional&lt;usize&gt;{2});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 27);</div>
<div class="line">assert(<a class="code hl_function" href="#afa87a762ead610d0d0e20e54e3380d7d">last_set</a>(v) == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(<a class="code hl_function" href="#afa87a762ead610d0d0e20e54e3380d7d">last_set</a>(empty) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_afa87a762ead610d0d0e20e54e3380d7d"><div class="ttname"><a href="#afa87a762ead610d0d0e20e54e3380d7d">gf2::last_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_set(Store const &amp;store)</div><div class="ttdoc">Returns the index of the last set bit in the bit-store or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitStore.h:866</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad8089c96553359e761a5916ce39c420c" name="ad8089c96553359e761a5916ce39c420c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8089c96553359e761a5916ce39c420c">&#9670;&#160;</a></span>last_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::last_unset </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-344"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#ad8089c96553359e761a5916ce39c420c">last_unset</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2, <span class="keyword">false</span>);</div>
<div class="line">assert(<a class="code hl_function" href="#ad8089c96553359e761a5916ce39c420c">last_unset</a>(v) == std::optional&lt;usize&gt;{2});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2);</div>
<div class="line">assert(<a class="code hl_function" href="#ad8089c96553359e761a5916ce39c420c">last_unset</a>(v) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27, <span class="keyword">false</span>);</div>
<div class="line">assert(<a class="code hl_function" href="#ad8089c96553359e761a5916ce39c420c">last_unset</a>(v) == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(empty.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_ad8089c96553359e761a5916ce39c420c"><div class="ttname"><a href="#ad8089c96553359e761a5916ce39c420c">gf2::last_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_unset(Store const &amp;store)</div><div class="ttdoc">Returns the index of the last unset bit in the bit-store or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitStore.h:1007</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad8a4b2b04947c9d1764cc5e64c7e18f9" name="ad8a4b2b04947c9d1764cc5e64c7e18f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">&#9670;&#160;</a></span>leading_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::leading_ones </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading ones in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-496"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">leading_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">leading_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">leading_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1000&#39;0010}), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">leading_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 8);</div>
<div class="ttc" id="anamespacegf2_html_ad8a4b2b04947c9d1764cc5e64c7e18f9"><div class="ttname"><a href="#ad8a4b2b04947c9d1764cc5e64c7e18f9">gf2::leading_ones</a></div><div class="ttdeci">constexpr u8 leading_ones(Word word)</div><div class="ttdoc">Returns the number of leading ones in an Unsigned.</div><div class="ttdef"><b>Definition</b> Unsigned.h:410</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9ee66f54ef560ada72c85ce60ebab33" name="aa9ee66f54ef560ada72c85ce60ebab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ee66f54ef560ada72c85ce60ebab33">&#9670;&#160;</a></span>leading_zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::leading_zeros </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-337"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{37};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(v), 37);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 27);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(v), 27);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(w), 0);</div>
<div class="ttc" id="anamespacegf2_html_aa9ee66f54ef560ada72c85ce60ebab33"><div class="ttname"><a href="#aa9ee66f54ef560ada72c85ce60ebab33">gf2::leading_zeros</a></div><div class="ttdeci">constexpr usize leading_zeros(Store const &amp;store)</div><div class="ttdoc">Returns the number of leading zeros in the store.</div><div class="ttdef"><b>Definition</b> BitStore.h:779</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a730c7cf46f5de572063287be53c53e70" name="a730c7cf46f5de572063287be53c53e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c7cf46f5de572063287be53c53e70">&#9670;&#160;</a></span>leading_zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::leading_zeros </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-494"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 8);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 7);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}), 6);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa9ee66f54ef560ada72c85ce60ebab33">leading_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aed00c8ab60ee9aa9e5783e8e9a224f99" name="aed00c8ab60ee9aa9e5783e8e9a224f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed00c8ab60ee9aa9e5783e8e9a224f99">&#9670;&#160;</a></span>lowest_set_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt; gf2::lowest_set_bit </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the lowest set bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-497"></a>
Example</h1>
<div class="fragment"><div class="line">assert(<a class="code hl_function" href="#aed00c8ab60ee9aa9e5783e8e9a224f99">lowest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}) == std::optional&lt;u8&gt;{});</div>
<div class="line">assert(<a class="code hl_function" href="#aed00c8ab60ee9aa9e5783e8e9a224f99">lowest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}) == std::optional&lt;u8&gt;{0});</div>
<div class="line">assert(<a class="code hl_function" href="#aed00c8ab60ee9aa9e5783e8e9a224f99">lowest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}) == std::optional&lt;u8&gt;{1});</div>
<div class="line">assert(<a class="code hl_function" href="#aed00c8ab60ee9aa9e5783e8e9a224f99">lowest_set_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1000&#39;0000}) == std::optional&lt;u8&gt;{7});</div>
<div class="ttc" id="anamespacegf2_html_aed00c8ab60ee9aa9e5783e8e9a224f99"><div class="ttname"><a href="#aed00c8ab60ee9aa9e5783e8e9a224f99">gf2::lowest_set_bit</a></div><div class="ttdeci">constexpr std::optional&lt; u8 &gt; lowest_set_bit(Word word)</div><div class="ttdoc">Returns the index of the lowest set bit in an Unsigned or std::nullopt if no bits are set.</div><div class="ttdef"><b>Definition</b> Unsigned.h:425</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac0de53666c9c94f325f36d8f5f0f8290" name="ac0de53666c9c94f325f36d8f5f0f8290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0de53666c9c94f325f36d8f5f0f8290">&#9670;&#160;</a></span>lowest_unset_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> &gt; gf2::lowest_unset_bit </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the lowest unset bit in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> or <span class="tt">std::nullopt</span> if there are no unset bits. </p>
<h1 class="doxsection"><a class="anchor" id="example-499"></a>
Example</h1>
<div class="fragment"><div class="line">assert(<a class="code hl_function" href="#ac0de53666c9c94f325f36d8f5f0f8290">lowest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}) == std::optional&lt;u8&gt;{});</div>
<div class="line">assert(<a class="code hl_function" href="#ac0de53666c9c94f325f36d8f5f0f8290">lowest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0001&#39;1000}) == std::optional&lt;u8&gt;{0});</div>
<div class="line">assert(<a class="code hl_function" href="#ac0de53666c9c94f325f36d8f5f0f8290">lowest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;1001}) == std::optional&lt;u8&gt;{1});</div>
<div class="line">assert(<a class="code hl_function" href="#ac0de53666c9c94f325f36d8f5f0f8290">lowest_unset_bit</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1000&#39;1111}) == std::optional&lt;u8&gt;{4});</div>
<div class="ttc" id="anamespacegf2_html_ac0de53666c9c94f325f36d8f5f0f8290"><div class="ttname"><a href="#ac0de53666c9c94f325f36d8f5f0f8290">gf2::lowest_unset_bit</a></div><div class="ttdeci">constexpr std::optional&lt; u8 &gt; lowest_unset_bit(Word word)</div><div class="ttdoc">Returns the index of the lowest unset bit in an Unsigned or std::nullopt if there are no unset bits.</div><div class="ttdef"><b>Definition</b> Unsigned.h:461</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84d33fc3ba98b78ab3ad44fba88df2c1" name="a84d33fc3ba98b78ab3ad44fba88df2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d33fc3ba98b78ab3ad44fba88df2c1">&#9670;&#160;</a></span>next_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::next_set </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next set bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more set bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-341"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#a84d33fc3ba98b78ab3ad44fba88df2c1">next_set</a>(v,0) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27);</div>
<div class="line">assert(<a class="code hl_function" href="#a84d33fc3ba98b78ab3ad44fba88df2c1">next_set</a>(v,0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(<a class="code hl_function" href="#a84d33fc3ba98b78ab3ad44fba88df2c1">next_set</a>(v,2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(<a class="code hl_function" href="#a84d33fc3ba98b78ab3ad44fba88df2c1">next_set</a>(v,27) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_a84d33fc3ba98b78ab3ad44fba88df2c1"><div class="ttname"><a href="#a84d33fc3ba98b78ab3ad44fba88df2c1">gf2::next_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_set(Store const &amp;store, usize index)</div><div class="ttdoc">Returns the index of the next set bit after index in the store or {} if no more set bits exist.</div><div class="ttdef"><b>Definition</b> BitStore.h:890</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2253deaf8dec9af0a0b3e3f4af24f49d" name="a2253deaf8dec9af0a0b3e3f4af24f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2253deaf8dec9af0a0b3e3f4af24f49d">&#9670;&#160;</a></span>next_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::next_unset </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next unset bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-345"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2, <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.next_unset(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.next_unset(27) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="classgf2_1_1BitVector.html#aa6ec1590bad64a8ff835918eed8afb50">next_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_aa6ec1590bad64a8ff835918eed8afb50"><div class="ttname"><a href="classgf2_1_1BitVector.html#aa6ec1590bad64a8ff835918eed8afb50">gf2::BitVector::next_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_unset(usize index) const</div><div class="ttdoc">Returns the index of the next unset bit after index in the bit-vector or {} if no more unset bits exi...</div><div class="ttdef"><b>Definition</b> BitVector.h:1508</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac257bfdd661157913f820bcd96ced815" name="ac257bfdd661157913f820bcd96ced815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac257bfdd661157913f820bcd96ced815">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::none </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no bits in the store are set, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="note-27"></a>
Note</h1>
<p>Empty store have no set bits (logical connective for <span class="tt"><a class="el" href="#ac257bfdd661157913f820bcd96ced815" title="Returns true if no bits in the store are set, false otherwise.">none</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</p>
<h1 class="doxsection"><a class="anchor" id="example-326"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac257bfdd661157913f820bcd96ced815">none</a>(v), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac257bfdd661157913f820bcd96ced815">none</a>(v), <span class="keyword">false</span>);</div>
<div class="ttc" id="anamespacegf2_html_ac257bfdd661157913f820bcd96ced815"><div class="ttname"><a href="#ac257bfdd661157913f820bcd96ced815">gf2::none</a></div><div class="ttdeci">constexpr bool none(Store const &amp;store)</div><div class="ttdoc">Returns true if no bits in the store are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitStore.h:419</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a262d78bc376e61bb7993c6cbb62c7f13" name="a262d78bc376e61bb7993c6cbb62c7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262d78bc376e61bb7993c6cbb62c7f13">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <span class="tt">AND</span> of two equal-sized bit-stores as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-112"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-375"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line"><span class="keyword">auto</span> v3 = v1 &amp; v2;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v3), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae1fee012a210fa3a0cbdc95c0129b789" name="ae1fee012a210fa3a0cbdc95c0129b789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fee012a210fa3a0cbdc95c0129b789">&#9670;&#160;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">Lhs &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">AND</span> of one bit-store with an equal-sized bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="panics-109"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-371"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">v1 &amp;= ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v1), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac94607ff1ae0693b1beac65dd6356000" name="ac94607ff1ae0693b1beac65dd6356000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94607ff1ae0693b1beac65dd6356000">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word, BitStore Lhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator* </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitMatrix.html">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator form for bit-vector, bit-matrix multiplication, <span class="tt">v * M</span>, returning a new bit-vector. </p>
<p><b>Note:</b> We store bit-matrices by rows so <span class="tt">dot(BitMatrix, BitVector)</span> will always be faster than this. </p>

</div>
</div>
<a id="a20bb9b68837d5556f2f34127365679fa" name="a20bb9b68837d5556f2f34127365679fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bb9b68837d5556f2f34127365679fa">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::operator* </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator <span class="tt">*</span> returns the dot product of <span class="tt">lhs</span> and <span class="tt">rhs</span> as a boolean value. </p>
<p>For any pair of vector-like types, the dot product is: \(u * v = \sum_i u_i v_i \) where the sum is over all the indices so the two operands must have the same length. In GF(2) the sum is modulo 2 and, by convention, the scalar output is a boolean value.</p>
<h1 class="doxsection"><a class="anchor" id="panics-119"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-382"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line">assert_eq(v1*v1, <span class="keyword">true</span>);</div>
<div class="line">assert_eq(v1*v2, <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad15366027d99c7dbb1f02ffe1c8dd03d" name="ad15366027d99c7dbb1f02ffe1c8dd03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15366027d99c7dbb1f02ffe1c8dd03d">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator+ </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two equal-sized bit-stores and returns the result as a new bit-vector. </p>
<p>In GF(2) addition is the same as <span class="tt">XOR</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-116"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-379"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line"><span class="keyword">auto</span> v3 = v1 + v2;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v3), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7ea68d994ef5b413822fe67c735d452a" name="a7ea68d994ef5b413822fe67c735d452a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea68d994ef5b413822fe67c735d452a">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator+= </td>
          <td>(</td>
          <td class="paramtype">Lhs &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition of one bit-store with an equal-sized bit-store. </p>
<p>In GF(2) addition is the same as <span class="tt">XOR</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-114"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-377"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">v1 += ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v1), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a92d7eb66f490d301485d15466635edda" name="a92d7eb66f490d301485d15466635edda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d7eb66f490d301485d15466635edda">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator- </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two equal-sized bit-stores and returns the result as a new bit-vector. </p>
<p>In GF(2) addition is the same as <span class="tt">XOR</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-117"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-380"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line"><span class="keyword">auto</span> v3 = v1 - v2;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v3), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a97b4bd320f0d11a6cb5ae25135034d47" name="a97b4bd320f0d11a6cb5ae25135034d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4bd320f0d11a6cb5ae25135034d47">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator-= </td>
          <td>(</td>
          <td class="paramtype">Lhs &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place difference of one bit-store with an equal-sized bit-store. </p>
<p>In GF(2) difference is the same as <span class="tt">XOR</span>.</p>
<h1 class="doxsection"><a class="anchor" id="panics-115"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-378"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">v1 -= ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v1), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af4e6d9629201dc37d74a7bc90e8ed975" name="af4e6d9629201dc37d74a7bc90e8ed975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e6d9629201dc37d74a7bc90e8ed975">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the store shifted left by <span class="tt">shift</span> bits. </p>
<p>Shifting is in <em>vector-order</em> so if <span class="tt">v = [v0,v1,v2,v3]</span> then <span class="tt">v &lt;&lt; 1</span> is <span class="tt">[v1,v2,v3,0]</span> with zeros added to the right. Left shifting in vector-order is the same as right shifting in bit-order.</p>
<p><b>Note:</b> Only accessible bits are affected by the shift.</p>
<h1 class="doxsection"><a class="anchor" id="example-368"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line"><span class="keyword">auto</span> w = v &lt;&lt; 8;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(w), <span class="stringliteral">&quot;11111111111100000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0e049b3d556045b8d38bf64ef5ae48ba" name="a0e049b3d556045b8d38bf64ef5ae48ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e049b3d556045b8d38bf64ef5ae48ba">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place left shift of a bit-store by <span class="tt">shift</span> bits. </p>
<p>Shifting is in <em>vector-order</em> so if <span class="tt">v = [v0,v1,v2,v3]</span> then <span class="tt">v &lt;&lt;= 1</span> is <span class="tt">[v1,v2,v3,0]</span> with zeros added to the right. Left shifting in vector-order is the same as right shifting in bit-order.</p>
<p><b>Note:</b> Only accessible bits are affected by the shift.</p>
<h1 class="doxsection"><a class="anchor" id="example-366"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line">v &lt;&lt;= 8;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;11111111111100000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a13bccb650d933d19ec4c91bbfe7f0ef8" name="a13bccb650d933d19ec4c91bbfe7f0ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bccb650d933d19ec4c91bbfe7f0ef8">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf2::operator== </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that any pair of bit-stores are equal in content. </p>
<p>Equality here means that the two bit-stores have identical content and <em>also</em> the same underlying word_type word. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(55);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(55);</div>
<div class="line">assert(u == v);</div>
<div class="line">v.set(23, <span class="keyword">false</span>);</div>
<div class="line">assert(u != v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23dd3d7f7ef4a78f9ab65d54e5d394ad" name="a23dd3d7f7ef4a78f9ab65d54e5d394ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dd3d7f7ef4a78f9ab65d54e5d394ad">&#9670;&#160;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is <span class="tt">lhs</span> shifted right by <span class="tt">shift</span> bits. </p>
<p>Shifting is in <em>vector-order</em> so if <span class="tt">v = [v0,v1,v2,v3]</span> then <span class="tt">v &gt;&gt;= 1</span> is <span class="tt">[0,v0,v1,v2]</span> with zeros added to the left. Right shifting in vector-order is the same as left shifting in bit-order.</p>
<p><b>Note:</b> Only accessible bits are affected by the shift.</p>
<h1 class="doxsection"><a class="anchor" id="example-369"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line"><span class="keyword">auto</span> w = v &gt;&gt; 8;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(w), <span class="stringliteral">&quot;00000000111111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa074227777980943f4e0a52c2abb2e3e" name="aa074227777980943f4e0a52c2abb2e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa074227777980943f4e0a52c2abb2e3e">&#9670;&#160;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place right shift of a store by <span class="tt">shift</span> bits. </p>
<p>Shifting is in <em>vector-order</em> so if <span class="tt">v = [v0,v1,v2,v3]</span> then <span class="tt">v &gt;&gt;= 1</span> is <span class="tt">[0,v0,v1,v2]</span> with zeros added to the left. Right shifting in vector-order is the same as left shifting in bit-order.</p>
<p><b>Note:</b> Only accessible bits are affected by the shift.</p>
<h1 class="doxsection"><a class="anchor" id="example-367"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(20);</div>
<div class="line">v &gt;&gt;= 8;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;00000000111111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1687ef8e4f015f7387912bd013500584" name="a1687ef8e4f015f7387912bd013500584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1687ef8e4f015f7387912bd013500584">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator^ </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <span class="tt">XOR</span> of two equal-sized bit-stores as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-111"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-374"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line"><span class="keyword">auto</span> v3 = v1 ^ v2;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v3), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a39ac1c9c4e8d925816d2bc5ff12e0711" name="a39ac1c9c4e8d925816d2bc5ff12e0711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ac1c9c4e8d925816d2bc5ff12e0711">&#9670;&#160;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator^= </td>
          <td>(</td>
          <td class="paramtype">Lhs &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">XOR</span> of one bit-store with an equal-sized bit-store. </p>
<p><b>Note:</b> Only accessible bits are affected by the shift.</p>
<h1 class="doxsection"><a class="anchor" id="example-370"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">v1 ^= ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v1), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afb56bf15d46a0f53489a06a88ea0f96c" name="afb56bf15d46a0f53489a06a88ea0f96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb56bf15d46a0f53489a06a88ea0f96c">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator| </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <span class="tt">OR</span> of two equal-sized bit-stores as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-113"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-376"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> v2 = ~v1;</div>
<div class="line"><span class="keyword">auto</span> v3 = v1 | v2;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v3), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a266cc1d698afa04717e29bf09bf94935" name="a266cc1d698afa04717e29bf09bf94935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266cc1d698afa04717e29bf09bf94935">&#9670;&#160;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, typename Rhs::word_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::operator|= </td>
          <td>(</td>
          <td class="paramtype">Lhs &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">OR</span> of one bit-store with an equal-sized bit-store. </p>
<h1 class="doxsection"><a class="anchor" id="panics-110"></a>
Panics</h1>
<p>In debug mode, this method panics if the lengths of the two bit-stores do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-372"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">v1 |= ~v1;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v1), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a63cdbdaf058edb19748525579aaa0118" name="a63cdbdaf058edb19748525579aaa0118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cdbdaf058edb19748525579aaa0118">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::operator~ </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that has the same bits as a bit-store but with all the bits flipped. </p>
<h1 class="doxsection"><a class="anchor" id="example-373"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = ~v;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(w), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7acc8bbe9a3578c1d8b9e8659c2bd891" name="a7acc8bbe9a3578c1d8b9e8659c2bd891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">&#9670;&#160;</a></span>previous_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::previous_set </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous set bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-342"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(<a class="code hl_function" href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">previous_set</a>(v,36) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27);</div>
<div class="line">assert(<a class="code hl_function" href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">previous_set</a>(v,36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(<a class="code hl_function" href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">previous_set</a>(v,27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(<a class="code hl_function" href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">previous_set</a>(v,2)  == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="anamespacegf2_html_a7acc8bbe9a3578c1d8b9e8659c2bd891"><div class="ttname"><a href="#a7acc8bbe9a3578c1d8b9e8659c2bd891">gf2::previous_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_set(Store const &amp;store, usize index)</div><div class="ttdoc">Returns the index of the previous set bit before index in the store or {} if there are none.</div><div class="ttdef"><b>Definition</b> BitStore.h:928</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaee9a90d260c8210b965a7b9aaf54570" name="aaee9a90d260c8210b965a7b9aaf54570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee9a90d260c8210b965a7b9aaf54570">&#9670;&#160;</a></span>previous_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; gf2::previous_unset </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous unset bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-346"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.previous_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,2, <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v,27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.previous_unset(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.previous_unset(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.previous_unset(2) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="classgf2_1_1BitVector.html#a9000a2348948286e3d12eacaa5948ff6">previous_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a9000a2348948286e3d12eacaa5948ff6"><div class="ttname"><a href="classgf2_1_1BitVector.html#a9000a2348948286e3d12eacaa5948ff6">gf2::BitVector::previous_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_unset(usize index) const</div><div class="ttdoc">Returns the index of the previous unset bit before index in the bit-vector or {} if no more unset bit...</div><div class="ttdef"><b>Definition</b> BitVector.h:1525</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a44a358ee6c3e8f2c57c85745d37f867f" name="a44a358ee6c3e8f2c57c85745d37f867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a358ee6c3e8f2c57c85745d37f867f">&#9670;&#160;</a></span>ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::ref </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "reference" to the bit element <span class="tt">i</span> in the given bit-store. </p>
<p>The returned object is a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference for the bit element at <span class="tt">index</span> rather than a true reference.</p>
<h1 class="doxsection"><a class="anchor" id="note-24"></a>
Note</h1>
<p>The referenced bit-store must continue to exist while the <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is in use. In debug mode the index <span class="tt">i</span> is bounds-checked.</p>
<h1 class="doxsection"><a class="anchor" id="example-317"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line"><a class="code hl_function" href="#a44a358ee6c3e8f2c57c85745d37f867f">ref</a>(v, 2) = <span class="keyword">true</span>;</div>
<div class="line">assert(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v) == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a44a358ee6c3e8f2c57c85745d37f867f">ref</a>(v, 3) = <a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(w, 3);</div>
<div class="line">assert(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v) == <span class="stringliteral">&quot;0011000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a44a358ee6c3e8f2c57c85745d37f867f">ref</a>(v, 4) |= <a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(w, 4);</div>
<div class="line">assert(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v) == <span class="stringliteral">&quot;0011100000&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a44a358ee6c3e8f2c57c85745d37f867f"><div class="ttname"><a href="#a44a358ee6c3e8f2c57c85745d37f867f">gf2::ref</a></div><div class="ttdeci">constexpr auto ref(Store &amp;store, usize i)</div><div class="ttdoc">Returns a &quot;reference&quot; to the bit element i in the given bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:197</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23f5a30c88d6d08c6751fb8cc6b747d6" name="a23f5a30c88d6d08c6751fb8cc6b747d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f5a30c88d6d08c6751fb8cc6b747d6">&#9670;&#160;</a></span>replace_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word, typename Other&gt; <br />
requires std::convertible_to&lt;Other, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::replace_bits </td>
          <td>(</td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the bits of <span class="tt">word</span> in the range <span class="tt">[begin, end)</span> with the bits from <span class="tt">other</span> leaving the rest unchanged. </p>
<p>The range is <em>half</em> open so the <span class="tt">end</span> bit is not copied.</p>
<p>The <span class="tt">Other</span> type must be convertible to <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>, perhaps by just removing a <span class="tt">const</span> qualifier.</p>
<h1 class="doxsection"><a class="anchor" id="panics-147"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-489"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b1111&#39;1111;</div>
<div class="line"><a class="code hl_function" href="#a23f5a30c88d6d08c6751fb8cc6b747d6">replace_bits</a>(word, 1, 3, 0b0000&#39;0000);</div>
<div class="line">assert_eq(word, 0b1111&#39;1001);</div>
<div class="ttc" id="anamespacegf2_html_a23f5a30c88d6d08c6751fb8cc6b747d6"><div class="ttname"><a href="#a23f5a30c88d6d08c6751fb8cc6b747d6">gf2::replace_bits</a></div><div class="ttdeci">constexpr void replace_bits(Word &amp;word, u8 begin, u8 end, Other other)</div><div class="ttdoc">Replace the bits of word in the range [begin, end) with the bits from other leaving the rest unchange...</div><div class="ttdef"><b>Definition</b> Unsigned.h:272</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7e371a5f346a2c3830a8293d172aaa22" name="a7e371a5f346a2c3830a8293d172aaa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e371a5f346a2c3830a8293d172aaa22">&#9670;&#160;</a></span>reset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::reset_bits </td>
          <td>(</td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the bits in the half-open range <span class="tt">[begin, end)</span> of <span class="tt">word</span> to zero, leaving the others unchanged. </p>
<h1 class="doxsection"><a class="anchor" id="panics-144"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-485"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b1111&#39;1111;</div>
<div class="line"><a class="code hl_function" href="#a7e371a5f346a2c3830a8293d172aaa22">reset_bits</a>(word, 1, 3);</div>
<div class="line">assert_eq(word, 0b1111&#39;1001);</div>
<div class="ttc" id="anamespacegf2_html_a7e371a5f346a2c3830a8293d172aaa22"><div class="ttname"><a href="#a7e371a5f346a2c3830a8293d172aaa22">gf2::reset_bits</a></div><div class="ttdeci">constexpr void reset_bits(Word &amp;word, u8 begin, u8 end)</div><div class="ttdoc">Resets the bits in the half-open range [begin, end) of word to zero, leaving the others unchanged.</div><div class="ttdef"><b>Definition</b> Unsigned.h:176</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf5400c9f48fc978113d9ca054b03290" name="adf5400c9f48fc978113d9ca054b03290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5400c9f48fc978113d9ca054b03290">&#9670;&#160;</a></span>reset_except_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::reset_except_bits </td>
          <td>(</td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits of <span class="tt">word</span> to 0 <em>except</em> for those in the half-open range <span class="tt">[begin, end)</span> which are unchanged. </p>
<h1 class="doxsection"><a class="anchor" id="panics-146"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-487"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b1111&#39;1111;</div>
<div class="line"><a class="code hl_function" href="#adf5400c9f48fc978113d9ca054b03290">reset_except_bits</a>(word, 1, 3);</div>
<div class="line">assert_eq(word, 0b000&#39;0110);</div>
<div class="ttc" id="anamespacegf2_html_adf5400c9f48fc978113d9ca054b03290"><div class="ttname"><a href="#adf5400c9f48fc978113d9ca054b03290">gf2::reset_except_bits</a></div><div class="ttdeci">constexpr void reset_except_bits(Word &amp;word, u8 begin, u8 end)</div><div class="ttdoc">Sets the bits of word to 0 except for those in the half-open range [begin, end) which are unchanged.</div><div class="ttdef"><b>Definition</b> Unsigned.h:222</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4139e2fe17c87caf6ed958e228b79de9" name="a4139e2fe17c87caf6ed958e228b79de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4139e2fe17c87caf6ed958e228b79de9">&#9670;&#160;</a></span>reverse_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::reverse_bits </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of <span class="tt">word</span> with all its bits reversed. </p>
<p>Reverses the order of bits in <span class="tt">word</span>. The least significant bit becomes the most significant bit, second least-significant bit becomes second most-significant bit, etc.</p>
<h1 class="doxsection"><a class="anchor" id="example-488"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#ad1e43953e374bea8222087e4aba6c74a">u32</a>  n32 = 0x12345678;</div>
<div class="line"><span class="keyword">auto</span> m32 = <a class="code hl_function" href="#a4139e2fe17c87caf6ed958e228b79de9">reverse_bits</a>(n32);</div>
<div class="line">assert_eq(m32, 0x1e6a2c48);</div>
<div class="line"><a class="code hl_typedef" href="#a770302128133591da0ca93ded6abf8aa">u64</a>  n64 = 0x1234567890123456;</div>
<div class="line"><span class="keyword">auto</span> m64 = <a class="code hl_function" href="#a4139e2fe17c87caf6ed958e228b79de9">reverse_bits</a>(n64);</div>
<div class="line">assert_eq(m64, 0x6a2c48091e6a2c48);</div>
<div class="line"><a class="code hl_typedef" href="#ae858164ae3b877b1f9ea2606fae215a0">u16</a> zero = 0;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a4139e2fe17c87caf6ed958e228b79de9">reverse_bits</a>(zero), 0);</div>
<div class="ttc" id="anamespacegf2_html_a4139e2fe17c87caf6ed958e228b79de9"><div class="ttname"><a href="#a4139e2fe17c87caf6ed958e228b79de9">gf2::reverse_bits</a></div><div class="ttdeci">constexpr Word reverse_bits(Word word)</div><div class="ttdoc">Returns a copy of word with all its bits reversed.</div><div class="ttdef"><b>Definition</b> Unsigned.h:249</div></div>
<div class="ttc" id="anamespacegf2_html_ad1e43953e374bea8222087e4aba6c74a"><div class="ttname"><a href="#ad1e43953e374bea8222087e4aba6c74a">gf2::u32</a></div><div class="ttdeci">std::uint32_t u32</div><div class="ttdoc">Word type alias for a 32-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:36</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae70d7e49dce7447eeb6b66bbc03bb2a5" name="ae70d7e49dce7447eeb6b66bbc03bb2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70d7e49dce7447eeb6b66bbc03bb2a5">&#9670;&#160;</a></span>riffle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::riffle </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the result of riffling the bits in this bit-store with zeros. </p>
<p>If bit-store has the bits <span class="tt">abcde</span> then the output bit-vector will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-361"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> dst = <a class="code hl_function" href="#ac462028756047a28bd47ba5134841371">riffle</a>(v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(dst), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ac462028756047a28bd47ba5134841371"><div class="ttname"><a href="#ac462028756047a28bd47ba5134841371">gf2::riffle</a></div><div class="ttdeci">constexpr void riffle(Store const &amp;store, BitVector&lt; typename Store::word_type &gt; &amp;dst)</div><div class="ttdoc">Interleaves the bits of a bit-store with zeros storing the result into the passed bit-vector dst.</div><div class="ttdef"><b>Definition</b> BitStore.h:1467</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac462028756047a28bd47ba5134841371" name="ac462028756047a28bd47ba5134841371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac462028756047a28bd47ba5134841371">&#9670;&#160;</a></span>riffle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::riffle </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the bits of a bit-store with zeros storing the result into the passed bit-vector <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> will have the bits of this bit-store interleaved with zeros. For example, if this bit-store has the bits <span class="tt">abcde</span> then <span class="tt">dst</span> will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<p><b>Note:</b> There is no last zero bit in <span class="tt">dst</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-360"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector&lt;u8&gt;</a> dst;</div>
<div class="line"><a class="code hl_function" href="#ac462028756047a28bd47ba5134841371">riffle</a>(v, dst);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(dst), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1096406612c1629a626fbc9a083a4054" name="a1096406612c1629a626fbc9a083a4054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1096406612c1629a626fbc9a083a4054">&#9670;&#160;</a></span>riffle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Word, Word &gt; gf2::riffle </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Riffles an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> into a pair of others containing the bits in the original word interleaved with zeros. </p>
<p>For example, if <span class="tt">self</span> is a <span class="tt"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a></span> with the binary representation <span class="tt">abcdefgh</span>, then on return <span class="tt">lo</span> will have the bits <span class="tt">0a0b0c0d</span> and <span class="tt">hi</span> will have the bits <span class="tt">0e0f0g0h</span>. The <span class="tt">lo</span> and <span class="tt">hi</span> words are returned in a tuple.</p>
<h1 class="doxsection"><a class="anchor" id="example-490"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b1111&#39;1111;</div>
<div class="line"><span class="keyword">auto</span> [lo, hi] = <a class="code hl_function" href="#ac462028756047a28bd47ba5134841371">riffle</a>(word);</div>
<div class="line">assert_eq(lo, 0b0101&#39;0101);</div>
<div class="line">assert_eq(hi, 0b0101&#39;0101);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0185d340520fd8519443cff59ddbe8a2" name="a0185d340520fd8519443cff59ddbe8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0185d340520fd8519443cff59ddbe8a2">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::set </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit-element at the given <span class="tt">index</span> to the specified boolean <span class="tt">value</span> (default <span class="tt">value</span> is <span class="tt">true</span>). </p>
<h1 class="doxsection"><a class="anchor" id="panics-97"></a>
Panics</h1>
<p>In debug mode the method panics if the index is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-320"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(v, 0), <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a690f9210e98f6a9615fc5b9cabd67cd3">get</a>(v, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a03ce4352f6f0b4a759b7bb7d880928df" name="a03ce4352f6f0b4a759b7bb7d880928df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ce4352f6f0b4a759b7bb7d880928df">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::set_all </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits in the store to the boolean <span class="tt">value</span>. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-327"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a03ce4352f6f0b4a759b7bb7d880928df">set_all</a>(v);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6c46a7570efd21105aa42c7d14c997d1" name="a6c46a7570efd21105aa42c7d14c997d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c46a7570efd21105aa42c7d14c997d1">&#9670;&#160;</a></span>set_bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::set_bits </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-store. </p>
<p>You can use this iterator to iterate over the set bits in the store and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-349"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(<a class="code hl_function" href="#a6c46a7570efd21105aa42c7d14c997d1">set_bits</a>(v));</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{0, 2, 4, 6, 8}));</div>
<div class="ttc" id="anamespacegf2_html_a6c46a7570efd21105aa42c7d14c997d1"><div class="ttname"><a href="#a6c46a7570efd21105aa42c7d14c997d1">gf2::set_bits</a></div><div class="ttdeci">constexpr auto set_bits(Store const &amp;store)</div><div class="ttdoc">Returns an iterator over the indices of any set bits in the bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1170</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a39fa3e7982acfbab6caa685ce6310258" name="a39fa3e7982acfbab6caa685ce6310258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fa3e7982acfbab6caa685ce6310258">&#9670;&#160;</a></span>set_bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::set_bits </td>
          <td>(</td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits in the half-open range <span class="tt">[begin, end)</span> of <span class="tt">word</span> to one, leaving the others unchanged. </p>
<h1 class="doxsection"><a class="anchor" id="panics-143"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-484"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b0000&#39;0000;</div>
<div class="line"><a class="code hl_function" href="#a6c46a7570efd21105aa42c7d14c997d1">set_bits</a>(word, 1, 3);</div>
<div class="line">assert_eq(word, 0b0000&#39;0110);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2e476cee5220beaaf11e0052f8980dc7" name="a2e476cee5220beaaf11e0052f8980dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e476cee5220beaaf11e0052f8980dc7">&#9670;&#160;</a></span>set_except_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::set_except_bits </td>
          <td>(</td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits of <span class="tt">word</span> to 1 <em>except</em> for those in the half-open range <span class="tt">[begin, end)</span> which are unchanged. </p>
<h1 class="doxsection"><a class="anchor" id="panics-145"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-486"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> word = 0b0000&#39;0000;</div>
<div class="line"><a class="code hl_function" href="#a2e476cee5220beaaf11e0052f8980dc7">set_except_bits</a>(word, 1, 3);</div>
<div class="line">assert_eq(word, 0b1111&#39;1001);</div>
<div class="ttc" id="anamespacegf2_html_a2e476cee5220beaaf11e0052f8980dc7"><div class="ttname"><a href="#a2e476cee5220beaaf11e0052f8980dc7">gf2::set_except_bits</a></div><div class="ttdeci">constexpr void set_except_bits(Word &amp;word, u8 begin, u8 end)</div><div class="ttdoc">Sets the bits of word to 1 except for those in the half-open range [begin, end) which are unchanged.</div><div class="ttdef"><b>Definition</b> Unsigned.h:199</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ade1775a262530e2cfd40b51256ad8b85" name="ade1775a262530e2cfd40b51256ad8b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1775a262530e2cfd40b51256ad8b85">&#9670;&#160;</a></span>span() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gf2::span </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-span over the bit-store <span class="tt">store</span> for its bits in the range <span class="tt">[begin, end)</span>. This span allows modification of the underlying bits (unless its created from a span that is itself const). </p>
<p>It is the responsibility of the caller to ensure that the underlying bit-store continues to exist for as long as the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="panics-105"></a>
Panics</h1>
<p>This method panics if the span range is invalid.</p>
<h1 class="doxsection"><a class="anchor" id="example-355"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = <a class="code hl_function" href="#a91642aa97f8c3823b3630dde99574a8b">span</a>(v, 1, 5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(s), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a91642aa97f8c3823b3630dde99574a8b"><div class="ttname"><a href="#a91642aa97f8c3823b3630dde99574a8b">gf2::span</a></div><div class="ttdeci">static constexpr auto span(Store const &amp;store, usize begin, usize end)</div><div class="ttdoc">Constructs a read-only bit-span over the const bit-store store for its bits in the range [begin,...</div><div class="ttdef"><b>Definition</b> BitStore.h:1276</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91642aa97f8c3823b3630dde99574a8b" name="a91642aa97f8c3823b3630dde99574a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91642aa97f8c3823b3630dde99574a8b">&#9670;&#160;</a></span>span() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gf2::span </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a read-only bit-span over the const bit-store <span class="tt">store</span> for its bits in the range <span class="tt">[begin, end)</span>. </p>
<p>It is the responsibility of the caller to ensure that the underlying bit-store continues to exist for as long as the <span class="tt"><a class="el" href="classgf2_1_1BitSpan.html" title="A bit_span is a non-owning view of contiguous bits in a bit-store.  .">BitSpan</a></span> is in use.</p>
<h1 class="doxsection"><a class="anchor" id="panics-104"></a>
Panics</h1>
<p>This method panics if the span range is invalid.</p>
<h1 class="doxsection"><a class="anchor" id="example-354"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = <a class="code hl_function" href="#a91642aa97f8c3823b3630dde99574a8b">span</a>(v, 1, 5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(s), <span class="stringliteral">&quot;0101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0838a227d5f2bfec59c69798f0692d31" name="a0838a227d5f2bfec59c69798f0692d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0838a227d5f2bfec59c69798f0692d31">&#9670;&#160;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::split </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span> respectively. Clones of the parts are returned as a pair of new bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>]. </p>
<p>On return, <span class="tt">left</span> is a clone of the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<h1 class="doxsection"><a class="anchor" id="panics-108"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-358"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> [left, right] = <a class="code hl_function" href="#a56284774b49c6d8b626c41eb23c285db">split</a>(v, 5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(left), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(right), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a56284774b49c6d8b626c41eb23c285db"><div class="ttname"><a href="#a56284774b49c6d8b626c41eb23c285db">gf2::split</a></div><div class="ttdeci">constexpr void split(Store const &amp;store, usize at, BitVector&lt; typename Store::word_type &gt; &amp;left, BitVector&lt; typename Store::word_type &gt; &amp;right)</div><div class="ttdoc">Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively....</div><div class="ttdef"><b>Definition</b> BitStore.h:1386</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a56284774b49c6d8b626c41eb23c285db" name="a56284774b49c6d8b626c41eb23c285db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56284774b49c6d8b626c41eb23c285db">&#9670;&#160;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::split </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; typename Store::word_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, size())</span> respectively. Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>. </p>
<p>On return, <span class="tt">left</span> contains the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<p>This lets one reuse the <span class="tt">left</span> and <span class="tt">right</span> destinations without having to allocate new bit-vectors. This is useful when implementing iterative algorithms that need to split a bit-vector into two parts repeatedly.</p>
<h1 class="doxsection"><a class="anchor" id="panics-107"></a>
Panics</h1>
<p>This method panics if the split point is beyond the end of the bit-vector.</p>
<h1 class="doxsection"><a class="anchor" id="example-357"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> left, right;</div>
<div class="line"><a class="code hl_function" href="#a56284774b49c6d8b626c41eb23c285db">split</a>(v, 5, left, right);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(left), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(right), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a832a9327ac2dac0ce3ebe50f6fed021d" name="a832a9327ac2dac0ce3ebe50f6fed021d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832a9327ac2dac0ce3ebe50f6fed021d">&#9670;&#160;</a></span>store_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::store_words </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over all the <em>words</em> underlying the bit-store. </p>
<p>You can use this iterator to iterate over the words in the store and read the <span class="tt">Word</span> value of each word. You <b>cannot</b> use this iterator to modify the words in the store.</p>
<h1 class="doxsection"><a class="anchor" id="note-34"></a>
Note</h1>
<p>The words here may be a synthetic construct. The expectation is that the bit <span class="tt">0</span> in the store is located at the bit-location <span class="tt">0</span> of <span class="tt">word(0)</span>. That is always the case for bit-vectors but bit-slices typically synthesise "words" on the fly from adjacent pairs of real underlying words. Nevertheless, almost all the methods in <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> are implemented efficiently by operating on those words.</p>
<h1 class="doxsection"><a class="anchor" id="example-351"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> words = std::ranges::to&lt;std::vector&gt;(<a class="code hl_function" href="#a832a9327ac2dac0ce3ebe50f6fed021d">store_words</a>(v));</div>
<div class="line">assert_eq(words, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="ttc" id="anamespacegf2_html_a832a9327ac2dac0ce3ebe50f6fed021d"><div class="ttname"><a href="#a832a9327ac2dac0ce3ebe50f6fed021d">gf2::store_words</a></div><div class="ttdeci">constexpr auto store_words(Store const &amp;store)</div><div class="ttdoc">Returns a const iterator over all the words underlying the bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1211</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8fe2ab8650590f082f800d223fdd6422" name="a8fe2ab8650590f082f800d223fdd6422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe2ab8650590f082f800d223fdd6422">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::sub </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="panics-106"></a>
Panics</h1>
<p>This method panics if the span range is invalid.</p>
<h1 class="doxsection"><a class="anchor" id="example-356"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = <a class="code hl_function" href="#a8fe2ab8650590f082f800d223fdd6422">sub</a>(v,1,5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(s), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(s), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a8fe2ab8650590f082f800d223fdd6422"><div class="ttname"><a href="#a8fe2ab8650590f082f800d223fdd6422">gf2::sub</a></div><div class="ttdeci">constexpr auto sub(Store const &amp;store, usize begin, usize end)</div><div class="ttdoc">Returns a clone of the elements in the half-open range [begin, end) as a new bit-vector.</div><div class="ttdef"><b>Definition</b> BitStore.h:1355</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23cbb1ad7a7a0ce5c2f8835564cc21ec" name="a23cbb1ad7a7a0ce5c2f8835564cc21ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::swap </td>
          <td>(</td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bits in the bit-store at indices <span class="tt">i0</span> and <span class="tt">i1</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-99"></a>
Panics</h1>
<p>In debug mode the method panics if either index is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-322"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">swap</a>(v, 0, 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0100000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">swap</a>(v, 0, 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">swap</a>(v, 0, 9);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">swap</a>(v, 0, 9);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a23cbb1ad7a7a0ce5c2f8835564cc21ec"><div class="ttname"><a href="#a23cbb1ad7a7a0ce5c2f8835564cc21ec">gf2::swap</a></div><div class="ttdeci">constexpr void swap(Store &amp;store, usize i0, usize i1)</div><div class="ttdoc">Swaps the bits in the bit-store at indices i0 and i1.</div><div class="ttdef"><b>Definition</b> BitStore.h:307</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af1900fd540d8f3670454d39b003d9667" name="af1900fd540d8f3670454d39b003d9667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1900fd540d8f3670454d39b003d9667">&#9670;&#160;</a></span>to_binary_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of a store. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The bit-store to convert to a binary string. </td></tr>
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-362"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(v), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(v), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(v, <span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_af1900fd540d8f3670454d39b003d9667"><div class="ttname"><a href="#af1900fd540d8f3670454d39b003d9667">gf2::to_binary_string</a></div><div class="ttdeci">static std::string to_binary_string(Store const &amp;store, std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;)</div><div class="ttdoc">Returns a binary string representation of a store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1536</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8e4d17607e82f5392f9c52b57cefbbda" name="a8e4d17607e82f5392f9c52b57cefbbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4d17607e82f5392f9c52b57cefbbda">&#9670;&#160;</a></span>to_binary_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the binary string representation of an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> showing <em>all</em> the bits. </p>
<h1 class="doxsection"><a class="anchor" id="example-501"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0011}), <span class="stringliteral">&quot;00000011&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), <span class="stringliteral">&quot;11111111&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8641a61d375c82684b921764e373cce" name="aa8641a61d375c82684b921764e373cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8641a61d375c82684b921764e373cce">&#9670;&#160;</a></span>to_hex_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_hex_string </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "hex" string representation of the bits in the bit-store. </p>
<p>The output is a string of hex characters without any spaces, commas, or other formatting.</p>
<p>The string may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
 Empty bit-vectors are represented as the empty string.</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<p>The output is in <em>vector-order</em>. If "h0" is the first hex digit in the output string, you can print it as four binary digits <span class="tt">v_0v_1v_2v_3</span>. For example, if h0 = "A" which is <span class="tt">1010</span> in binary, then v = 1010.</p>
<h1 class="doxsection"><a class="anchor" id="example-365"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v0;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(v0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(4);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(v1), <span class="stringliteral">&quot;F&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(v2), <span class="stringliteral">&quot;F1.2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(8);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af1900fd540d8f3670454d39b003d9667">to_binary_string</a>(v3), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(v3), <span class="stringliteral">&quot;AA&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_aa8641a61d375c82684b921764e373cce"><div class="ttname"><a href="#aa8641a61d375c82684b921764e373cce">gf2::to_hex_string</a></div><div class="ttdeci">static std::string to_hex_string(Store const &amp;store)</div><div class="ttdoc">Returns the &quot;hex&quot; string representation of the bits in the bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1641</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afe64e61826101a505216e9c18ff2564a" name="afe64e61826101a505216e9c18ff2564a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe64e61826101a505216e9c18ff2564a">&#9670;&#160;</a></span>to_hex_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_hex_string </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hex string representation of an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> showing <em>all</em> the bits. </p>
<h1 class="doxsection"><a class="anchor" id="example-502"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0011}), <span class="stringliteral">&quot;03&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aa8641a61d375c82684b921764e373cce">to_hex_string</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), <span class="stringliteral">&quot;FF&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a id="a75fa1cd092371f7093307f09dbd71c55" name="a75fa1cd092371f7093307f09dbd71c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fa1cd092371f7093307f09dbd71c55">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_pretty_string </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "pretty" string representation of a store. </p>
<p>The output is a string of 0's and 1's with spaces between each bit, and the whole thing enclosed in square brackets.</p>
<h1 class="doxsection"><a class="anchor" id="example-364"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a75fa1cd092371f7093307f09dbd71c55">to_pretty_string</a>(v), <span class="stringliteral">&quot;[1,0,1,0,1,0,1,0,1,0]&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> empty;</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a75fa1cd092371f7093307f09dbd71c55">to_pretty_string</a>(empty), <span class="stringliteral">&quot;[]&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_a75fa1cd092371f7093307f09dbd71c55"><div class="ttname"><a href="#a75fa1cd092371f7093307f09dbd71c55">gf2::to_pretty_string</a></div><div class="ttdeci">static std::string to_pretty_string(Store const &amp;store)</div><div class="ttdoc">Returns a &quot;pretty&quot; string representation of a store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1605</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a355af2e0599965ef8d4eada941eee8e3" name="a355af2e0599965ef8d4eada941eee8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355af2e0599965ef8d4eada941eee8e3">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gf2::to_string </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of a store. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The bit-store to convert to a binary string. </td></tr>
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-363"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classgf2_1_1BitVector.html">BitVector</a> v{10};</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v, <span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91d03fc055e7a9b1f082e80b34b30bbf" name="a91d03fc055e7a9b1f082e80b34b30bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d03fc055e7a9b1f082e80b34b30bbf">&#9670;&#160;</a></span>to_words() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::to_words </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-store as new <span class="tt">std::vector</span>. </p>
<h1 class="doxsection"><a class="anchor" id="note-36"></a>
Note</h1>
<ul>
<li>The last word in the store may not be fully occupied but unused slots will be all zeros.</li>
<li>The returned <span class="tt">std::vector</span>'s element type will be the same as the store's <span class="tt">word_type</span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-353"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> words = <a class="code hl_function" href="#abda627169916e771d25c9a1af8dad123">to_words</a>(v);</div>
<div class="line">assert_eq(words, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="ttc" id="anamespacegf2_html_abda627169916e771d25c9a1af8dad123"><div class="ttname"><a href="#abda627169916e771d25c9a1af8dad123">gf2::to_words</a></div><div class="ttdeci">constexpr void to_words(Store const &amp;store, std::output_iterator&lt; typename Store::word_type &gt; auto out)</div><div class="ttdoc">Returns a copy of the words underlying this bit-store and puts them into the passed output iterator.</div><div class="ttdef"><b>Definition</b> BitStore.h:1234</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abda627169916e771d25c9a1af8dad123" name="abda627169916e771d25c9a1af8dad123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda627169916e771d25c9a1af8dad123">&#9670;&#160;</a></span>to_words() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gf2::to_words </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::output_iterator&lt; typename Store::word_type &gt; auto</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-store and puts them into the passed output iterator. </p>
<h1 class="doxsection"><a class="anchor" id="note-35"></a>
Note</h1>
<ol type="1">
<li>The last word in the store may not be fully occupied but unused slots will be all zeros.</li>
<li>The output iterator must be able to accept values of the store's <span class="tt">word_type</span>.</li>
<li>The output iterator must have enough space to accept all the words in the store.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="example-352"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;u8&gt;::ones</a>(10);</div>
<div class="line">std::vector&lt;u8&gt; out8(v.words());</div>
<div class="line"><a class="code hl_function" href="#abda627169916e771d25c9a1af8dad123">to_words</a>(v, out8.begin());</div>
<div class="line">assert_eq(out8, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="line">std::vector&lt;u16&gt; out16(v.words());</div>
<div class="line"><a class="code hl_function" href="#abda627169916e771d25c9a1af8dad123">to_words</a>(v, out16.begin());</div>
<div class="line">assert_eq(out16, (std::vector&lt;u16&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf0dbd78e459e1125e4fd7c636853e35" name="adf0dbd78e459e1125e4fd7c636853e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0dbd78e459e1125e4fd7c636853e35">&#9670;&#160;</a></span>trailing_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::trailing_ones </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing ones in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-495"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#adf0dbd78e459e1125e4fd7c636853e35">trailing_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#adf0dbd78e459e1125e4fd7c636853e35">trailing_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#adf0dbd78e459e1125e4fd7c636853e35">trailing_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#adf0dbd78e459e1125e4fd7c636853e35">trailing_ones</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 8);</div>
<div class="ttc" id="anamespacegf2_html_adf0dbd78e459e1125e4fd7c636853e35"><div class="ttname"><a href="#adf0dbd78e459e1125e4fd7c636853e35">gf2::trailing_ones</a></div><div class="ttdeci">constexpr u8 trailing_ones(Word word)</div><div class="ttdoc">Returns the number of trailing ones in an Unsigned.</div><div class="ttdef"><b>Definition</b> Unsigned.h:395</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abdf2434cc208bb1633add06c3619bf06" name="abdf2434cc208bb1633add06c3619bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf2434cc208bb1633add06c3619bf06">&#9670;&#160;</a></span>trailing_zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::trailing_zeros </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-338"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;u8&gt;::zeros</a>(27);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(v), 27);</div>
<div class="line"><a class="code hl_function" href="#a0185d340520fd8519443cff59ddbe8a2">set</a>(v, 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(v), 26);</div>
<div class="ttc" id="anamespacegf2_html_abdf2434cc208bb1633add06c3619bf06"><div class="ttname"><a href="#abdf2434cc208bb1633add06c3619bf06">gf2::trailing_zeros</a></div><div class="ttdeci">constexpr usize trailing_zeros(Store const &amp;store)</div><div class="ttdoc">Returns the number of trailing zeros in the store.</div><div class="ttdef"><b>Definition</b> BitStore.h:800</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abd96d700874211c947d7ca863fd8372e" name="abd96d700874211c947d7ca863fd8372e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd96d700874211c947d7ca863fd8372e">&#9670;&#160;</a></span>trailing_zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::trailing_zeros </td>
          <td>(</td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-493"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0000}), 8);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0001}), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0000&#39;0010}), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#abdf2434cc208bb1633add06c3619bf06">trailing_zeros</a>(<a class="code hl_typedef" href="#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b1111&#39;1111}), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a976e9da1d5515af13d3d805fa2339b58" name="a976e9da1d5515af13d3d805fa2339b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976e9da1d5515af13d3d805fa2339b58">&#9670;&#160;</a></span>unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BitStore Store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gf2::unset_bits </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-store. </p>
<p>You can use this iterator to iterate over the unset bits in the store and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-350"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#aeed3a5c646dbc7c38b4298574734ae4a">BitVector&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a355af2e0599965ef8d4eada941eee8e3">to_string</a>(v), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(<a class="code hl_function" href="#a976e9da1d5515af13d3d805fa2339b58">unset_bits</a>(v));</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{1, 3, 5, 7, 9}));</div>
<div class="ttc" id="anamespacegf2_html_a976e9da1d5515af13d3d805fa2339b58"><div class="ttname"><a href="#a976e9da1d5515af13d3d805fa2339b58">gf2::unset_bits</a></div><div class="ttdeci">constexpr auto unset_bits(Store const &amp;store)</div><div class="ttdoc">Returns an iterator over the indices of any unset bits in the bit-store.</div><div class="ttdef"><b>Definition</b> BitStore.h:1187</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac0196c65fdb8ea5284bd28b74b1391ac" name="ac0196c65fdb8ea5284bd28b74b1391ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0196c65fdb8ea5284bd28b74b1391ac">&#9670;&#160;</a></span>with_set_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::with_set_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> with the bits in the half-open range <span class="tt">[begin, end)</span> set to 1 and the others set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="panics-141"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-482"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits&lt;u8&gt;</a>(0, 0), 0b0000&#39;0000);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits&lt;u8&gt;</a>(0, 1), 0b0000&#39;0001);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits&lt;u8&gt;</a>(0, 2), 0b0000&#39;0011);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits&lt;u8&gt;</a>(1, 3), 0b0000&#39;0110);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ac0196c65fdb8ea5284bd28b74b1391ac">with_set_bits&lt;u8&gt;</a>(0, 8), 0b1111&#39;1111);</div>
<div class="ttc" id="anamespacegf2_html_ac0196c65fdb8ea5284bd28b74b1391ac"><div class="ttname"><a href="#ac0196c65fdb8ea5284bd28b74b1391ac">gf2::with_set_bits</a></div><div class="ttdeci">constexpr Word with_set_bits(u8 begin, u8 end)</div><div class="ttdoc">Returns an Unsigned with the bits in the half-open range [begin, end) set to 1 and the others set to ...</div><div class="ttdef"><b>Definition</b> Unsigned.h:112</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a53af367ace4cb8292aef14a2338eefa7" name="a53af367ace4cb8292aef14a2338eefa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53af367ace4cb8292aef14a2338eefa7">&#9670;&#160;</a></span>with_unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::with_unset_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> with the bits in the half-open range <span class="tt">[begin, end)</span> set to 0 and the others set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="panics-142"></a>
Panics</h1>
<p>In debug mode, the range `[begin, end) is checked for validity and the program exits on failure.</p>
<h1 class="doxsection"><a class="anchor" id="example-483"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits&lt;u8&gt;</a>(0, 0), 0b1111&#39;1111);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits&lt;u8&gt;</a>(0, 1), 0b1111&#39;1110);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits&lt;u8&gt;</a>(0, 2), 0b1111&#39;1100);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits&lt;u8&gt;</a>(1, 3), 0b1111&#39;1001);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a53af367ace4cb8292aef14a2338eefa7">with_unset_bits&lt;u8&gt;</a>(0, 8), 0b0000&#39;0000);</div>
<div class="ttc" id="anamespacegf2_html_a53af367ace4cb8292aef14a2338eefa7"><div class="ttname"><a href="#a53af367ace4cb8292aef14a2338eefa7">gf2::with_unset_bits</a></div><div class="ttdeci">constexpr Word with_unset_bits(u8 begin, u8 end)</div><div class="ttdoc">Returns an Unsigned with the bits in the half-open range [begin, end) set to 0 and the others set to ...</div><div class="ttdef"><b>Definition</b> Unsigned.h:133</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaf2ed88c6da45988348d97b3b209a210" name="aaf2ed88c6da45988348d97b3b209a210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2ed88c6da45988348d97b3b209a210">&#9670;&#160;</a></span>word_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::word_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> word holding bit element <span class="tt">i</span>. </p>
<p>Assumes we are holding bits in a sequence of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> words.</p>
<h1 class="doxsection"><a class="anchor" id="example-504"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aaf2ed88c6da45988348d97b3b209a210">word_index&lt;u8&gt;</a>(0), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aaf2ed88c6da45988348d97b3b209a210">word_index&lt;u8&gt;</a>(8), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#aaf2ed88c6da45988348d97b3b209a210">word_index&lt;u8&gt;</a>(19), 2);</div>
<div class="ttc" id="anamespacegf2_html_aaf2ed88c6da45988348d97b3b209a210"><div class="ttname"><a href="#aaf2ed88c6da45988348d97b3b209a210">gf2::word_index</a></div><div class="ttdeci">constexpr usize word_index(usize i)</div><div class="ttdoc">Returns the index of the Unsigned word holding bit element i.</div><div class="ttdef"><b>Definition</b> Unsigned.h:547</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="addc2c0a44d96155e38c2ad788bbd3d15" name="addc2c0a44d96155e38c2ad788bbd3d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc2c0a44d96155e38c2ad788bbd3d15">&#9670;&#160;</a></span>words_needed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a> gf2::words_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n_bits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span>s needed to store <span class="tt">n_bits</span> bits. </p>
<h1 class="doxsection"><a class="anchor" id="example-503"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#addc2c0a44d96155e38c2ad788bbd3d15">words_needed&lt;u8&gt;</a>(0), 0);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#addc2c0a44d96155e38c2ad788bbd3d15">words_needed&lt;u8&gt;</a>(8), 1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#addc2c0a44d96155e38c2ad788bbd3d15">words_needed&lt;u8&gt;</a>(19), 3);</div>
<div class="ttc" id="anamespacegf2_html_addc2c0a44d96155e38c2ad788bbd3d15"><div class="ttname"><a href="#addc2c0a44d96155e38c2ad788bbd3d15">gf2::words_needed</a></div><div class="ttdeci">constexpr usize words_needed(usize n_bits)</div><div class="ttdoc">Returns the number of Unsigneds needed to store n_bits bits.</div><div class="ttdef"><b>Definition</b> Unsigned.h:530</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a25e0e45234996261621fe95ff6fd4c4e" name="a25e0e45234996261621fe95ff6fd4c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e0e45234996261621fe95ff6fd4c4e">&#9670;&#160;</a></span>ALTERNATING</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::ALTERNATING = <a class="el" href="#acf1efd9e5621725420f4c5926573b376">MAX</a>&lt;Word&gt; / 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance with alternating bits set to 0 and 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-481"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_variable" href="#a25e0e45234996261621fe95ff6fd4c4e">ALTERNATING&lt;u8&gt;</a>, 0b0101&#39;0101);</div>
<div class="ttc" id="anamespacegf2_html_a25e0e45234996261621fe95ff6fd4c4e"><div class="ttname"><a href="#a25e0e45234996261621fe95ff6fd4c4e">gf2::ALTERNATING</a></div><div class="ttdeci">constexpr Word ALTERNATING</div><div class="ttdoc">The Unsigned instance with alternating bits set to 0 and 1.</div><div class="ttdef"><b>Definition</b> Unsigned.h:91</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1d8969ed4ed705fbc26eec1eed8b6ae" name="ad1d8969ed4ed705fbc26eec1eed8b6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d8969ed4ed705fbc26eec1eed8b6ae">&#9670;&#160;</a></span>BITS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940">u8</a> gf2::BITS = std::numeric_limits&lt;Word&gt;::digits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bits in an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> returned as a <span class="tt"><a class="el" href="#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a></span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-477"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_variable" href="#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS&lt;u16&gt;</a>, 16);</div>
<div class="ttc" id="anamespacegf2_html_ad1d8969ed4ed705fbc26eec1eed8b6ae"><div class="ttname"><a href="#ad1d8969ed4ed705fbc26eec1eed8b6ae">gf2::BITS</a></div><div class="ttdeci">constexpr u8 BITS</div><div class="ttdoc">The number of bits in an Unsigned returned as a u8.</div><div class="ttdef"><b>Definition</b> Unsigned.h:55</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acf1efd9e5621725420f4c5926573b376" name="acf1efd9e5621725420f4c5926573b376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1efd9e5621725420f4c5926573b376">&#9670;&#160;</a></span>MAX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::MAX = std::numeric_limits&lt;Word&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance with all its bits set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-480"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_variable" href="#acf1efd9e5621725420f4c5926573b376">MAX&lt;u8&gt;</a>, 255);</div>
<div class="ttc" id="anamespacegf2_html_acf1efd9e5621725420f4c5926573b376"><div class="ttname"><a href="#acf1efd9e5621725420f4c5926573b376">gf2::MAX</a></div><div class="ttdeci">constexpr Word MAX</div><div class="ttdoc">The Unsigned instance with all its bits set to 1.</div><div class="ttdef"><b>Definition</b> Unsigned.h:82</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ac31b0679b7a7ad28fa9f7432e5761d" name="a3ac31b0679b7a7ad28fa9f7432e5761d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac31b0679b7a7ad28fa9f7432e5761d">&#9670;&#160;</a></span>ONE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::ONE = Word{1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The one value for an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> type. </p>
<h1 class="doxsection"><a class="anchor" id="example-479"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_variable" href="#a3ac31b0679b7a7ad28fa9f7432e5761d">ONE&lt;u8&gt;</a>, 1);</div>
<div class="ttc" id="anamespacegf2_html_a3ac31b0679b7a7ad28fa9f7432e5761d"><div class="ttname"><a href="#a3ac31b0679b7a7ad28fa9f7432e5761d">gf2::ONE</a></div><div class="ttdeci">constexpr Word ONE</div><div class="ttdoc">The one value for an Unsigned type.</div><div class="ttdef"><b>Definition</b> Unsigned.h:73</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a171887ab6ae6dd7dd533d431f86b152c" name="a171887ab6ae6dd7dd533d431f86b152c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171887ab6ae6dd7dd533d431f86b152c">&#9670;&#160;</a></span>ZERO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word gf2::ZERO = Word{0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The zero value for an <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> type. </p>
<h1 class="doxsection"><a class="anchor" id="example-478"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_variable" href="#a171887ab6ae6dd7dd533d431f86b152c">ZERO&lt;u8&gt;</a>, 0);</div>
<div class="ttc" id="anamespacegf2_html_a171887ab6ae6dd7dd533d431f86b152c"><div class="ttname"><a href="#a171887ab6ae6dd7dd533d431f86b152c">gf2::ZERO</a></div><div class="ttdeci">constexpr Word ZERO</div><div class="ttdoc">The zero value for an Unsigned type.</div><div class="ttdef"><b>Definition</b> Unsigned.h:64</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
