// This file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `BitPolynomial.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-26 16:50:00

#include "../include/gf2/BitPolynomial.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    // Trace the source for the tests.
    auto header_file = "BitPolynomial.h";
    std::size_t test_count = 44;
    std::println(stderr, "Running {} tests extracted from: `{}`", test_count, header_file);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for `{}`:", doxy::max_fails, header_file);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    // Run the tests ...
    header_line = 22;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        p[0] = true;
        p[1] = false;
        p[2] = true;
        assert_eq(p.to_string(), "1 + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 49;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 60;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p{BitVector<>::ones(10)};
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 77;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::ones(10);
        BitPolynomial p{std::move(coeffs)};
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 91;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zero();
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 100;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::one();
        assert_eq(p.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 109;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::constant(true);
        assert_eq(p.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 122;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_full_string(), "0 + 0x + 0x^2 + 0x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 133;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(4);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 142;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 154;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::from(10, [](usize i) { return i % 2 == 0; });
        assert_eq(p.to_string(), "1 + x^2 + x^4 + x^6 + x^8 + x^10");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 187;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 42;
        auto p1 = BitPolynomial<>::seeded_random(3311, seed);
        auto p2 = BitPolynomial<>::seeded_random(3311, seed);
        assert_eq(p1, p2, "BitPolys with the same seed should be equal");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 213;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("10101000").value();
        BitPolynomial p{coeffs};
        assert_eq(p.degree(), 4);
        assert_eq(p.size(), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 226;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("10101000").value();
        BitPolynomial p{coeffs};
        assert_eq(p.degree(), 4);
        assert_eq(p.size(), 8);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 261;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p[2], false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 272;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_string(), "0");
        p[2] = true;
        assert_eq(p.to_string(), "x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 285;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(3);
        auto c = p.coefficients();
        assert_eq(c.to_string(), "1111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 297;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::zeros(3);
        assert_eq(p.to_string(), "0");
        auto& c = p.coefficients();
        c.set_all();
        assert_eq(p.to_string(), "1 + x + x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 311;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
        auto c = BitVector<u8>::ones(3);
        p.copy_coefficients(c);
        assert_eq(c.to_string(), "111");
        assert_eq(p.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 332;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitPolynomial p;
        assert_eq(p.to_string(), "0");
        auto coeffs = BitVector<>::ones(3);
        p.copy_coefficients(std::move(coeffs));
        assert_eq(p.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 348;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.clear();
        assert_eq(p.to_string(), "0");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 366;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("111010").value();
        assert_eq(coeffs.to_string(), "111010");
        BitPolynomial p{coeffs};
        assert_eq(p.to_string(), "1 + x + x^2 + x^4");
        assert_eq(p.to_full_string(), "1 + x + x^2 + 0x^3 + x^4 + 0x^5");
        p.resize(2);
        assert_eq(p.to_string(), "1 + x");
        p.resize(4);
        assert_eq(p.to_full_string(), "1 + x + 0x^2 + 0x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 385;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.shrink_to_fit();
        assert_eq(p.to_string(), "x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 402;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.is_monic(), false);
        p.make_monic();
        assert_eq(p.is_monic(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 421;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(2);
        auto q = BitPolynomial<>::x_to_the(3);
        p += q;
        assert_eq(p.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 453;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(2);
        auto q = BitPolynomial<>::x_to_the(3);
        p -= q;
        assert_eq(p.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 466;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(1);
        assert_eq(p.to_string(), "1 + x");
        auto q = BitPolynomial<>::ones(2);
        assert_eq(q.to_string(), "1 + x + x^2");
        p *= q;
        assert_eq(p.to_string(), "1 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 494;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p + q;
        assert_eq(r.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 518;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p - q;
        assert_eq(r.to_string(), "x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 532;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::x_to_the(2);
        auto r = p * q;
        assert_eq(r.to_string(), "x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 553;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("111").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_string(), "1 + x + x^2");
        BitPolynomial q;
        p.squared(q);
        assert_eq(q.to_string(), "1 + x^2 + x^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 578;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        auto q = p.squared();
        assert_eq(q.to_string(), "x^6");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 595;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p.to_string(), "x^3");
        p.times_x_to_the(2);
        assert_eq(p.to_string(), "x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 617;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        BitPolynomial q;
        p.sub(4, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4");
        p.sub(6, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        p.sub(16, q);
        assert_eq(q.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        p.sub(0, q);
        assert_eq(q.to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 644;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(4).to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(p.sub(6).to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(16).to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(p.sub(0).to_string(), "1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 662;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(6);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        BitPolynomial low, high;
        p.split(4, low, high);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(high.to_string(), "1 + x");
        p.split(6, low, high);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6");
        assert_eq(high.to_string(), "0");
        p.split(0, low, high);
        assert_eq(low.to_string(), "1");
        assert_eq(high.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 693;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(7);
        assert_eq(p.to_string(), "1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7");
        auto [low, high] = p.split(4);
        assert_eq(low.to_string(), "1 + x + x^2 + x^3 + x^4");
        assert_eq(high.to_string(), "1 + x + x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 713;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        assert_eq(p(true), true);
        assert_eq(p(false), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 739;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(6);
        BitPolynomial p1{BitVector<>::alternating(12)};
        assert_eq(p1(m), BitMatrix<>::zeros(6, 6));
        BitPolynomial p2{BitVector<>::alternating(6)};
        assert_eq(p2(m), BitMatrix<>::identity(6));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 793;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto r = p.reduce_x_to_the(2);
        assert_eq(r.to_string(), "x^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 909;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_string("M"), "1 + M^2 + M^4");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 947;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto coeffs = BitVector<>::from_string("101010").value();
        BitPolynomial p{coeffs};
        assert_eq(p.to_full_string("M"), "1 + 0M + M^2 + 0M^3 + M^4 + 0M^5");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 989;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::x_to_the(3);
        auto q = BitPolynomial<>::zeros(1000);
        q[3] = true;
        assert(p == q);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1033;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitPolynomial<>::ones(2);
        auto px = std::format("{}", p);
        auto py = std::format("{:y}", p);
        assert_eq(px, "1 + x + x^2");
        assert_eq(py, "1 + y + y^2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    // Print a summary of the tests results.
    if (fails == 0) {
        std::println(stderr, "[{}] All {} tests PASSED", header_file, test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Test FAIL summary for `{}`: Ran {} of a possible {} tests, PASSED: {}, FAILED: {}", header_file, test, test_count, test - fails, fails);
        std::print(stderr, "--------------------------------------------------------------------------------------");
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}