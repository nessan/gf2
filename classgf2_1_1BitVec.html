<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitVec&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitVec.html','','classgf2_1_1BitVec-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitVec&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitVec_8h_source.html">BitVec.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad1e5d382e4b7ae827e5b14a4b44d3e09" id="r_ad1e5d382e4b7ae827e5b14a4b44d3e09"><td class="memItemLeft" align="right" valign="top"><a id="ad1e5d382e4b7ae827e5b14a4b44d3e09" name="ad1e5d382e4b7ae827e5b14a4b44d3e09"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_type</b> = Word</td></tr>
<tr class="memdesc:ad1e5d382e4b7ae827e5b14a4b44d3e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying unsigned word type used to store the bits. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Required BitStore Concept Methods:</div></td></tr>
<tr class="memitem:a54e7e8f54ed7dcb6d85e7c655aba03e1" id="r_a54e7e8f54ed7dcb6d85e7c655aba03e1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">size</a> () const</td></tr>
<tr class="memdesc:a54e7e8f54ed7dcb6d85e7c655aba03e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bit-elements in the bit-vector.  <br /></td></tr>
<tr class="memitem:a87103730819743af8ff170fb5ca13185" id="r_a87103730819743af8ff170fb5ca13185"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87103730819743af8ff170fb5ca13185">words</a> () const</td></tr>
<tr class="memdesc:a87103730819743af8ff170fb5ca13185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words in the bit-vector's underlying word store.  <br /></td></tr>
<tr class="memitem:a1d6e74f511ed45d28b2b918107eff1ef" id="r_a1d6e74f511ed45d28b2b918107eff1ef"><td class="memItemLeft" align="right" valign="top">constexpr Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef">word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a1d6e74f511ed45d28b2b918107eff1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns word <span class="tt">i</span> from the bit-vector's underlying word store.  <br /></td></tr>
<tr class="memitem:acb878752cc181ef833e9dafbb059cb8c" id="r_acb878752cc181ef833e9dafbb059cb8c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb878752cc181ef833e9dafbb059cb8c">set_word</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, Word <a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef">word</a>)</td></tr>
<tr class="memdesc:acb878752cc181ef833e9dafbb059cb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets word <span class="tt">i</span> in the bit-vector's underlying word store to <span class="tt">value</span> (masked if necessary).  <br /></td></tr>
<tr class="memitem:abfc4befce710a6af1421985116e96633" id="r_abfc4befce710a6af1421985116e96633"><td class="memItemLeft" align="right" valign="top">constexpr const Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc4befce710a6af1421985116e96633">store</a> () const</td></tr>
<tr class="memdesc:abfc4befce710a6af1421985116e96633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the underlying store of words .  <br /></td></tr>
<tr class="memitem:a7d3ff5adb0af65ef42b2a675589caae7" id="r_a7d3ff5adb0af65ef42b2a675589caae7"><td class="memItemLeft" align="right" valign="top">constexpr Word *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d3ff5adb0af65ef42b2a675589caae7">store</a> ()</td></tr>
<tr class="memdesc:a7d3ff5adb0af65ef42b2a675589caae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying store of words.  <br /></td></tr>
<tr class="memitem:a5aeba2cd4fa570743723c3ef3bbd8ac4" id="r_a5aeba2cd4fa570743723c3ef3bbd8ac4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aeba2cd4fa570743723c3ef3bbd8ac4">offset</a> () const</td></tr>
<tr class="memdesc:a5aeba2cd4fa570743723c3ef3bbd8ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bits) of the first bit in the store within the first word.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors:</div></td></tr>
<tr class="memitem:a038038c80199c235110eb287b0d557df" id="r_a038038c80199c235110eb287b0d557df"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len=0)</td></tr>
<tr class="memdesc:a038038c80199c235110eb287b0d557df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-vector of length <span class="tt">n</span> with all the bit elements set to 0.  <br /></td></tr>
<tr class="memitem:a6d5b271c540def1bf0bc0dd03f777da9" id="r_a6d5b271c540def1bf0bc0dd03f777da9"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5b271c540def1bf0bc0dd03f777da9">BitVec</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len, Word <a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef">word</a>)</td></tr>
<tr class="memdesc:a6d5b271c540def1bf0bc0dd03f777da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-vector with <span class="tt">len</span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span>.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Size and Capacity:</div></td></tr>
<tr class="memitem:a60eeedc53538281d5de6cc5cf556833b" id="r_a60eeedc53538281d5de6cc5cf556833b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60eeedc53538281d5de6cc5cf556833b">capacity</a> () const</td></tr>
<tr class="memdesc:a60eeedc53538281d5de6cc5cf556833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the bit-vector.  <br /></td></tr>
<tr class="memitem:a9cea0afd5df1aa626b1319c4897ac970" id="r_a9cea0afd5df1aa626b1319c4897ac970"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cea0afd5df1aa626b1319c4897ac970">remaining_capacity</a> () const</td></tr>
<tr class="memdesc:a9cea0afd5df1aa626b1319c4897ac970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating.  <br /></td></tr>
<tr class="memitem:a86c9723397a5256e234fe7f9cebda6df" id="r_a86c9723397a5256e234fe7f9cebda6df"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c9723397a5256e234fe7f9cebda6df">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a86c9723397a5256e234fe7f9cebda6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the bit-vector's capacity as much as possible.  <br /></td></tr>
<tr class="memitem:ac38c66028b0aa20333f1a26715c2aa5f" id="r_ac38c66028b0aa20333f1a26715c2aa5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac38c66028b0aa20333f1a26715c2aa5f">clear</a> ()</td></tr>
<tr class="memdesc:ac38c66028b0aa20333f1a26715c2aa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the bit-vector so <code><a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>==0</code>.  <br /></td></tr>
<tr class="memitem:abac2ae23aebeffc85bce13f6e0528783" id="r_abac2ae23aebeffc85bce13f6e0528783"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac2ae23aebeffc85bce13f6e0528783">resize</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:abac2ae23aebeffc85bce13f6e0528783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the bit-vector so that its <span class="tt"><a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a></span> is <span class="tt">n</span>.  <br /></td></tr>
<tr class="memitem:a2a317450b6723ee4c8b00296966d14e3" id="r_a2a317450b6723ee4c8b00296966d14e3"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a317450b6723ee4c8b00296966d14e3">clean</a> ()</td></tr>
<tr class="memdesc:a2a317450b6723ee4c8b00296966d14e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets any unused bits in the <em>last</em> occupied word to 0.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Push/pop Single Elements:</div></td></tr>
<tr class="memitem:a5843880584a61949af70e645f0db7d14" id="r_a5843880584a61949af70e645f0db7d14"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5843880584a61949af70e645f0db7d14">push</a> (bool b)</td></tr>
<tr class="memdesc:a5843880584a61949af70e645f0db7d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a single bit <span class="tt">b</span> onto the bit-vector.  <br /></td></tr>
<tr class="memitem:a7ae048f5abad05cf4e62a3a36338a0cc" id="r_a7ae048f5abad05cf4e62a3a36338a0cc"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae048f5abad05cf4e62a3a36338a0cc">pop</a> ()</td></tr>
<tr class="memdesc:a7ae048f5abad05cf4e62a3a36338a0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last bit from the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Appending from Various Sources:</div></td></tr>
<tr class="memitem:af9ff9479a5511c5c0725cb18bcef5b7a" id="r_af9ff9479a5511c5c0725cb18bcef5b7a"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:af9ff9479a5511c5c0725cb18bcef5b7a template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ff9479a5511c5c0725cb18bcef5b7a">append</a> (Src src)</td></tr>
<tr class="memdesc:af9ff9479a5511c5c0725cb18bcef5b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from any unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:af24fb69b77b1698b749aad33a2ac6f18" id="r_af24fb69b77b1698b749aad33a2ac6f18"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:af24fb69b77b1698b749aad33a2ac6f18 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af24fb69b77b1698b749aad33a2ac6f18">append</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:af24fb69b77b1698b749aad33a2ac6f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> <span class="tt">src</span> onto the end of the bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:ad185e484f70295a6f0bd868fdd227cba" id="r_ad185e484f70295a6f0bd868fdd227cba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:ad185e484f70295a6f0bd868fdd227cba template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad185e484f70295a6f0bd868fdd227cba">append</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:ad185e484f70295a6f0bd868fdd227cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the bits from a <span class="tt">std::bitset</span> onto the end of the bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:a3c7e98e4cae78d02f32dd8ea12c1eaf1" id="r_a3c7e98e4cae78d02f32dd8ea12c1eaf1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a> (char c, int base)</td></tr>
<tr class="memdesc:a3c7e98e4cae78d02f32dd8ea12c1eaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining.  <br /></td></tr>
<tr class="memitem:adea51e74e43feea1473e37e8ca487cb1" id="r_adea51e74e43feea1473e37e8ca487cb1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adea51e74e43feea1473e37e8ca487cb1">append_hex_digit</a> (char c)</td></tr>
<tr class="memdesc:adea51e74e43feea1473e37e8ca487cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single hex digit character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Removing Elements:</div></td></tr>
<tr class="memitem:aa1ac4a0001c584bf0f384febd3ee3cc6" id="r_aa1ac4a0001c584bf0f384febd3ee3cc6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1ac4a0001c584bf0f384febd3ee3cc6">split_off</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at)</td></tr>
<tr class="memdesc:aa1ac4a0001c584bf0f384febd3ee3cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a bit-vector into two at the given index, returning a new <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a></span>.  <br /></td></tr>
<tr class="memitem:a60877bf5ff25a746976ffa049aff82ad" id="r_a60877bf5ff25a746976ffa049aff82ad"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60877bf5ff25a746976ffa049aff82ad">split_off</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; Word &gt; &amp;dst)</td></tr>
<tr class="memdesc:a60877bf5ff25a746976ffa049aff82ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a bit-vector into two at the given index, returning the second part in <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:ad2b7eb7f8f39597fe4ac171e9c6d3d27" id="r_ad2b7eb7f8f39597fe4ac171e9c6d3d27"><td class="memTemplParams" colspan="2">template&lt;Unsigned Dst = Word&gt; </td></tr>
<tr class="memitem:ad2b7eb7f8f39597fe4ac171e9c6d3d27 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; Dst &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b7eb7f8f39597fe4ac171e9c6d3d27">split_off_unsigned</a> ()</td></tr>
<tr class="memdesc:ad2b7eb7f8f39597fe4ac171e9c6d3d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Accessors:</div></td></tr>
<tr class="memitem:ac682031cf75b027bc7ab6a54f767f819" id="r_ac682031cf75b027bc7ab6a54f767f819"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac682031cf75b027bc7ab6a54f767f819">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:ac682031cf75b027bc7ab6a54f767f819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a2d98eb19ca984d29e87fd750c2768f75" id="r_a2d98eb19ca984d29e87fd750c2768f75"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d98eb19ca984d29e87fd750c2768f75">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) const</td></tr>
<tr class="memdesc:a2d98eb19ca984d29e87fd750c2768f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value of the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:acd71df2577df7b16357fcaa6eeb1a24d" id="r_acd71df2577df7b16357fcaa6eeb1a24d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd71df2577df7b16357fcaa6eeb1a24d">front</a> () const</td></tr>
<tr class="memdesc:acd71df2577df7b16357fcaa6eeb1a24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:aacc24b0f55492047c6765d643208ef48" id="r_aacc24b0f55492047c6765d643208ef48"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc24b0f55492047c6765d643208ef48">back</a> () const</td></tr>
<tr class="memdesc:aacc24b0f55492047c6765d643208ef48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Mutators:</div></td></tr>
<tr class="memitem:a96e7eb01840c25b04c77e737d3629ed4" id="r_a96e7eb01840c25b04c77e737d3629ed4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, bool value=true)</td></tr>
<tr class="memdesc:a96e7eb01840c25b04c77e737d3629ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:ad07a5992e0db88d8b7732275c39fa9ef" id="r_ad07a5992e0db88d8b7732275c39fa9ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07a5992e0db88d8b7732275c39fa9ef">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:ad07a5992e0db88d8b7732275c39fa9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "reference" to the bit element <span class="tt">i</span>.  <br /></td></tr>
<tr class="memitem:ac5f4a8bd9959119bbb1e3c36f11a0bb5" id="r_ac5f4a8bd9959119bbb1e3c36f11a0bb5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f4a8bd9959119bbb1e3c36f11a0bb5">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:ac5f4a8bd9959119bbb1e3c36f11a0bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining.  <br /></td></tr>
<tr class="memitem:ae5b995b704e31fedcf979c57d470dfb8" id="r_ae5b995b704e31fedcf979c57d470dfb8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b995b704e31fedcf979c57d470dfb8">swap</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i0, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i1)</td></tr>
<tr class="memdesc:ae5b995b704e31fedcf979c57d470dfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bits in the bit-store at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Queries:</div></td></tr>
<tr class="memitem:a24e0f0c5127892b1f84e8f46260bd331" id="r_a24e0f0c5127892b1f84e8f46260bd331"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24e0f0c5127892b1f84e8f46260bd331">is_empty</a> () const</td></tr>
<tr class="memdesc:a24e0f0c5127892b1f84e8f46260bd331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the store is empty, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a8172a1ae6e66073e1109c045cd6b962e" id="r_a8172a1ae6e66073e1109c045cd6b962e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8172a1ae6e66073e1109c045cd6b962e">any</a> () const</td></tr>
<tr class="memdesc:a8172a1ae6e66073e1109c045cd6b962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if at least one bit in the store is set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a238a8a4ef81d267c8604a5f7a7ed6132" id="r_a238a8a4ef81d267c8604a5f7a7ed6132"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a238a8a4ef81d267c8604a5f7a7ed6132">all</a> () const</td></tr>
<tr class="memdesc:a238a8a4ef81d267c8604a5f7a7ed6132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all bits in the store are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:abc79128289adb4dd8d15f536cea6fb07" id="r_abc79128289adb4dd8d15f536cea6fb07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc79128289adb4dd8d15f536cea6fb07">none</a> () const</td></tr>
<tr class="memdesc:abc79128289adb4dd8d15f536cea6fb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no bits in the store are set, <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Mutators:</div></td></tr>
<tr class="memitem:a188e583de62ec470801b098249a044a0" id="r_a188e583de62ec470801b098249a044a0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188e583de62ec470801b098249a044a0">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:a188e583de62ec470801b098249a044a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the store to the boolean <span class="tt">value</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:afda431c0fc232ab81d98e85088cb7cc1" id="r_afda431c0fc232ab81d98e85088cb7cc1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afda431c0fc232ab81d98e85088cb7cc1">flip_all</a> ()</td></tr>
<tr class="memdesc:afda431c0fc232ab81d98e85088cb7cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the value of the bits in the store and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Copying into the BitVec:</div></td></tr>
<tr class="memitem:a164e532a5d4d63e04261f55c86c0af34" id="r_a164e532a5d4d63e04261f55c86c0af34"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:a164e532a5d4d63e04261f55c86c0af34 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164e532a5d4d63e04261f55c86c0af34">copy</a> (Src src)</td></tr>
<tr class="memdesc:a164e532a5d4d63e04261f55c86c0af34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bits from an unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a805b05ffb2a3e7d26360ee5b2f50f476" id="r_a805b05ffb2a3e7d26360ee5b2f50f476"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:a805b05ffb2a3e7d26360ee5b2f50f476 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a805b05ffb2a3e7d26360ee5b2f50f476">copy</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:a805b05ffb2a3e7d26360ee5b2f50f476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bits from an equal-sized <span class="tt">src</span> store and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a91cafc8930ab04dd3c92292be6de65bf" id="r_a91cafc8930ab04dd3c92292be6de65bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:a91cafc8930ab04dd3c92292be6de65bf template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cafc8930ab04dd3c92292be6de65bf">copy</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a91cafc8930ab04dd3c92292be6de65bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bits of an equal-sized <span class="tt">std::bitset</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Store Fills:</div></td></tr>
<tr class="memitem:a4224deb018c860d819310f72bb516908" id="r_a4224deb018c860d819310f72bb516908"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4224deb018c860d819310f72bb516908">copy</a> (std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a4224deb018c860d819310f72bb516908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the store by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining.  <br /></td></tr>
<tr class="memitem:a7b46b8911038a43ff97c900d83e7fbed" id="r_a7b46b8911038a43ff97c900d83e7fbed"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b46b8911038a43ff97c900d83e7fbed">fill_random</a> (double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:a7b46b8911038a43ff97c900d83e7fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the store with random bits and returns a reference to this for chaining.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts:</div></td></tr>
<tr class="memitem:aa9f1faf3e7550d4c3bc3baf21c209d1e" id="r_aa9f1faf3e7550d4c3bc3baf21c209d1e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9f1faf3e7550d4c3bc3baf21c209d1e">count_ones</a> () const</td></tr>
<tr class="memdesc:aa9f1faf3e7550d4c3bc3baf21c209d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in the store.  <br /></td></tr>
<tr class="memitem:a2d2935436b7ba76295b60345db420a61" id="r_a2d2935436b7ba76295b60345db420a61"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d2935436b7ba76295b60345db420a61">count_zeros</a> () const</td></tr>
<tr class="memdesc:a2d2935436b7ba76295b60345db420a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unset bits in the store.  <br /></td></tr>
<tr class="memitem:afc84d3c4f7a8304f52b28765475c3a8b" id="r_afc84d3c4f7a8304f52b28765475c3a8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc84d3c4f7a8304f52b28765475c3a8b">leading_zeros</a> () const</td></tr>
<tr class="memdesc:afc84d3c4f7a8304f52b28765475c3a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of leading zeros in the store.  <br /></td></tr>
<tr class="memitem:a3681bc0ae42792d49670789feb85a46d" id="r_a3681bc0ae42792d49670789feb85a46d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3681bc0ae42792d49670789feb85a46d">trailing_zeros</a> () const</td></tr>
<tr class="memdesc:a3681bc0ae42792d49670789feb85a46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of trailing zeros in the store.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Set-bit Indices:</div></td></tr>
<tr class="memitem:ac5e0764e73414967b27a7325bcfd581a" id="r_ac5e0764e73414967b27a7325bcfd581a"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e0764e73414967b27a7325bcfd581a">first_set</a> () const</td></tr>
<tr class="memdesc:ac5e0764e73414967b27a7325bcfd581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first set bit in the bit-store or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:af193a47251b36284c46424524b904c0a" id="r_af193a47251b36284c46424524b904c0a"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af193a47251b36284c46424524b904c0a">last_set</a> () const</td></tr>
<tr class="memdesc:af193a47251b36284c46424524b904c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last set bit in the bit-store or <span class="tt">{}</span> if no bits are set.  <br /></td></tr>
<tr class="memitem:acd6d60650865955b829d11de55199219" id="r_acd6d60650865955b829d11de55199219"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6d60650865955b829d11de55199219">next_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:acd6d60650865955b829d11de55199219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next set bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more set bits exist.  <br /></td></tr>
<tr class="memitem:aca2b1afc660ff95d8ec775cbc2689dcc" id="r_aca2b1afc660ff95d8ec775cbc2689dcc"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca2b1afc660ff95d8ec775cbc2689dcc">previous_set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:aca2b1afc660ff95d8ec775cbc2689dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous set bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Unset-bit Indices:</div></td></tr>
<tr class="memitem:aab9955f248d42cff47e9a415db5d5f7b" id="r_aab9955f248d42cff47e9a415db5d5f7b"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab9955f248d42cff47e9a415db5d5f7b">first_unset</a> () const</td></tr>
<tr class="memdesc:aab9955f248d42cff47e9a415db5d5f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:a9f6b9b21f5c72b05db1739fcff74ca8f" id="r_a9f6b9b21f5c72b05db1739fcff74ca8f"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6b9b21f5c72b05db1739fcff74ca8f">last_unset</a> () const</td></tr>
<tr class="memdesc:a9f6b9b21f5c72b05db1739fcff74ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset.  <br /></td></tr>
<tr class="memitem:a01ff64db71253037f7990494190d132e" id="r_a01ff64db71253037f7990494190d132e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ff64db71253037f7990494190d132e">next_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a01ff64db71253037f7990494190d132e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the next unset bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr class="memitem:a35581d0c84cca8d385abd42e963cb69e" id="r_a35581d0c84cca8d385abd42e963cb69e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35581d0c84cca8d385abd42e963cb69e">previous_unset</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> index) const</td></tr>
<tr class="memdesc:a35581d0c84cca8d385abd42e963cb69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the previous unset bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Iterators:</div></td></tr>
<tr class="memitem:a56f5a25e9e7a389aef207416667cd606" id="r_a56f5a25e9e7a389aef207416667cd606"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56f5a25e9e7a389aef207416667cd606">bits</a> () const</td></tr>
<tr class="memdesc:a56f5a25e9e7a389aef207416667cd606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-store.  <br /></td></tr>
<tr class="memitem:a6dc03c6aaa9d475fc2cfc2350ec47783" id="r_a6dc03c6aaa9d475fc2cfc2350ec47783"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dc03c6aaa9d475fc2cfc2350ec47783">bits</a> ()</td></tr>
<tr class="memdesc:a6dc03c6aaa9d475fc2cfc2350ec47783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const iterator over the values of the bits in the mutable bit-store.  <br /></td></tr>
<tr class="memitem:aac4e0bcb2be911a8bd590932e28fcb31" id="r_aac4e0bcb2be911a8bd590932e28fcb31"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac4e0bcb2be911a8bd590932e28fcb31">set_bits</a> () const</td></tr>
<tr class="memdesc:aac4e0bcb2be911a8bd590932e28fcb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-store.  <br /></td></tr>
<tr class="memitem:afdc9bdd91c2640a600ab38540483f5ed" id="r_afdc9bdd91c2640a600ab38540483f5ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc9bdd91c2640a600ab38540483f5ed">unset_bits</a> () const</td></tr>
<tr class="memdesc:afdc9bdd91c2640a600ab38540483f5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-store.  <br /></td></tr>
<tr class="memitem:a59995a46ced1daef94f1f5ec3e34a97f" id="r_a59995a46ced1daef94f1f5ec3e34a97f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59995a46ced1daef94f1f5ec3e34a97f">store_words</a> () const</td></tr>
<tr class="memdesc:a59995a46ced1daef94f1f5ec3e34a97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator over all the <em>words</em> underlying the bit-store.  <br /></td></tr>
<tr class="memitem:a8b8920fb3faa73171f9e1e8ae8e90953" id="r_a8b8920fb3faa73171f9e1e8ae8e90953"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8920fb3faa73171f9e1e8ae8e90953">to_words</a> () const</td></tr>
<tr class="memdesc:a8b8920fb3faa73171f9e1e8ae8e90953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the words underlying this bit-store.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Spans:</div></td></tr>
<tr class="memitem:a16b78eb9514437fd3ba23cfc28a31f19" id="r_a16b78eb9514437fd3ba23cfc28a31f19"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b78eb9514437fd3ba23cfc28a31f19">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a16b78eb9514437fd3ba23cfc28a31f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <em>immutable</em> bit-span encompassing the store's bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr class="memitem:af7e112efa01260c893f5a74d34953c47" id="r_af7e112efa01260c893f5a74d34953c47"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e112efa01260c893f5a74d34953c47">span</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end)</td></tr>
<tr class="memdesc:af7e112efa01260c893f5a74d34953c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable bit-span encompassing the bits in the half-open range <span class="tt">[begin, end)</span>.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-vectors:</div></td></tr>
<tr class="memitem:a66f22d5eb48cbd639e080bca8cae94c3" id="r_a66f22d5eb48cbd639e080bca8cae94c3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f22d5eb48cbd639e080bca8cae94c3">sub</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> begin, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> end) const</td></tr>
<tr class="memdesc:a66f22d5eb48cbd639e080bca8cae94c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector.  <br /></td></tr>
<tr id="pub-methods-18" class="groupHeader"><td colspan="2"><div class="groupHeader">Splits:</div></td></tr>
<tr class="memitem:aad2cdea9a00459c91c7183b3ac190712" id="r_aad2cdea9a00459c91c7183b3ac190712"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2cdea9a00459c91c7183b3ac190712">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at, <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;left, <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;right) const</td></tr>
<tr class="memdesc:aad2cdea9a00459c91c7183b3ac190712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively.  <br /></td></tr>
<tr class="memitem:a74964c052d3bff286b71d3a43d0da288" id="r_a74964c052d3bff286b71d3a43d0da288"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74964c052d3bff286b71d3a43d0da288">split_at</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> at) const</td></tr>
<tr class="memdesc:a74964c052d3bff286b71d3a43d0da288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively.  <br /></td></tr>
<tr id="pub-methods-19" class="groupHeader"><td colspan="2"><div class="groupHeader">Riffling:</div></td></tr>
<tr class="memitem:a16de7a2d5ab564306a2420545696a068" id="r_a16de7a2d5ab564306a2420545696a068"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16de7a2d5ab564306a2420545696a068">riffled</a> (<a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a16de7a2d5ab564306a2420545696a068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the bits of this bit-store with zeros storing the result into the bit-vector <span class="tt">dst</span>.  <br /></td></tr>
<tr class="memitem:a8cd602e2d070e57a59c82f129a30e65e" id="r_a8cd602e2d070e57a59c82f129a30e65e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cd602e2d070e57a59c82f129a30e65e">riffled</a> () const</td></tr>
<tr class="memdesc:a8cd602e2d070e57a59c82f129a30e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-vector that is the result of riffling the bits in this bit-store with zeros.  <br /></td></tr>
<tr id="pub-methods-20" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations:</div></td></tr>
<tr class="memitem:af4276ca5b45a8020549679b55ce4b41c" id="r_af4276ca5b45a8020549679b55ce4b41c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4276ca5b45a8020549679b55ce4b41c">to_binary_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:af4276ca5b45a8020549679b55ce4b41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the store.  <br /></td></tr>
<tr class="memitem:a2c17d2d2fb6d1f9f13828e2d8c085d4a" id="r_a2c17d2d2fb6d1f9f13828e2d8c085d4a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a> (std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</td></tr>
<tr class="memdesc:a2c17d2d2fb6d1f9f13828e2d8c085d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary string representation of the store.  <br /></td></tr>
<tr class="memitem:a80600ca582bde198ecea6b9d2c2dda57" id="r_a80600ca582bde198ecea6b9d2c2dda57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80600ca582bde198ecea6b9d2c2dda57">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:a80600ca582bde198ecea6b9d2c2dda57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "pretty" string representation of the store.  <br /></td></tr>
<tr class="memitem:a795cf2bcc162662e2b1c845d87e57d55" id="r_a795cf2bcc162662e2b1c845d87e57d55"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795cf2bcc162662e2b1c845d87e57d55">to_hex_string</a> () const</td></tr>
<tr class="memdesc:a795cf2bcc162662e2b1c845d87e57d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "hex" string representation of the bits in the bit-store.  <br /></td></tr>
<tr class="memitem:a0015903f8538e95fb94eb5f55163dd96" id="r_a0015903f8538e95fb94eb5f55163dd96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0015903f8538e95fb94eb5f55163dd96">describe</a> () const</td></tr>
<tr class="memdesc:a0015903f8538e95fb94eb5f55163dd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multi-line string describing the bit-store in some detail.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Factory Constructors:</div></td></tr>
<tr class="memitem:a89d721629c0bd3546fc77a1448a3185c" id="r_a89d721629c0bd3546fc77a1448a3185c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89d721629c0bd3546fc77a1448a3185c">with_capacity</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="#a60eeedc53538281d5de6cc5cf556833b">capacity</a>)</td></tr>
<tr class="memdesc:a89d721629c0bd3546fc77a1448a3185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct an empty bit-vector with at least the specified capacity.  <br /></td></tr>
<tr class="memitem:a9cbdc533df0b2efeca27daaee792b081" id="r_a9cbdc533df0b2efeca27daaee792b081"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbdc533df0b2efeca27daaee792b081">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a9cbdc533df0b2efeca27daaee792b081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 0.  <br /></td></tr>
<tr class="memitem:abe88a62254e18559eaa3a5bdc8eec2c7" id="r_abe88a62254e18559eaa3a5bdc8eec2c7"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe88a62254e18559eaa3a5bdc8eec2c7">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:abe88a62254e18559eaa3a5bdc8eec2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 1.  <br /></td></tr>
<tr class="memitem:a703114f6dcdfbe1bb7fded1650c31e29" id="r_a703114f6dcdfbe1bb7fded1650c31e29"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703114f6dcdfbe1bb7fded1650c31e29">constant</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, bool value)</td></tr>
<tr class="memdesc:a703114f6dcdfbe1bb7fded1650c31e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are set to <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:af8291af2e5ead48379b0ab5eeee87ef8" id="r_af8291af2e5ead48379b0ab5eeee87ef8"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8291af2e5ead48379b0ab5eeee87ef8">unit</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i)</td></tr>
<tr class="memdesc:af8291af2e5ead48379b0ab5eeee87ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a "unit" bit-vector of length <span class="tt">n</span> where only element <span class="tt">i</span> is set.  <br /></td></tr>
<tr class="memitem:aa2a913940a592ccc49ed6754f606c411" id="r_aa2a913940a592ccc49ed6754f606c411"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2a913940a592ccc49ed6754f606c411">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:aa2a913940a592ccc49ed6754f606c411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of length <span class="tt">n</span> looking like <span class="tt">101010...</span>.  <br /></td></tr>
<tr class="memitem:adff516a657e2c3f2c703fbf778572148" id="r_adff516a657e2c3f2c703fbf778572148"><td class="memTemplParams" colspan="2">template&lt;Unsigned Src&gt; </td></tr>
<tr class="memitem:adff516a657e2c3f2c703fbf778572148 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff516a657e2c3f2c703fbf778572148">from</a> (Src src)</td></tr>
<tr class="memdesc:adff516a657e2c3f2c703fbf778572148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance. The resulting bit-vector will have the same size as the number of bits in the <span class="tt">src</span> unsigned integer.  <br /></td></tr>
<tr class="memitem:a5d904d6460fa97d3fbbb8e7f7ef638bd" id="r_a5d904d6460fa97d3fbbb8e7f7ef638bd"><td class="memTemplParams" colspan="2">template&lt;BitStore Src&gt; </td></tr>
<tr class="memitem:a5d904d6460fa97d3fbbb8e7f7ef638bd template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d904d6460fa97d3fbbb8e7f7ef638bd">from</a> (Src const &amp;src)</td></tr>
<tr class="memdesc:a5d904d6460fa97d3fbbb8e7f7ef638bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> bit-store instance.  <br /></td></tr>
<tr class="memitem:a7f05d1a22cae97fba646ad9e689b839a" id="r_a7f05d1a22cae97fba646ad9e689b839a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </td></tr>
<tr class="memitem:a7f05d1a22cae97fba646ad9e689b839a template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f05d1a22cae97fba646ad9e689b839a">from</a> (std::bitset&lt; N &gt; const &amp;src)</td></tr>
<tr class="memdesc:a7f05d1a22cae97fba646ad9e689b839a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from the bits of a <span class="tt">std::bitset</span>.  <br /></td></tr>
<tr class="memitem:a6e999cdb776c7d7b225a0ac092827e4b" id="r_a6e999cdb776c7d7b225a0ac092827e4b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e999cdb776c7d7b225a0ac092827e4b">from</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len, std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a6e999cdb776c7d7b225a0ac092827e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, len)</span>.  <br /></td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Random Bit-Vector Constructors:</div></td></tr>
<tr class="memitem:ab57ee9beea8e50d4671758c20e544215" id="r_ab57ee9beea8e50d4671758c20e544215"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab57ee9beea8e50d4671758c20e544215">random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len, double p=0.5, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed=0)</td></tr>
<tr class="memdesc:ab57ee9beea8e50d4671758c20e544215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are picked at random.  <br /></td></tr>
<tr class="memitem:ac162f922f382c8607410e40ea3661771" id="r_ac162f922f382c8607410e40ea3661771"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac162f922f382c8607410e40ea3661771">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len, <a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed)</td></tr>
<tr class="memdesc:ac162f922f382c8607410e40ea3661771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a0c45315e29f7cfc66e7e18d5a42f9876" id="r_a0c45315e29f7cfc66e7e18d5a42f9876"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c45315e29f7cfc66e7e18d5a42f9876">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> len, double p)</td></tr>
<tr class="memdesc:a0c45315e29f7cfc66e7e18d5a42f9876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr id="pub-static-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors from Strings:</div></td></tr>
<tr class="memitem:a19b6684f4fa06d3f003029850da307f1" id="r_a19b6684f4fa06d3f003029850da307f1"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19b6684f4fa06d3f003029850da307f1">from_string</a> (std::string_view sv)</td></tr>
<tr class="memdesc:a19b6684f4fa06d3f003029850da307f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a string <span class="tt">s</span>, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
<tr class="memitem:ac8baf5a5cf90bb23038a3c97b6a9686c" id="r_ac8baf5a5cf90bb23038a3c97b6a9686c"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8baf5a5cf90bb23038a3c97b6a9686c">from_binary_string</a> (std::string_view sv, bool no_punctuation=false)</td></tr>
<tr class="memdesc:ac8baf5a5cf90bb23038a3c97b6a9686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a binary string, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
<tr class="memitem:a018d880a7c150488379b03951c9fbb00" id="r_a018d880a7c150488379b03951c9fbb00"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a018d880a7c150488379b03951c9fbb00">from_hex_string</a> (std::string_view sv, bool no_punctuation=false)</td></tr>
<tr class="memdesc:a018d880a7c150488379b03951c9fbb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-vector from a hex string, returning <span class="tt">std::nullopt</span> on failure.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af2e8edad7a0e3a99a15c5802a53341ae" id="r_af2e8edad7a0e3a99a15c5802a53341ae"><td class="memItemLeft" align="right" valign="top"><a id="af2e8edad7a0e3a99a15c5802a53341ae" name="af2e8edad7a0e3a99a15c5802a53341ae"></a>
static constexpr <a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bits_per_word</b> = <a class="el" href="namespacegf2.html#ad1d8969ed4ed705fbc26eec1eed8b6ae">BITS</a>&lt;Word&gt;</td></tr>
<tr class="memdesc:af2e8edad7a0e3a99a15c5802a53341ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits per <span class="tt">Word</span>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word = usize&gt;<br />
class gf2::BitVec&lt; Word &gt;</div><p>A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. </p>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a></span> class satisfies the <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> concept. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a038038c80199c235110eb287b0d557df" name="a038038c80199c235110eb287b0d557df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038038c80199c235110eb287b0d557df">&#9670;&#160;</a></span>BitVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::BitVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-vector of length <span class="tt">n</span> with all the bit elements set to 0. </p>
<dl class="section note"><dt>Note</dt><dd>The default constructor returns the empty bit-vector with no elements.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-378"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> u;</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a038038c80199c235110eb287b0d557df"><div class="ttname"><a href="#a038038c80199c235110eb287b0d557df">gf2::BitVec::BitVec</a></div><div class="ttdeci">constexpr BitVec(usize len=0)</div><div class="ttdoc">Constructs a bit-vector of length n with all the bit elements set to 0.</div><div class="ttdef"><b>Definition</b> BitVec.h:148</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a2c17d2d2fb6d1f9f13828e2d8c085d4a"><div class="ttname"><a href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">gf2::BitVec::to_string</a></div><div class="ttdeci">std::string to_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1659</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6d5b271c540def1bf0bc0dd03f777da9" name="a6d5b271c540def1bf0bc0dd03f777da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5b271c540def1bf0bc0dd03f777da9">&#9670;&#160;</a></span>BitVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::BitVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-vector with <span class="tt">len</span> elements by repeatedly copying all the bits from <span class="tt"><a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span>. </p>
<p>You specify the length <span class="tt">len</span> of the bit-vector which means the final copy of <span class="tt"><a class="el" href="#a1d6e74f511ed45d28b2b918107eff1ef" title="Returns word i from the bit-vector&#39;s underlying word store.">word</a></span> may be truncated and padded with zeros (unused bit slots are always set to zero in this library).</p>
<h1 class="doxsection"><a class="anchor" id="example-379"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> v{10, <a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>{0b0101&#39;0101}};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">size</a>(), 10);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a54e7e8f54ed7dcb6d85e7c655aba03e1"><div class="ttname"><a href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">gf2::BitVec::size</a></div><div class="ttdeci">constexpr usize size() const</div><div class="ttdoc">Returns the number of bit-elements in the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVec.h:50</div></div>
<div class="ttc" id="anamespacegf2_html_a872a69469085fcdddf299ae4adc3c940"><div class="ttname"><a href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">gf2::u8</a></div><div class="ttdeci">std::uint8_t u8</div><div class="ttdoc">Word type alias for an 8-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:30</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a238a8a4ef81d267c8604a5f7a7ed6132" name="a238a8a4ef81d267c8604a5f7a7ed6132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238a8a4ef81d267c8604a5f7a7ed6132">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all bits in the store are set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Empty stores have no set bits (logical connective for <span class="tt"><a class="el" href="#a238a8a4ef81d267c8604a5f7a7ed6132" title="Returns true if all bits in the store are set, false otherwise.">all</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-419"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{3};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a238a8a4ef81d267c8604a5f7a7ed6132">all</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(1);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a238a8a4ef81d267c8604a5f7a7ed6132">all</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a238a8a4ef81d267c8604a5f7a7ed6132"><div class="ttname"><a href="#a238a8a4ef81d267c8604a5f7a7ed6132">gf2::BitVec::all</a></div><div class="ttdeci">constexpr bool all() const</div><div class="ttdoc">Returns true if all bits in the store are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVec.h:1073</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a96e7eb01840c25b04c77e737d3629ed4"><div class="ttname"><a href="#a96e7eb01840c25b04c77e737d3629ed4">gf2::BitVec::set</a></div><div class="ttdeci">auto set(usize i, bool value=true)</div><div class="ttdoc">Sets the bit-element i to the specified boolean value &amp; returns this for chaining....</div><div class="ttdef"><b>Definition</b> BitVec.h:974</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa2a913940a592ccc49ed6754f606c411" name="aa2a913940a592ccc49ed6754f606c411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a913940a592ccc49ed6754f606c411">&#9670;&#160;</a></span>alternating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> looking like <span class="tt">101010...</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-385"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;u8&gt;::alternating</a>(10).<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_aa2a913940a592ccc49ed6754f606c411"><div class="ttname"><a href="#aa2a913940a592ccc49ed6754f606c411">gf2::BitVec::alternating</a></div><div class="ttdeci">static constexpr BitVec alternating(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n looking like 101010....</div><div class="ttdef"><b>Definition</b> BitVec.h:237</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8172a1ae6e66073e1109c045cd6b962e" name="a8172a1ae6e66073e1109c045cd6b962e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8172a1ae6e66073e1109c045cd6b962e">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if at least one bit in the store is set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Empty stores have no set bits (logical connective for <span class="tt"><a class="el" href="#a8172a1ae6e66073e1109c045cd6b962e" title="Returns true if at least one bit in the store is set, false otherwise.">any</a></span> is <span class="tt">OR</span> with identity <span class="tt">false</span>).</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-418"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a8172a1ae6e66073e1109c045cd6b962e">any</a>(), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a8172a1ae6e66073e1109c045cd6b962e">any</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a8172a1ae6e66073e1109c045cd6b962e"><div class="ttname"><a href="#a8172a1ae6e66073e1109c045cd6b962e">gf2::BitVec::any</a></div><div class="ttdeci">constexpr bool any() const</div><div class="ttdoc">Returns true if at least one bit in the store is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVec.h:1058</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af24fb69b77b1698b749aad33a2ac6f18" name="af24fb69b77b1698b749aad33a2ac6f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24fb69b77b1698b749aad33a2ac6f18">&#9670;&#160;</a></span>append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> <span class="tt">src</span> onto the end of the bit-vector and returns this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>Generally, we do not support interactions between bit-stores that use different underlying unsigned word types. This method is an exception, and the <span class="tt">src</span> bit-store may use a different unsigned type from the one used here.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-403"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u16&gt;::ones</a>(10);</div>
<div class="line">v.append(w);</div>
<div class="line">assert_eq(v.size(), 20);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;00000000001111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a9cbdc533df0b2efeca27daaee792b081"><div class="ttname"><a href="#a9cbdc533df0b2efeca27daaee792b081">gf2::BitVec::zeros</a></div><div class="ttdeci">static constexpr BitVec zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVec.h:194</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_abe88a62254e18559eaa3a5bdc8eec2c7"><div class="ttname"><a href="#abe88a62254e18559eaa3a5bdc8eec2c7">gf2::BitVec::ones</a></div><div class="ttdeci">static constexpr BitVec ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVec.h:202</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af9ff9479a5511c5c0725cb18bcef5b7a" name="af9ff9479a5511c5c0725cb18bcef5b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ff9479a5511c5c0725cb18bcef5b7a">&#9670;&#160;</a></span>append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from any unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>We allow <em>any</em> unsigned integral source, e.g. appending a single <span class="tt"><a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-402"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(4);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">v.append(src);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;11110101010101010101&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u32&gt;::ones</a>(4);</div>
<div class="line">w.append(src);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;11110101010101010101&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_ae858164ae3b877b1f9ea2606fae215a0"><div class="ttname"><a href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">gf2::u16</a></div><div class="ttdeci">std::uint16_t u16</div><div class="ttdoc">Word type alias for a 16-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad185e484f70295a6f0bd868fdd227cba" name="ad185e484f70295a6f0bd868fdd227cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad185e484f70295a6f0bd868fdd227cba">&#9670;&#160;</a></span>append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::append </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the bits from a <span class="tt">std::bitset</span> onto the end of the bit-vector and returns this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-404"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVec.html">BitVec</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#af9ff9479a5511c5c0725cb18bcef5b7a">append</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html"><div class="ttname"><a href="classgf2_1_1BitVec.html">gf2::BitVec</a></div><div class="ttdoc">A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...</div><div class="ttdef"><b>Definition</b> BitVec.h:23</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_af9ff9479a5511c5c0725cb18bcef5b7a"><div class="ttname"><a href="#af9ff9479a5511c5c0725cb18bcef5b7a">gf2::BitVec::append</a></div><div class="ttdeci">auto append(Src src)</div><div class="ttdoc">Appends all the bits from any unsigned integral src value and returns a reference to this for chainin...</div><div class="ttdef"><b>Definition</b> BitVec.h:677</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3c7e98e4cae78d02f32dd8ea12c1eaf1" name="a3c7e98e4cae78d02f32dd8ea12c1eaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">&#9670;&#160;</a></span>append_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::append_digit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining. </p>
<p>The character is interpreted as a base <span class="tt">base</span> number where<span class="tt">base</span> must be one of 2, 4, 8, 16.</p>
<dl class="section note"><dt>Note</dt><dd>This method does nothing if the base or character is not recognized.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-405"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a>(<span class="charliteral">&#39;A&#39;</span>, 16);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a>(<span class="charliteral">&#39;X&#39;</span>, 16);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 8);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010001&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 4);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;101000101&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">append_digit</a>(<span class="charliteral">&#39;1&#39;</span>, 2);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010001011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a3c7e98e4cae78d02f32dd8ea12c1eaf1"><div class="ttname"><a href="#a3c7e98e4cae78d02f32dd8ea12c1eaf1">gf2::BitVec::append_digit</a></div><div class="ttdeci">constexpr BitVec &amp; append_digit(char c, int base)</div><div class="ttdoc">Appends a single character c onto the end of bit-vector and returns this for chaining.</div><div class="ttdef"><b>Definition</b> BitVec.h:743</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adea51e74e43feea1473e37e8ca487cb1" name="adea51e74e43feea1473e37e8ca487cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea51e74e43feea1473e37e8ca487cb1">&#9670;&#160;</a></span>append_hex_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::append_hex_digit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single hex digit character <span class="tt">c</span> onto the end of bit-vector and returns this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>This method does nothing if the character is not a hex digit.</dd></dl>
<p>This is the same as <span class="tt">append_digit(c, 16)</span> but we push hex digits more often than other bases and want to skip some checks for efficiency.</p>
<h1 class="doxsection"><a class="anchor" id="example-406"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#adea51e74e43feea1473e37e8ca487cb1">append_hex_digit</a>(<span class="charliteral">&#39;F&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#adea51e74e43feea1473e37e8ca487cb1">append_hex_digit</a>(<span class="charliteral">&#39;X&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#adea51e74e43feea1473e37e8ca487cb1">append_hex_digit</a>(<span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;11110001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_adea51e74e43feea1473e37e8ca487cb1"><div class="ttname"><a href="#adea51e74e43feea1473e37e8ca487cb1">gf2::BitVec::append_hex_digit</a></div><div class="ttdeci">constexpr BitVec &amp; append_hex_digit(char c)</div><div class="ttdoc">Appends a single hex digit character c onto the end of bit-vector and returns this for chaining.</div><div class="ttdef"><b>Definition</b> BitVec.h:777</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aacc24b0f55492047c6765d643208ef48" name="aacc24b0f55492047c6765d643208ef48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc24b0f55492047c6765d643208ef48">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the last bit element is set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the method panics of the store is empty.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-412"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.back(), <span class="keyword">true</span>);</div>
<div class="line">v.set_all(<span class="keyword">false</span>);</div>
<div class="line">assert_eq(v.back(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0c45315e29f7cfc66e7e18d5a42f9876" name="a0c45315e29f7cfc66e7e18d5a42f9876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c45315e29f7cfc66e7e18d5a42f9876">&#9670;&#160;</a></span>biased_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-392"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a0c45315e29f7cfc66e7e18d5a42f9876">BitVec&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a0c45315e29f7cfc66e7e18d5a42f9876">BitVec&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line">assert_eq(u.size(), v.size());</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a0c45315e29f7cfc66e7e18d5a42f9876"><div class="ttname"><a href="#a0c45315e29f7cfc66e7e18d5a42f9876">gf2::BitVec::biased_random</a></div><div class="ttdeci">static BitVec biased_random(usize len, double p)</div><div class="ttdoc">Factory method to generate a bit-vector of size len where the elements are from independent fair coin...</div><div class="ttdef"><b>Definition</b> BitVec.h:382</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6dc03c6aaa9d475fc2cfc2350ec47783" name="a6dc03c6aaa9d475fc2cfc2350ec47783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc03c6aaa9d475fc2cfc2350ec47783">&#9670;&#160;</a></span>bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const iterator over the values of the bits in the mutable bit-store. </p>
<p>You can use this iterator to iterate over the bits in the store to get <em>or</em> set the value of each bit.</p>
<dl class="section note"><dt>Note</dt><dd>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-441"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : v.bits()) bit = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a56f5a25e9e7a389aef207416667cd606" name="a56f5a25e9e7a389aef207416667cd606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f5a25e9e7a389aef207416667cd606">&#9670;&#160;</a></span>bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over the <span class="tt">bool</span> values of the bits in the const bit-store. </p>
<p>You can use this iterator to iterate over the bits in the store and get the values of each bit as a <span class="tt">bool</span>.</p>
<dl class="section note"><dt>Note</dt><dd>For the most part, try to avoid iterating through individual bits. It is much more efficient to use methods that work on whole words of bits at a time.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-440"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; bit : u.bits()) assert_eq(bit, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60eeedc53538281d5de6cc5cf556833b" name="a60eeedc53538281d5de6cc5cf556833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60eeedc53538281d5de6cc5cf556833b">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the bit-vector. </p>
<p>This is the total number of bits that the bit-vector can hold without allocating more memory. The number <em>includes</em> the number of bits already in use.</p>
<h1 class="doxsection"><a class="anchor" id="example-396"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a60eeedc53538281d5de6cc5cf556833b">capacity</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u64&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.capacity(), 64);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a60eeedc53538281d5de6cc5cf556833b"><div class="ttname"><a href="#a60eeedc53538281d5de6cc5cf556833b">gf2::BitVec::capacity</a></div><div class="ttdeci">constexpr usize capacity() const</div><div class="ttdoc">Returns the current capacity of the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVec.h:541</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a317450b6723ee4c8b00296966d14e3" name="a2a317450b6723ee4c8b00296966d14e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a317450b6723ee4c8b00296966d14e3">&#9670;&#160;</a></span>clean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::clean </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets any unused bits in the <em>last</em> occupied word to 0. </p>
<p>This method can be used to enforce the guarantee that unused bits in the store are always set to 0. </p>

</div>
</div>
<a id="ac38c66028b0aa20333f1a26715c2aa5f" name="ac38c66028b0aa20333f1a26715c2aa5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38c66028b0aa20333f1a26715c2aa5f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the bit-vector so <code><a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>==0</code>. </p>
<p>The capacity is not changed by this operation. </p>

</div>
</div>
<a id="a703114f6dcdfbe1bb7fded1650c31e29" name="a703114f6dcdfbe1bb7fded1650c31e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703114f6dcdfbe1bb7fded1650c31e29">&#9670;&#160;</a></span>constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are set to <span class="tt">value</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-383"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a703114f6dcdfbe1bb7fded1650c31e29">BitVec&lt;&gt;::constant</a>(10, <span class="keyword">true</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#a703114f6dcdfbe1bb7fded1650c31e29">BitVec&lt;&gt;::constant</a>(10, <span class="keyword">false</span>);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a703114f6dcdfbe1bb7fded1650c31e29"><div class="ttname"><a href="#a703114f6dcdfbe1bb7fded1650c31e29">gf2::BitVec::constant</a></div><div class="ttdeci">static constexpr BitVec constant(usize n, bool value)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are set to value.</div><div class="ttdef"><b>Definition</b> BitVec.h:213</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a805b05ffb2a3e7d26360ee5b2f50f476" name="a805b05ffb2a3e7d26360ee5b2f50f476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805b05ffb2a3e7d26360ee5b2f50f476">&#9670;&#160;</a></span>copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the bits from an equal-sized <span class="tt">src</span> store and returns a reference to this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>This is one of the few methods in the library that <em>doesn't</em> require the two stores to have the same <span class="tt"><a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09" title="The underlying unsigned word type used to store the bits.">word_type</a></span>. You can use it to convert between different <span class="tt"><a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09" title="The underlying unsigned word type used to store the bits.">word_type</a></span> stores (e.g., from <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;<a class="el" href="namespacegf2.html#ad1e43953e374bea8222087e4aba6c74a" title="Word type alias for a 32-bit unsigned integer.">u32</a>&gt;</span> to <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>) as long as the sizes match.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-424"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u64&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">v.copy(<a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;u8&gt;::alternating</a>(10));</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a164e532a5d4d63e04261f55c86c0af34" name="a164e532a5d4d63e04261f55c86c0af34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e532a5d4d63e04261f55c86c0af34">&#9670;&#160;</a></span>copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the bits from an unsigned integral <span class="tt">src</span> value and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="notes-3"></a>
Notes:</h1>
<ol type="1">
<li>The size of the store <em>must</em> match the number of bits in the source type.</li>
<li>We allow <em>any</em> unsigned integral source, e.g. copying a single <span class="tt"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa" title="Word type alias for a 64-bit unsigned integer.">u64</a></span> into a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span> of size 64.</li>
<li>The least-significant bit of the source becomes the bit at index 0 in the store.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="example-423"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> v{16};</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> src = 0b1010101010101010;</div>
<div class="line">v.<a class="code hl_function" href="#a164e532a5d4d63e04261f55c86c0af34">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVec.html">BitVec&lt;u32&gt;</a> w{16};</div>
<div class="line">w.<a class="code hl_function" href="#a164e532a5d4d63e04261f55c86c0af34">copy</a>(src);</div>
<div class="line">assert_eq(w.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0101010101010101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a164e532a5d4d63e04261f55c86c0af34"><div class="ttname"><a href="#a164e532a5d4d63e04261f55c86c0af34">gf2::BitVec::copy</a></div><div class="ttdeci">auto copy(Src src)</div><div class="ttdoc">Copies the bits from an unsigned integral src value and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitVec.h:1136</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91cafc8930ab04dd3c92292be6de65bf" name="a91cafc8930ab04dd3c92292be6de65bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cafc8930ab04dd3c92292be6de65bf">&#9670;&#160;</a></span>copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the bits of an equal-sized <span class="tt">std::bitset</span> and returns a reference to this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd><span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> which is the reverse of our convention.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-425"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitVec.html">BitVec</a> v{10};</div>
<div class="line">v.<a class="code hl_function" href="#a164e532a5d4d63e04261f55c86c0af34">copy</a>(src);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4224deb018c860d819310f72bb516908" name="a4224deb018c860d819310f72bb516908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4224deb018c860d819310f72bb516908">&#9670;&#160;</a></span>copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the store by repeatedly calling <span class="tt">f(i)</span> and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-426"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">v.<a class="code hl_function" href="#a164e532a5d4d63e04261f55c86c0af34">copy</a>([](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">size</a>(), 10);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9f1faf3e7550d4c3bc3baf21c209d1e" name="aa9f1faf3e7550d4c3bc3baf21c209d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f1faf3e7550d4c3bc3baf21c209d1e">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of set bits in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-428"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aa9f1faf3e7550d4c3bc3baf21c209d1e">count_ones</a>(), 0);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#aa9f1faf3e7550d4c3bc3baf21c209d1e">count_ones</a>(), 1);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_aa9f1faf3e7550d4c3bc3baf21c209d1e"><div class="ttname"><a href="#aa9f1faf3e7550d4c3bc3baf21c209d1e">gf2::BitVec::count_ones</a></div><div class="ttdeci">constexpr usize count_ones() const</div><div class="ttdoc">Returns the number of set bits in the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1221</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2d2935436b7ba76295b60345db420a61" name="a2d2935436b7ba76295b60345db420a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2935436b7ba76295b60345db420a61">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unset bits in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-429"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2d2935436b7ba76295b60345db420a61">count_zeros</a>(), 10);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2d2935436b7ba76295b60345db420a61">count_zeros</a>(), 9);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a2d2935436b7ba76295b60345db420a61"><div class="ttname"><a href="#a2d2935436b7ba76295b60345db420a61">gf2::BitVec::count_zeros</a></div><div class="ttdeci">constexpr usize count_zeros() const</div><div class="ttdoc">Returns the number of unset bits in the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1232</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0015903f8538e95fb94eb5f55163dd96" name="a0015903f8538e95fb94eb5f55163dd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015903f8538e95fb94eb5f55163dd96">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::describe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a multi-line string describing the bit-store in some detail. </p>
<p>This method is useful for debugging but you should not rely on the output format which may change. </p>

</div>
</div>
<a id="a7b46b8911038a43ff97c900d83e7fbed" name="a7b46b8911038a43ff97c900d83e7fbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b46b8911038a43ff97c900d83e7fbed">&#9670;&#160;</a></span>fill_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::fill_random </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the store with random bits and returns a reference to this for chaining. </p>
<p>The default call <span class="tt"><a class="el" href="#a7b46b8911038a43ff97c900d83e7fbed" title="Fill the store with random bits and returns a reference to this for chaining.">fill_random()</a></span> sets each bit to 1 with probability 0.5 (fair coin).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the fill is all zeros, if <span class="tt">p &gt; 1</span> then the fill is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-427"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> u{10}, v{10};</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line">u.<a class="code hl_function" href="#a7b46b8911038a43ff97c900d83e7fbed">fill_random</a>(0.5, seed);</div>
<div class="line">v.fill_random(0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a7b46b8911038a43ff97c900d83e7fbed"><div class="ttname"><a href="#a7b46b8911038a43ff97c900d83e7fbed">gf2::BitVec::fill_random</a></div><div class="ttdeci">auto fill_random(double p=0.5, u64 seed=0)</div><div class="ttdoc">Fill the store with random bits and returns a reference to this for chaining.</div><div class="ttdef"><b>Definition</b> BitVec.h:1206</div></div>
<div class="ttc" id="anamespacegf2_html_a770302128133591da0ca93ded6abf8aa"><div class="ttname"><a href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">gf2::u64</a></div><div class="ttdeci">std::uint64_t u64</div><div class="ttdoc">Word type alias for a 64-bit unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac5e0764e73414967b27a7325bcfd581a" name="ac5e0764e73414967b27a7325bcfd581a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0764e73414967b27a7325bcfd581a">&#9670;&#160;</a></span>first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::first_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first set bit in the bit-store or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-432"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.first_set() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#ac5e0764e73414967b27a7325bcfd581a">first_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ac5e0764e73414967b27a7325bcfd581a"><div class="ttname"><a href="#ac5e0764e73414967b27a7325bcfd581a">gf2::BitVec::first_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_set() const</div><div class="ttdoc">Returns the index of the first set bit in the bit-store or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitVec.h:1277</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aab9955f248d42cff47e9a415db5d5f7b" name="aab9955f248d42cff47e9a415db5d5f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9955f248d42cff47e9a415db5d5f7b">&#9670;&#160;</a></span>first_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::first_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-436"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.first_unset() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#aab9955f248d42cff47e9a415db5d5f7b">first_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_aab9955f248d42cff47e9a415db5d5f7b"><div class="ttname"><a href="#aab9955f248d42cff47e9a415db5d5f7b">gf2::BitVec::first_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; first_unset() const</div><div class="ttdoc">Returns the index of the first unset bit in the bit-store or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitVec.h:1341</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac5f4a8bd9959119bbb1e3c36f11a0bb5" name="ac5f4a8bd9959119bbb1e3c36f11a0bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4a8bd9959119bbb1e3c36f11a0bb5">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bit-element <span class="tt">i</span> and returns this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index is bounds-checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-415"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line">v.flip(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0111111111&quot;</span>);</div>
<div class="line">v.flip(1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111111&quot;</span>);</div>
<div class="line">v.flip(9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0011111110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afda431c0fc232ab81d98e85088cb7cc1" name="afda431c0fc232ab81d98e85088cb7cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda431c0fc232ab81d98e85088cb7cc1">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the value of the bits in the store and returns a reference to this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="example-422"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">v.flip_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5d904d6460fa97d3fbbb8e7f7ef638bd" name="a5d904d6460fa97d3fbbb8e7f7ef638bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d904d6460fa97d3fbbb8e7f7ef638bd">&#9670;&#160;</a></span>from() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Src const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> bit-store instance. </p>
<h1 class="doxsection"><a class="anchor" id="note-3"></a>
Note</h1>
<p>Generally, we do not support interactions between bit-stores that use different underlying unsigned word types. This method is an exception &ndash; the <span class="tt">src</span> bit-store may use a different unsigned type from the one used here. It makes it possible to convert between bit-vector types which is occasionally useful.</p>
<h1 class="doxsection"><a class="anchor" id="example-387"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(<a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10));</div>
<div class="line">assert_eq(v.size(), 10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(<a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u16&gt;::ones</a>(20));</div>
<div class="line">assert_eq(w.size(), 20);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;11111111111111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> x = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(<a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u32&gt;::zeros</a>(10));</div>
<div class="line">assert_eq(x.size(), 10);</div>
<div class="line">assert_eq(x.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_adff516a657e2c3f2c703fbf778572148"><div class="ttname"><a href="#adff516a657e2c3f2c703fbf778572148">gf2::BitVec::from</a></div><div class="ttdeci">static constexpr BitVec from(Src src)</div><div class="ttdoc">Factory method to construct a bit-vector by copying all the bits from any Unsigned instance....</div><div class="ttdef"><b>Definition</b> BitVec.h:257</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adff516a657e2c3f2c703fbf778572148" name="adff516a657e2c3f2c703fbf778572148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff516a657e2c3f2c703fbf778572148">&#9670;&#160;</a></span>from() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Src&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">Src</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by copying <em>all</em> the bits from <em>any</em> <span class="tt"><a class="el" href="conceptgf2_1_1Unsigned.html" title="The Unsigned concept is the same as std::unsigned_integral. It is satisfied by all primitive unsigned...">Unsigned</a></span> instance. The resulting bit-vector will have the same size as the number of bits in the <span class="tt">src</span> unsigned integer. </p>
<h1 class="doxsection"><a class="anchor" id="example-386"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> s8 = 0b01010101;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(s8);</div>
<div class="line">assert_eq(u.size(), 8);</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a> s16 = 0b0101010101010101;</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(s16);</div>
<div class="line">assert_eq(v.size(), 16);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u32&gt;::from</a>(s8);</div>
<div class="line">assert_eq(w.size(), 8);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7f05d1a22cae97fba646ad9e689b839a" name="a7f05d1a22cae97fba646ad9e689b839a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f05d1a22cae97fba646ad9e689b839a">&#9670;&#160;</a></span>from() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from the bits of a <span class="tt">std::bitset</span>. </p>
<dl class="section note"><dt>Note</dt><dd><span class="tt">std::bitset</span> prints its bit elements in <em>bit-order</em> ...b2b1b0., we print in <em>vector-order</em> b0b1b2...</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-388"></a>
Example</h1>
<div class="fragment"><div class="line">std::bitset&lt;10&gt; src{0b1010101010};</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;&gt;::from</a>(src);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6e999cdb776c7d7b225a0ac092827e4b" name="a6e999cdb776c7d7b225a0ac092827e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e999cdb776c7d7b225a0ac092827e4b">&#9670;&#160;</a></span>from() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector by repeatedly calling <span class="tt">f(i)</span> for <span class="tt">i</span> in <span class="tt">[0, len)</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">f</td><td>The function to call for each index <span class="tt">i</span> in <span class="tt">[0, len)</span>.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-389"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#adff516a657e2c3f2c703fbf778572148">BitVec&lt;u8&gt;::from</a>(10, [](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(v.size(), 10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac8baf5a5cf90bb23038a3c97b6a9686c" name="ac8baf5a5cf90bb23038a3c97b6a9686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8baf5a5cf90bb23038a3c97b6a9686c">&#9670;&#160;</a></span>from_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_punctuation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a binary string, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The string can contain whitespace, commas, single quotes, and underscores. If the second argument is true, then the string is assumed to have none of the above characters. There can always be a "0b" prefix.</p>
<h1 class="doxsection"><a class="anchor" id="example-394"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ac8baf5a5cf90bb23038a3c97b6a9686c">BitVec&lt;u8&gt;::from_binary_string</a>(<span class="stringliteral">&quot;0b1010&#39;1010&#39;10&quot;</span>).value();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ac8baf5a5cf90bb23038a3c97b6a9686c">BitVec&lt;u8&gt;::from_binary_string</a>(<span class="stringliteral">&quot;&quot;</span>).value();</div>
<div class="line">assert_eq(u.to_string(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ac8baf5a5cf90bb23038a3c97b6a9686c"><div class="ttname"><a href="#ac8baf5a5cf90bb23038a3c97b6a9686c">gf2::BitVec::from_binary_string</a></div><div class="ttdeci">static std::optional&lt; BitVec &gt; from_binary_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVec.h:445</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a018d880a7c150488379b03951c9fbb00" name="a018d880a7c150488379b03951c9fbb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018d880a7c150488379b03951c9fbb00">&#9670;&#160;</a></span>from_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from_hex_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_punctuation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a hex string, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The hex string should consist of the characters 0-9, A-F, a-f, with an optional prefix "0x" or "0X". The string may also have a suffix of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8 which indicates that the last digit should be interpreted as a base <span class="tt">base</span> number. This allows for bit-vectors whose length is not a multiple of 4.</p>
<h1 class="doxsection"><a class="anchor" id="example-395"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0xAA&quot;</span>).value();</div>
<div class="line">assert_eq(v1.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1&quot;</span>).value();</div>
<div class="line">assert_eq(v2.to_string(), <span class="stringliteral">&quot;0001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.8&quot;</span>).value();</div>
<div class="line">assert_eq(v3.to_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v4 = <a class="code hl_function" href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.4&quot;</span>).value();</div>
<div class="line">assert_eq(v4.to_string(), <span class="stringliteral">&quot;01&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v5 = <a class="code hl_function" href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec&lt;&gt;::from_hex_string</a>(<span class="stringliteral">&quot;0x1.2&quot;</span>).value();</div>
<div class="line">assert_eq(v5.to_string(), <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a018d880a7c150488379b03951c9fbb00"><div class="ttname"><a href="#a018d880a7c150488379b03951c9fbb00">gf2::BitVec::from_hex_string</a></div><div class="ttdeci">static std::optional&lt; BitVec &gt; from_hex_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a hex string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVec.h:486</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a19b6684f4fa06d3f003029850da307f1" name="a19b6684f4fa06d3f003029850da307f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b6684f4fa06d3f003029850da307f1">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::from_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-vector from a string <span class="tt">s</span>, returning <span class="tt">std::nullopt</span> on failure. </p>
<p>The string can contain whitespace, commas, single quotes, and underscores and optionally a "0b", "0x", or "0X" prefix. If there is no prefix, and the string only contains '0' and '1' characters, we assume the string is binary. To force getting it interpreted as a hex string, add a prefix of "0x" or "0X".</p>
<p>A hex string can have a suffix of ".2", ".4", or ".8" to indicate the base of the last digit/character. This allows for bit-vectors of any length as opposed to just a multiple of 4.</p>
<h1 class="doxsection"><a class="anchor" id="example-393"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0b1010_1010_10&quot;</span>).value();</div>
<div class="line">assert_eq(v1.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;AA&quot;</span>).value();</div>
<div class="line">assert_eq(v2.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;1010&#39;1010&quot;</span>).value();</div>
<div class="line">assert_eq(v3.to_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v4 = <a class="code hl_function" href="#a19b6684f4fa06d3f003029850da307f1">BitVec&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0x1.8&quot;</span>).value();</div>
<div class="line">assert_eq(v4.to_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a19b6684f4fa06d3f003029850da307f1"><div class="ttname"><a href="#a19b6684f4fa06d3f003029850da307f1">gf2::BitVec::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVec &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVec.h:408</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd71df2577df7b16357fcaa6eeb1a24d" name="acd71df2577df7b16357fcaa6eeb1a24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd71df2577df7b16357fcaa6eeb1a24d">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the first bit element is set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the method panics of the store is empty.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-411"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.front(), <span class="keyword">true</span>);</div>
<div class="line">v.set_all(<span class="keyword">false</span>);</div>
<div class="line">assert_eq(v.front(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac682031cf75b027bc7ab6a54f767f819" name="ac682031cf75b027bc7ab6a54f767f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac682031cf75b027bc7ab6a54f767f819">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the bit at the given index <span class="tt">i</span> is set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index <span class="tt">i</span> is bounds-checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-409"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac682031cf75b027bc7ab6a54f767f819">get</a>(0), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac682031cf75b027bc7ab6a54f767f819">get</a>(0), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ac682031cf75b027bc7ab6a54f767f819"><div class="ttname"><a href="#ac682031cf75b027bc7ab6a54f767f819">gf2::BitVec::get</a></div><div class="ttdeci">constexpr bool get(usize i) const</div><div class="ttdoc">Returns true if the bit at the given index i is set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVec.h:916</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a24e0f0c5127892b1f84e8f46260bd331" name="a24e0f0c5127892b1f84e8f46260bd331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e0f0c5127892b1f84e8f46260bd331">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the store is empty, <span class="tt">false</span> otherwise. </p>
<h1 class="doxsection"><a class="anchor" id="example-417"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v;</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a24e0f0c5127892b1f84e8f46260bd331">is_empty</a>(), <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> u{10};</div>
<div class="line">assert_eq(u.<a class="code hl_function" href="#a24e0f0c5127892b1f84e8f46260bd331">is_empty</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a24e0f0c5127892b1f84e8f46260bd331"><div class="ttname"><a href="#a24e0f0c5127892b1f84e8f46260bd331">gf2::BitVec::is_empty</a></div><div class="ttdeci">constexpr bool is_empty() const</div><div class="ttdoc">Returns true if the store is empty, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVec.h:1045</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af193a47251b36284c46424524b904c0a" name="af193a47251b36284c46424524b904c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af193a47251b36284c46424524b904c0a">&#9670;&#160;</a></span>last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::last_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last set bit in the bit-store or <span class="tt">{}</span> if no bits are set. </p>
<h1 class="doxsection"><a class="anchor" id="example-433"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.last_set() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#af193a47251b36284c46424524b904c0a">last_set</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_af193a47251b36284c46424524b904c0a"><div class="ttname"><a href="#af193a47251b36284c46424524b904c0a">gf2::BitVec::last_set</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_set() const</div><div class="ttdoc">Returns the index of the last set bit in the bit-store or {} if no bits are set.</div><div class="ttdef"><b>Definition</b> BitVec.h:1292</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9f6b9b21f5c72b05db1739fcff74ca8f" name="a9f6b9b21f5c72b05db1739fcff74ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b9b21f5c72b05db1739fcff74ca8f">&#9670;&#160;</a></span>last_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::last_unset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last unset bit in the bit-store or <span class="tt">{}</span> if no bits are unset. </p>
<h1 class="doxsection"><a class="anchor" id="example-437"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{2});</div>
<div class="line">v.set(2);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.last_unset() == std::optional&lt;usize&gt;{27});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a9f6b9b21f5c72b05db1739fcff74ca8f">last_unset</a>() == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a9f6b9b21f5c72b05db1739fcff74ca8f"><div class="ttname"><a href="#a9f6b9b21f5c72b05db1739fcff74ca8f">gf2::BitVec::last_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; last_unset() const</div><div class="ttdoc">Returns the index of the last unset bit in the bit-store or {} if no bits are unset.</div><div class="ttdef"><b>Definition</b> BitVec.h:1358</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afc84d3c4f7a8304f52b28765475c3a8b" name="afc84d3c4f7a8304f52b28765475c3a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc84d3c4f7a8304f52b28765475c3a8b">&#9670;&#160;</a></span>leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::leading_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of leading zeros in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-430"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{37};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#afc84d3c4f7a8304f52b28765475c3a8b">leading_zeros</a>(), 37);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(27);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#afc84d3c4f7a8304f52b28765475c3a8b">leading_zeros</a>(), 27);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(w.leading_zeros(), 0);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_afc84d3c4f7a8304f52b28765475c3a8b"><div class="ttname"><a href="#afc84d3c4f7a8304f52b28765475c3a8b">gf2::BitVec::leading_zeros</a></div><div class="ttdeci">constexpr usize leading_zeros() const</div><div class="ttdoc">Returns the number of leading zeros in the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1245</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd6d60650865955b829d11de55199219" name="acd6d60650865955b829d11de55199219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6d60650865955b829d11de55199219">&#9670;&#160;</a></span>next_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::next_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next set bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more set bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-434"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.next_set(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.next_set(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.next_set(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.next_set(27) == std::optional&lt;usize&gt;{});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a01ff64db71253037f7990494190d132e" name="a01ff64db71253037f7990494190d132e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ff64db71253037f7990494190d132e">&#9670;&#160;</a></span>next_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::next_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the next unset bit after <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-438"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.next_unset(0) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.next_unset(2) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.next_unset(27) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a01ff64db71253037f7990494190d132e">next_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a01ff64db71253037f7990494190d132e"><div class="ttname"><a href="#a01ff64db71253037f7990494190d132e">gf2::BitVec::next_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; next_unset(usize index) const</div><div class="ttdoc">Returns the index of the next unset bit after index in the store or {} if no more unset bits exist.</div><div class="ttdef"><b>Definition</b> BitVec.h:1374</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abc79128289adb4dd8d15f536cea6fb07" name="abc79128289adb4dd8d15f536cea6fb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc79128289adb4dd8d15f536cea6fb07">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no bits in the store are set, <span class="tt">false</span> otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Empty store have no set bits (logical connective for <span class="tt"><a class="el" href="#abc79128289adb4dd8d15f536cea6fb07" title="Returns true if no bits in the store are set, false otherwise.">none</a></span> is <span class="tt">AND</span> with identity <span class="tt">true</span>).</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-420"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#abc79128289adb4dd8d15f536cea6fb07">none</a>(), <span class="keyword">true</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#abc79128289adb4dd8d15f536cea6fb07">none</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_abc79128289adb4dd8d15f536cea6fb07"><div class="ttname"><a href="#abc79128289adb4dd8d15f536cea6fb07">gf2::BitVec::none</a></div><div class="ttdeci">constexpr bool none() const</div><div class="ttdoc">Returns true if no bits in the store are set, false otherwise.</div><div class="ttdef"><b>Definition</b> BitVec.h:1086</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5aeba2cd4fa570743723c3ef3bbd8ac4" name="a5aeba2cd4fa570743723c3ef3bbd8ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aeba2cd4fa570743723c3ef3bbd8ac4">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::offset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset (in bits) of the first bit in the store within the first word. </p>
<p>This is always zero for <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a></span>. </p>

</div>
</div>
<a id="abe88a62254e18559eaa3a5bdc8eec2c7" name="abe88a62254e18559eaa3a5bdc8eec2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe88a62254e18559eaa3a5bdc8eec2c7">&#9670;&#160;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-382"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(10).<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad07a5992e0db88d8b7732275c39fa9ef" name="ad07a5992e0db88d8b7732275c39fa9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07a5992e0db88d8b7732275c39fa9ef">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "reference" to the bit element <span class="tt">i</span>. </p>
<p>The returned object is a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference for the bit element at <span class="tt">index</span> rather than a true reference.</p>
<dl class="section note"><dt>Note</dt><dd>The referenced bit-store must continue to exist while the <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> is in use. </dd>
<dd>
In debug mode the index <span class="tt">i</span> is bounds-checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-414"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(10);</div>
<div class="line">v[3] = w[3];</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;0011000000&quot;</span>);</div>
<div class="line">v[4] |= w[4];</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;0011100000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2d98eb19ca984d29e87fd750c2768f75" name="a2d98eb19ca984d29e87fd750c2768f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d98eb19ca984d29e87fd750c2768f75">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boolean value of the bit element <span class="tt">i</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index is bounds-checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-410"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert(v[2] == <span class="keyword">false</span>);</div>
<div class="line">v[2] = <span class="keyword">true</span>;</div>
<div class="line">assert(v[2] == <span class="keyword">true</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;0010000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7ae048f5abad05cf4e62a3a36338a0cc" name="a7ae048f5abad05cf4e62a3a36338a0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae048f5abad05cf4e62a3a36338a0cc">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; bool &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::pop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last bit from the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-401"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a5843880584a61949af70e645f0db7d14">push</a>(1);</div>
<div class="line">v.<a class="code hl_function" href="#a5843880584a61949af70e645f0db7d14">push</a>(0);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;10&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b1 = v.<a class="code hl_function" href="#a7ae048f5abad05cf4e62a3a36338a0cc">pop</a>();</div>
<div class="line">assert_eq(*b1, <span class="keyword">false</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b2 = v.<a class="code hl_function" href="#a7ae048f5abad05cf4e62a3a36338a0cc">pop</a>();</div>
<div class="line">assert_eq(*b2, <span class="keyword">true</span>);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> b3 = v.<a class="code hl_function" href="#a7ae048f5abad05cf4e62a3a36338a0cc">pop</a>();</div>
<div class="line">assert(b3 == std::nullopt);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a5843880584a61949af70e645f0db7d14"><div class="ttname"><a href="#a5843880584a61949af70e645f0db7d14">gf2::BitVec::push</a></div><div class="ttdeci">constexpr BitVec &amp; push(bool b)</div><div class="ttdoc">Pushes a single bit b onto the bit-vector.</div><div class="ttdef"><b>Definition</b> BitVec.h:628</div></div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a7ae048f5abad05cf4e62a3a36338a0cc"><div class="ttname"><a href="#a7ae048f5abad05cf4e62a3a36338a0cc">gf2::BitVec::pop</a></div><div class="ttdeci">constexpr std::optional&lt; bool &gt; pop()</div><div class="ttdoc">Removes the last bit from the bit-vector and returns it or std::nullopt if the bit-vector is empty.</div><div class="ttdef"><b>Definition</b> BitVec.h:651</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aca2b1afc660ff95d8ec775cbc2689dcc" name="aca2b1afc660ff95d8ec775cbc2689dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b1afc660ff95d8ec775cbc2689dcc">&#9670;&#160;</a></span>previous_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::previous_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous set bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-435"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(37);</div>
<div class="line">assert(v.previous_set(36) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2);</div>
<div class="line">v.set(27);</div>
<div class="line">assert(v.previous_set(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.previous_set(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.previous_set(2)  == std::optional&lt;usize&gt;{});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a35581d0c84cca8d385abd42e963cb69e" name="a35581d0c84cca8d385abd42e963cb69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35581d0c84cca8d385abd42e963cb69e">&#9670;&#160;</a></span>previous_unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::previous_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the previous unset bit before <span class="tt">index</span> in the store or <span class="tt">{}</span> if no more unset bits exist. </p>
<h1 class="doxsection"><a class="anchor" id="example-439"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(37);</div>
<div class="line">assert(v.previous_unset(0) == std::optional&lt;usize&gt;{});</div>
<div class="line">v.set(2, <span class="keyword">false</span>);</div>
<div class="line">v.set(27, <span class="keyword">false</span>);</div>
<div class="line">assert(v.previous_unset(36) == std::optional&lt;usize&gt;{27});</div>
<div class="line">assert(v.previous_unset(27) == std::optional&lt;usize&gt;{2});</div>
<div class="line">assert(v.previous_unset(2) == std::optional&lt;usize&gt;{});</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert(empty.<a class="code hl_function" href="#a35581d0c84cca8d385abd42e963cb69e">previous_unset</a>(0) == std::optional&lt;usize&gt;{});</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a35581d0c84cca8d385abd42e963cb69e"><div class="ttname"><a href="#a35581d0c84cca8d385abd42e963cb69e">gf2::BitVec::previous_unset</a></div><div class="ttdeci">constexpr std::optional&lt; usize &gt; previous_unset(usize index) const</div><div class="ttdoc">Returns the index of the previous unset bit before index in the store or {} if no more unset bits exi...</div><div class="ttdef"><b>Definition</b> BitVec.h:1390</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5843880584a61949af70e645f0db7d14" name="a5843880584a61949af70e645f0db7d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5843880584a61949af70e645f0db7d14">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::push </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a single bit <span class="tt">b</span> onto the bit-vector. </p>
<p>Returns a reference to the current object for chaining.</p>
<h1 class="doxsection"><a class="anchor" id="example-400"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v;</div>
<div class="line">v.<a class="code hl_function" href="#a5843880584a61949af70e645f0db7d14">push</a>(1);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a5843880584a61949af70e645f0db7d14">push</a>(0);</div>
<div class="line">assert(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>() == <span class="stringliteral">&quot;10&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab57ee9beea8e50d4671758c20e544215" name="ab57ee9beea8e50d4671758c20e544215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57ee9beea8e50d4671758c20e544215">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are picked at random. </p>
<p>The default call <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;&gt;::random(len)</span> produces a random bit-vector with each bit being 1 with probability 0.5 and where the RNG is seeded from entropy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the bit-vector is all zeros, if <span class="tt">p &gt; 1</span> then the bit-vector is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-390"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ab57ee9beea8e50d4671758c20e544215">BitVec&lt;&gt;::random</a>(10, 0.5, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ab57ee9beea8e50d4671758c20e544215">BitVec&lt;&gt;::random</a>(10, 0.5, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ab57ee9beea8e50d4671758c20e544215"><div class="ttname"><a href="#ab57ee9beea8e50d4671758c20e544215">gf2::BitVec::random</a></div><div class="ttdeci">static BitVec random(usize len, double p=0.5, u64 seed=0)</div><div class="ttdoc">Factory method to generate a bit-vector of size len where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitVec.h:345</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9cea0afd5df1aa626b1319c4897ac970" name="a9cea0afd5df1aa626b1319c4897ac970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cea0afd5df1aa626b1319c4897ac970">&#9670;&#160;</a></span>remaining_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::remaining_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>additional</em> elements we can store in the bit-vector without reallocating. </p>
<h1 class="doxsection"><a class="anchor" id="example-397"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u64&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.remaining_capacity(), 54);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abac2ae23aebeffc85bce13f6e0528783" name="abac2ae23aebeffc85bce13f6e0528783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac2ae23aebeffc85bce13f6e0528783">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the bit-vector so that its <span class="tt"><a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a></span> is <span class="tt">n</span>. </p>
<ul>
<li>If <span class="tt">n</span> is greater than the bit-vector's current size, then the new elements are set to 0.</li>
<li>If <span class="tt">n</span> is less than the bit-vector's current size, then the bit-vector is truncated.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-399"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(1000);</div>
<div class="line">v.resize(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">v.resize(15);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;111111111100000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8cd602e2d070e57a59c82f129a30e65e" name="a8cd602e2d070e57a59c82f129a30e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd602e2d070e57a59c82f129a30e65e">&#9670;&#160;</a></span>riffled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-vector that is the result of riffling the bits in this bit-store with zeros. </p>
<p>If bit-store has the bits <span class="tt">abcde</span> then the output bit-vector will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<dl class="section note"><dt>Note</dt><dd>There is no last zero bit in <span class="tt">dst</span>.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-452"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> dst = v.riffled();</div>
<div class="line">assert_eq(dst.to_string(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a16de7a2d5ab564306a2420545696a068" name="a16de7a2d5ab564306a2420545696a068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16de7a2d5ab564306a2420545696a068">&#9670;&#160;</a></span>riffled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::riffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaves the bits of this bit-store with zeros storing the result into the bit-vector <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> will have the bits of this bit-store interleaved with zeros. For example, if this bit-store has the bits <span class="tt">abcde</span> then <span class="tt">dst</span> will have the bits <span class="tt">a0b0c0d0e</span>.</p>
<dl class="section note"><dt>Note</dt><dd>There is no last zero bit in <span class="tt">dst</span>.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-451"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> dst;</div>
<div class="line">v.riffled(dst);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1010101010101010101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac162f922f382c8607410e40ea3661771" name="ac162f922f382c8607410e40ea3661771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac162f922f382c8607410e40ea3661771">&#9670;&#160;</a></span>seeded_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a></td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of size <span class="tt">len</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random bit-vectors, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the bit-vector to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">p &lt; 0</span> then the bit-vector is all zeros, if <span class="tt">p &gt; 1</span> then the bit-vector is all ones.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-391"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegf2.html#a770302128133591da0ca93ded6abf8aa">u64</a> seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ac162f922f382c8607410e40ea3661771">BitVec&lt;&gt;::seeded_random</a>(10, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ac162f922f382c8607410e40ea3661771">BitVec&lt;&gt;::seeded_random</a>(10, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_ac162f922f382c8607410e40ea3661771"><div class="ttname"><a href="#ac162f922f382c8607410e40ea3661771">gf2::BitVec::seeded_random</a></div><div class="ttdeci">static BitVec seeded_random(usize len, u64 seed)</div><div class="ttdoc">Factory method to generate a bit-vector of size len where the elements are from independent fair coin...</div><div class="ttdef"><b>Definition</b> BitVec.h:368</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a96e7eb01840c25b04c77e737d3629ed4" name="a96e7eb01840c25b04c77e737d3629ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e7eb01840c25b04c77e737d3629ed4">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit-element <span class="tt">i</span> to the specified boolean <span class="tt">value</span> &amp; returns this for chaining. The default value for <span class="tt">value</span> is <span class="tt">true</span>. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index is bounds-checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-413"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac682031cf75b027bc7ab6a54f767f819">get</a>(0), <span class="keyword">false</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#ac682031cf75b027bc7ab6a54f767f819">get</a>(0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a188e583de62ec470801b098249a044a0" name="a188e583de62ec470801b098249a044a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188e583de62ec470801b098249a044a0">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bits in the store to the boolean <span class="tt">value</span> and returns a reference to this for chaining. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-421"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">v.set_all();</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aac4e0bcb2be911a8bd590932e28fcb31" name="aac4e0bcb2be911a8bd590932e28fcb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4e0bcb2be911a8bd590932e28fcb31">&#9670;&#160;</a></span>set_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::set_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>set</em> bits in the bit-store. </p>
<p>You can use this iterator to iterate over the set bits in the store and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-442"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.set_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{0, 2, 4, 6, 8}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acb878752cc181ef833e9dafbb059cb8c" name="acb878752cc181ef833e9dafbb059cb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb878752cc181ef833e9dafbb059cb8c">&#9670;&#160;</a></span>set_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::set_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets word <span class="tt">i</span> in the bit-vector's underlying word store to <span class="tt">value</span> (masked if necessary). </p>
<p>The final word in the store may not be fully occupied but we ensure that unused bits remain set to 0.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index is bounds checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-375"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.set_word(1, 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000011&quot;</span>);</div>
<div class="line">assert_eq(v.count_ones(), 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a86c9723397a5256e234fe7f9cebda6df" name="a86c9723397a5256e234fe7f9cebda6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c9723397a5256e234fe7f9cebda6df">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> &amp; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks the bit-vector's capacity as much as possible. </p>
<p>This method may do nothing.</p>
<h1 class="doxsection"><a class="anchor" id="example-398"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(1000);</div>
<div class="line">v.resize(15);</div>
<div class="line">v.shrink_to_fit();</div>
<div class="line">assert_eq(v.capacity(), 16);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a54e7e8f54ed7dcb6d85e7c655aba03e1" name="a54e7e8f54ed7dcb6d85e7c655aba03e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bit-elements in the bit-vector. </p>
<h1 class="doxsection"><a class="anchor" id="example-372"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1">size</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.size(), 10);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af7e112efa01260c893f5a74d34953c47" name="af7e112efa01260c893f5a74d34953c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e112efa01260c893f5a74d34953c47">&#9670;&#160;</a></span>span() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable bit-span encompassing the bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Mutability here is deep &ndash; the interior pointer in the returned span is to <em>non-const</em> words.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the span range is not valid.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-447"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a16b78eb9514437fd3ba23cfc28a31f19" name="a16b78eb9514437fd3ba23cfc28a31f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b78eb9514437fd3ba23cfc28a31f19">&#9670;&#160;</a></span>span() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <em>immutable</em> bit-span encompassing the store's bits in the half-open range <span class="tt">[begin, end)</span>. </p>
<p>Immutability here is deep &ndash; the interior pointer in the returned span is to <em>const</em> words.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the span range is not valid.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-446"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.span(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a74964c052d3bff286b71d3a43d0da288" name="a74964c052d3bff286b71d3a43d0da288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74964c052d3bff286b71d3a43d0da288">&#9670;&#160;</a></span>split_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are returned as a pair of bit-vectors [<span class="tt">left</span>, <span class="tt">right</span>].</p>
<p>On return, <span class="tt">left</span> is a clone of the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the split point is beyond the end of the bit-vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-450"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> [left, right] = v.split_at(5);</div>
<div class="line">assert_eq(left.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.to_string(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aad2cdea9a00459c91c7183b3ac190712" name="aad2cdea9a00459c91c7183b3ac190712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2cdea9a00459c91c7183b3ac190712">&#9670;&#160;</a></span>split_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; <a class="el" href="#ad1e5d382e4b7ae827e5b14a4b44d3e09">word_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Views a bit-store as two parts containing the elements <span class="tt">[0, at)</span> and <span class="tt">[at, <a class="el" href="#a54e7e8f54ed7dcb6d85e7c655aba03e1" title="Returns the number of bit-elements in the bit-vector.">size()</a>)</span> respectively. </p>
<p>Clones of the parts are stored in the passed bit-vectors <span class="tt">left</span> and <span class="tt">right</span>.</p>
<p>On return, <span class="tt">left</span> contains the bits from the start of the bit-vector up to but not including <span class="tt">at</span> and <span class="tt">right</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. This bit-vector itself is not modified.</p>
<p>This lets one reuse the <span class="tt">left</span> and <span class="tt">right</span> destinations without having to allocate new bit-vectors. This is useful when implementing iterative algorithms that need to split a bit-vector into two parts repeatedly.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the split point is beyond the end of the bit-vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-449"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> left, right;</div>
<div class="line">v.split_at(5, left, right);</div>
<div class="line">assert_eq(left.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(right.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa1ac4a0001c584bf0f384febd3ee3cc6" name="aa1ac4a0001c584bf0f384febd3ee3cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ac4a0001c584bf0f384febd3ee3cc6">&#9670;&#160;</a></span>split_off() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::split_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a bit-vector into two at the given index, returning a new <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a></span>. </p>
<p>The returned bit-vector contains the bits from <span class="tt">at</span> to the end of the bit-vector. The bit-vector is resized to only contain the bits in the half-open range <span class="tt">[0, at)</span>.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the split point is beyond the end of the bit-vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-407"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> w = v.split_off(5);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60877bf5ff25a746976ffa049aff82ad" name="a60877bf5ff25a746976ffa049aff82ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60877bf5ff25a746976ffa049aff82ad">&#9670;&#160;</a></span>split_off() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::split_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a bit-vector into two at the given index, returning the second part in <span class="tt">dst</span>. </p>
<p>On return, <span class="tt">dst</span> contains the bits from <span class="tt">at</span> to the end of the bit-vector. The bit-vector is resized to only contain the bits in the half-open range <span class="tt">[0, at)</span>.</p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the split point is beyond the end of the bit-vector.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-408"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> dst;</div>
<div class="line">v.split_off(5, dst);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;10101&quot;</span>);</div>
<div class="line">assert_eq(dst.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;01010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad2b7eb7f8f39597fe4ac171e9c6d3d27" name="ad2b7eb7f8f39597fe4ac171e9c6d3d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7eb7f8f39597fe4ac171e9c6d3d27">&#9670;&#160;</a></span>split_off_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;Unsigned Dst = Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Dst &gt; <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::split_off_unsigned </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split off a single arbitrary sized unsigned integer off the end of the bit-vector and returns it or <span class="tt">std::nullopt</span> if the bit-vector is empty. </p>
<dl class="section note"><dt>Note</dt><dd>You can split off a primitive unsigned integer type of <em>any</em> size from the end of a non-empty bit-vector.</dd></dl>
<p>For example, if <span class="tt">v</span> is a <span class="tt"><a class="el" href="classgf2_1_1BitVec.html" title="A dynamically-sized vector over GF(2) with bit elements compactly stored in a standard vector of prim...">BitVec</a>&lt;<a class="el" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940" title="Word type alias for an 8-bit unsigned integer.">u8</a>&gt;</span>with 22 elements, then you can split off a <span class="tt"><a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a></span> value from the end of <span class="tt">v</span> by calling <span class="tt">v.split_off_unsigned&lt;<a class="el" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0" title="Word type alias for a 16-bit unsigned integer.">u16</a>&gt;()</span>. This leaves the bit-vector with 6 elements.</p>
<h1 class="doxsection"><a class="anchor" id="examples"></a>
Examples</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(22);</div>
<div class="line"><span class="keyword">auto</span> x16 = v.split_off_unsigned&lt;<a class="code hl_typedef" href="namespacegf2.html#ae858164ae3b877b1f9ea2606fae215a0">u16</a>&gt;();</div>
<div class="line">assert_eq(*x16, 0b1111&#39;1111&#39;1111&#39;1111);</div>
<div class="line">assert_eq(v.size(), 6);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> w = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;u8&gt;::alternating</a>(24);</div>
<div class="line"><span class="keyword">auto</span> x8 = w.split_off_unsigned&lt;<a class="code hl_typedef" href="namespacegf2.html#a872a69469085fcdddf299ae4adc3c940">u8</a>&gt;();</div>
<div class="line">assert_eq(*x8, 0b0101&#39;0101);</div>
<div class="line">assert_eq(w.size(), 16);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;1010101010101010&quot;</span>);</div>
<div class="line">w.append(*x8);</div>
<div class="line">assert_eq(w.to_string(), <span class="stringliteral">&quot;101010101010101010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7d3ff5adb0af65ef42b2a675589caae7" name="a7d3ff5adb0af65ef42b2a675589caae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3ff5adb0af65ef42b2a675589caae7">&#9670;&#160;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word * <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying store of words. </p>
<dl class="section note"><dt>Note</dt><dd>The pointer is non-const but you should be careful about using it to modify the words in the store.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-377"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> ptr = v.store();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abfc4befce710a6af1421985116e96633" name="abfc4befce710a6af1421985116e96633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc4befce710a6af1421985116e96633">&#9670;&#160;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Word * <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::store </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the underlying store of words . </p>
<h1 class="doxsection"><a class="anchor" id="example-376"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> ptr = v.store();</div>
<div class="line">assert_eq(*ptr, 0b1111&#39;1111);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a59995a46ced1daef94f1f5ec3e34a97f" name="a59995a46ced1daef94f1f5ec3e34a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59995a46ced1daef94f1f5ec3e34a97f">&#9670;&#160;</a></span>store_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::store_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator over all the <em>words</em> underlying the bit-store. </p>
<p>You can use this iterator to iterate over the words in the store and read the <span class="tt">Word</span> value of each word. You <b>cannot</b> use this iterator to modify the words in the store.</p>
<dl class="section note"><dt>Note</dt><dd>The words here may be a synthetic construct. The expectation is that the bit <span class="tt">0</span> in the store is located at the bit-location <span class="tt">0</span> of <span class="tt">word(0)</span>. That is always the case for bit-vectors but bit-slices typically synthesise "words" on the fly from adjacent pairs of bit-vector words. Nevertheless, almost all the methods in <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> are implemented efficiently by operating on those words.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-444"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a87103730819743af8ff170fb5ca13185">words</a> = std::ranges::to&lt;std::vector&gt;(v.store_words());</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a87103730819743af8ff170fb5ca13185">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a87103730819743af8ff170fb5ca13185"><div class="ttname"><a href="#a87103730819743af8ff170fb5ca13185">gf2::BitVec::words</a></div><div class="ttdeci">constexpr usize words() const</div><div class="ttdoc">Returns the number of words in the bit-vector&#39;s underlying word store.</div><div class="ttdef"><b>Definition</b> BitVec.h:63</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a66f22d5eb48cbd639e080bca8cae94c3" name="a66f22d5eb48cbd639e080bca8cae94c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f22d5eb48cbd639e080bca8cae94c3">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <em>clone</em> of the elements in the half-open range <span class="tt">[begin, end)</span> as a new bit-vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method panics if the range is not valid.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-448"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line"><span class="keyword">auto</span> s = v.sub(1,5);</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;0101&quot;</span>);</div>
<div class="line">s.set_all();</div>
<div class="line">assert_eq(s.to_string(), <span class="stringliteral">&quot;1111&quot;</span>);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae5b995b704e31fedcf979c57d470dfb8" name="ae5b995b704e31fedcf979c57d470dfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b995b704e31fedcf979c57d470dfb8">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bits in the bit-store at indices <span class="tt">i0</span> and <span class="tt">i1</span> and returns this for chaining. </p>
<dl class="section note"><dt>Note</dt><dd>In debug mode, panics if either of the indices is out of bounds.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-416"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;&gt;::zeros</a>(10);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.swap(0, 1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0100000000&quot;</span>);</div>
<div class="line">v.swap(0, 1);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">v.swap(0, 9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="line">v.swap(0, 9);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af4276ca5b45a8020549679b55ce4b41c" name="af4276ca5b45a8020549679b55ce4b41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4276ca5b45a8020549679b55ce4b41c">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the store. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-453"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#af4276ca5b45a8020549679b55ce4b41c">to_binary_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#af4276ca5b45a8020549679b55ce4b41c">to_binary_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#af4276ca5b45a8020549679b55ce4b41c">to_binary_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_af4276ca5b45a8020549679b55ce4b41c"><div class="ttname"><a href="#af4276ca5b45a8020549679b55ce4b41c">gf2::BitVec::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view sep=&quot;&quot;, std::string_view pre=&quot;&quot;, std::string_view post=&quot;&quot;) const</div><div class="ttdoc">Returns a binary string representation of the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1638</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a795cf2bcc162662e2b1c845d87e57d55" name="a795cf2bcc162662e2b1c845d87e57d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795cf2bcc162662e2b1c845d87e57d55">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "hex" string representation of the bits in the bit-store. </p>
<p>The output is a string of hex characters without any spaces, commas, or other formatting.</p>
<p>The string may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
 Empty bit-vectors are represented as the empty string.</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<p>The output is in <em>vector-order</em>. If "h0" is the first hex digit in the output string, you can print it as four binary digits <span class="tt">v_0v_1v_2v_3</span>. For example, if h0 = "A" which is <span class="tt">1010</span> in binary, then v = 1010.</p>
<h1 class="doxsection"><a class="anchor" id="example-456"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a795cf2bcc162662e2b1c845d87e57d55">to_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v1 = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(4);</div>
<div class="line">assert_eq(v1.to_hex_string(), <span class="stringliteral">&quot;F&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v2 = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(v2.to_hex_string(), <span class="stringliteral">&quot;F1.2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> v3 = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(8);</div>
<div class="line">assert_eq(v3.to_binary_string(), <span class="stringliteral">&quot;10101010&quot;</span>);</div>
<div class="line">assert_eq(v3.to_hex_string(), <span class="stringliteral">&quot;AA&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a795cf2bcc162662e2b1c845d87e57d55"><div class="ttname"><a href="#a795cf2bcc162662e2b1c845d87e57d55">gf2::BitVec::to_hex_string</a></div><div class="ttdeci">std::string to_hex_string() const</div><div class="ttdoc">Returns the &quot;hex&quot; string representation of the bits in the bit-store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1707</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a80600ca582bde198ecea6b9d2c2dda57" name="a80600ca582bde198ecea6b9d2c2dda57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80600ca582bde198ecea6b9d2c2dda57">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a "pretty" string representation of the store. </p>
<p>The output is a string of 0's and 1's with spaces between each bit, and the whole thing enclosed in square brackets.</p>
<h1 class="doxsection"><a class="anchor" id="example-455"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_pretty_string(), <span class="stringliteral">&quot;[1,0,1,0,1,0,1,0,1,0]&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> empty;</div>
<div class="line">assert_eq(empty.<a class="code hl_function" href="#a80600ca582bde198ecea6b9d2c2dda57">to_pretty_string</a>(), <span class="stringliteral">&quot;[]&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a80600ca582bde198ecea6b9d2c2dda57"><div class="ttname"><a href="#a80600ca582bde198ecea6b9d2c2dda57">gf2::BitVec::to_pretty_string</a></div><div class="ttdeci">std::string to_pretty_string() const</div><div class="ttdoc">Returns a &quot;pretty&quot; string representation of the store.</div><div class="ttdef"><b>Definition</b> BitVec.h:1675</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2c17d2d2fb6d1f9f13828e2d8c085d4a" name="a2c17d2d2fb6d1f9f13828e2d8c085d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>pre</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>post</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a binary string representation of the store. </p>
<p>The string is formatted as a sequence of <span class="tt">0</span>s and <span class="tt">1</span>s with the least significant bit on the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The separator between bit elements which defaults to no separator. </td></tr>
    <tr><td class="paramname">pre</td><td>The prefix to add to the string which defaults to no prefix. </td></tr>
    <tr><td class="paramname">post</td><td>The postfix to add to the string which defaults to no postfix.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-454"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v{10};</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="#a96e7eb01840c25b04c77e737d3629ed4">set</a>(0);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(v.<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>), <span class="stringliteral">&quot;[1,0,0,0,0,0,0,0,0,0]&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b8920fb3faa73171f9e1e8ae8e90953" name="a8b8920fb3faa73171f9e1e8ae8e90953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8920fb3faa73171f9e1e8ae8e90953">&#9670;&#160;</a></span>to_words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::to_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the words underlying this bit-store. </p>
<dl class="section note"><dt>Note</dt><dd>The last word in the vector may not be fully occupied but unused slots will be all zeros.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-445"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a87103730819743af8ff170fb5ca13185">words</a> = v.to_words();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a87103730819743af8ff170fb5ca13185">words</a>, (std::vector&lt;u8&gt;{0b1111&#39;1111, 0b0000&#39;0011}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3681bc0ae42792d49670789feb85a46d" name="a3681bc0ae42792d49670789feb85a46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3681bc0ae42792d49670789feb85a46d">&#9670;&#160;</a></span>trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::trailing_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of trailing zeros in the store. </p>
<h1 class="doxsection"><a class="anchor" id="example-431"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;u8&gt;::zeros</a>(27);</div>
<div class="line">assert_eq(v.trailing_zeros(), 27);</div>
<div class="line">v.set(0);</div>
<div class="line">assert_eq(v.trailing_zeros(), 26);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af8291af2e5ead48379b0ab5eeee87ef8" name="af8291af2e5ead48379b0ab5eeee87ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8291af2e5ead48379b0ab5eeee87ef8">&#9670;&#160;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a "unit" bit-vector of length <span class="tt">n</span> where only element <span class="tt">i</span> is set. </p>
<p>This method panics if the condition <span class="tt">i &lt; n</span> is not met.</p>
<h1 class="doxsection"><a class="anchor" id="example-384"></a>
Example</h1>
<div class="fragment"><div class="line">assert_eq(<a class="code hl_function" href="#af8291af2e5ead48379b0ab5eeee87ef8">BitVec&lt;&gt;::unit</a>(10, 0).<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;1000000000&quot;</span>);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#af8291af2e5ead48379b0ab5eeee87ef8">BitVec&lt;&gt;::unit</a>(10, 9).<a class="code hl_function" href="#a2c17d2d2fb6d1f9f13828e2d8c085d4a">to_string</a>(), <span class="stringliteral">&quot;0000000001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_af8291af2e5ead48379b0ab5eeee87ef8"><div class="ttname"><a href="#af8291af2e5ead48379b0ab5eeee87ef8">gf2::BitVec::unit</a></div><div class="ttdeci">static constexpr BitVec unit(usize n, usize i)</div><div class="ttdoc">Factory method to generate a &quot;unit&quot; bit-vector of length n where only element i is set.</div><div class="ttdef"><b>Definition</b> BitVec.h:224</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afdc9bdd91c2640a600ab38540483f5ed" name="afdc9bdd91c2640a600ab38540483f5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc9bdd91c2640a600ab38540483f5ed">&#9670;&#160;</a></span>unset_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::unset_bits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator over the <em>indices</em> of any <em>unset</em> bits in the bit-store. </p>
<p>You can use this iterator to iterate over the unset bits in the store and get the index of each bit.</p>
<h1 class="doxsection"><a class="anchor" id="example-443"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#aa2a913940a592ccc49ed6754f606c411">BitVec&lt;u8&gt;::alternating</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1010101010&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> indices = std::ranges::to&lt;std::vector&gt;(v.unset_bits());</div>
<div class="line">assert_eq(indices, (std::vector&lt;usize&gt;{1, 3, 5, 7, 9}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a89d721629c0bd3546fc77a1448a3185c" name="a89d721629c0bd3546fc77a1448a3185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d721629c0bd3546fc77a1448a3185c">&#9670;&#160;</a></span>with_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::with_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct an empty bit-vector with at least the specified capacity. </p>
<h1 class="doxsection"><a class="anchor" id="example-380"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a89d721629c0bd3546fc77a1448a3185c">BitVec&lt;&gt;::with_capacity</a>(10);</div>
<div class="line">assert_eq(v.size(), 0);</div>
<div class="line">assert(v.capacity() &gt;=10);</div>
<div class="ttc" id="aclassgf2_1_1BitVec_html_a89d721629c0bd3546fc77a1448a3185c"><div class="ttname"><a href="#a89d721629c0bd3546fc77a1448a3185c">gf2::BitVec::with_capacity</a></div><div class="ttdeci">static constexpr BitVec with_capacity(usize capacity)</div><div class="ttdoc">Factory method to construct an empty bit-vector with at least the specified capacity.</div><div class="ttdef"><b>Definition</b> BitVec.h:181</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1d6e74f511ed45d28b2b918107eff1ef" name="a1d6e74f511ed45d28b2b918107eff1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6e74f511ed45d28b2b918107eff1ef">&#9670;&#160;</a></span>word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns word <span class="tt">i</span> from the bit-vector's underlying word store. </p>
<p>The final word in the store may not be fully occupied but we guarantee that unused bits are set to 0.</p>
<dl class="section note"><dt>Note</dt><dd>In debug mode the index is bounds checked.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="example-374"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#abe88a62254e18559eaa3a5bdc8eec2c7">BitVec&lt;u8&gt;::ones</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;1111111111&quot;</span>);</div>
<div class="line">assert_eq(v.words(), 2);</div>
<div class="line">assert_eq(v.word(0), 0b1111&#39;1111);</div>
<div class="line">assert_eq(v.word(1), 0b0000&#39;0011);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a87103730819743af8ff170fb5ca13185" name="a87103730819743af8ff170fb5ca13185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87103730819743af8ff170fb5ca13185">&#9670;&#160;</a></span>words()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words in the bit-vector's underlying word store. </p>
<p>The bit-elements are packed into a standard vector with this number of words.</p>
<h1 class="doxsection"><a class="anchor" id="example-373"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec</a> v0;</div>
<div class="line">assert_eq(v0.<a class="code hl_function" href="#a87103730819743af8ff170fb5ca13185">words</a>(), 0);</div>
<div class="line"><a class="code hl_function" href="#a038038c80199c235110eb287b0d557df">BitVec&lt;u8&gt;</a> v1(10);</div>
<div class="line">assert_eq(v1.words(), 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9cbdc533df0b2efeca27daaee792b081" name="a9cbdc533df0b2efeca27daaee792b081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbdc533df0b2efeca27daaee792b081">&#9670;&#160;</a></span>zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a038038c80199c235110eb287b0d557df">BitVec</a> <a class="el" href="classgf2_1_1BitVec.html">gf2::BitVec</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-vector of length <span class="tt">n</span> where the elements are all 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-381"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a9cbdc533df0b2efeca27daaee792b081">BitVec&lt;&gt;::zeros</a>(10);</div>
<div class="line">assert_eq(v.to_string(), <span class="stringliteral">&quot;0000000000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitVec.html">BitVec</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
