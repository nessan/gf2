<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: gf2::BitMatrix&lt; Word &gt;</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classgf2_1_1BitMatrix.html','','classgf2_1_1BitMatrix-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">gf2::BitMatrix&lt; Word &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the matrix. The row elements are compactly stored in standard vectors of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BitMatrix_8h_source.html">BitMatrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8871103e8ad06e7c118246e3ae64b050" id="r_a8871103e8ad06e7c118246e3ae64b050"><td class="memItemLeft" align="right" valign="top"><a id="a8871103e8ad06e7c118246e3ae64b050" name="a8871103e8ad06e7c118246e3ae64b050"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_type</b> = Word</td></tr>
<tr class="memdesc:a8871103e8ad06e7c118246e3ae64b050"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying unsigned word type used to store the bits. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ae5c368ef2b300f03a588f7461623d177" id="r_ae5c368ef2b300f03a588f7461623d177"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> ()</td></tr>
<tr class="memdesc:ae5c368ef2b300f03a588f7461623d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor creates an empty bit-matrix with no rows or columns.  <br /></td></tr>
<tr class="memitem:a22e7cc4d491400a387a1ab895effffed" id="r_a22e7cc4d491400a387a1ab895effffed"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22e7cc4d491400a387a1ab895effffed">BitMatrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a22e7cc4d491400a387a1ab895effffed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> square bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:a24d56fbaf0c9a945967734a6f7d35272" id="r_a24d56fbaf0c9a945967734a6f7d35272"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d56fbaf0c9a945967734a6f7d35272">BitMatrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a24d56fbaf0c9a945967734a6f7d35272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">m x n</span> bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:af17834d1275c5d4894412337e2fae78a" id="r_af17834d1275c5d4894412337e2fae78a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17834d1275c5d4894412337e2fae78a">BitMatrix</a> (std::vector&lt; row_type &gt; const &amp;<a class="el" href="#a28475ec720b56857bf838222f5bcff28">rows</a>)</td></tr>
<tr class="memdesc:af17834d1275c5d4894412337e2fae78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit-matrix by <em>copying</em> a given set of rows which can be any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> subclass.  <br /></td></tr>
<tr class="memitem:a20261a0691dbb5ba0c3ad02164506db6" id="r_a20261a0691dbb5ba0c3ad02164506db6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20261a0691dbb5ba0c3ad02164506db6">BitMatrix</a> (std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; &amp;&amp;<a class="el" href="#a28475ec720b56857bf838222f5bcff28">rows</a>)</td></tr>
<tr class="memdesc:a20261a0691dbb5ba0c3ad02164506db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit-matrix by <em>moving</em> the given rows.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Basic queries</div></td></tr>
<tr class="memitem:a28475ec720b56857bf838222f5bcff28" id="r_a28475ec720b56857bf838222f5bcff28"><td class="memItemLeft" align="right" valign="top"><a id="a28475ec720b56857bf838222f5bcff28" name="a28475ec720b56857bf838222f5bcff28"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const</td></tr>
<tr class="memdesc:a28475ec720b56857bf838222f5bcff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the bit-matrix. <br /></td></tr>
<tr class="memitem:a442cc69f62dc133313a62100f404a376" id="r_a442cc69f62dc133313a62100f404a376"><td class="memItemLeft" align="right" valign="top"><a id="a442cc69f62dc133313a62100f404a376" name="a442cc69f62dc133313a62100f404a376"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () const</td></tr>
<tr class="memdesc:a442cc69f62dc133313a62100f404a376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the bit-matrix. <br /></td></tr>
<tr class="memitem:a6d8b8913f95d36b33cfe2708199d7fa0" id="r_a6d8b8913f95d36b33cfe2708199d7fa0"><td class="memItemLeft" align="right" valign="top"><a id="a6d8b8913f95d36b33cfe2708199d7fa0" name="a6d8b8913f95d36b33cfe2708199d7fa0"></a>
constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a6d8b8913f95d36b33cfe2708199d7fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the totalnumber of elements in the bit-matrix. <br /></td></tr>
<tr class="memitem:a2105fc527b6d4f63757a92e67c1e892c" id="r_a2105fc527b6d4f63757a92e67c1e892c"><td class="memItemLeft" align="right" valign="top"><a id="a2105fc527b6d4f63757a92e67c1e892c" name="a2105fc527b6d4f63757a92e67c1e892c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const</td></tr>
<tr class="memdesc:a2105fc527b6d4f63757a92e67c1e892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an empty bit-matrix? <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Checks for Special Bit-Matrices</div></td></tr>
<tr class="memitem:a643db1e6f224de8b2d6f83cd6122258d" id="r_a643db1e6f224de8b2d6f83cd6122258d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a643db1e6f224de8b2d6f83cd6122258d">is_square</a> () const</td></tr>
<tr class="memdesc:a643db1e6f224de8b2d6f83cd6122258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this a square bit-matrix? Note that empty bit-matrices are NOT considered square.  <br /></td></tr>
<tr class="memitem:ae4bdba6def6fc1bbbfeba7ee3a350c1b" id="r_ae4bdba6def6fc1bbbfeba7ee3a350c1b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">is_zero</a> () const</td></tr>
<tr class="memdesc:ae4bdba6def6fc1bbbfeba7ee3a350c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this a square <em>zero</em> bit-matrix?  <br /></td></tr>
<tr class="memitem:ab22926c01bdf883d1132ef55a988e75c" id="r_ab22926c01bdf883d1132ef55a988e75c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab22926c01bdf883d1132ef55a988e75c">is_identity</a> () const</td></tr>
<tr class="memdesc:ab22926c01bdf883d1132ef55a988e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this is the identity bit-matrix.  <br /></td></tr>
<tr class="memitem:a0cb0145058cc1a40b353b66704a2b543" id="r_a0cb0145058cc1a40b353b66704a2b543"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb0145058cc1a40b353b66704a2b543">is_symmetric</a> () const</td></tr>
<tr class="memdesc:a0cb0145058cc1a40b353b66704a2b543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this is a symmetric square bit-matrix.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Bit Counts</div></td></tr>
<tr class="memitem:a3cd140ee3e9e76f01e88d0438fb3f44a" id="r_a3cd140ee3e9e76f01e88d0438fb3f44a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd140ee3e9e76f01e88d0438fb3f44a">count_ones</a> () const</td></tr>
<tr class="memdesc:a3cd140ee3e9e76f01e88d0438fb3f44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of one elements in the bit-matrix.  <br /></td></tr>
<tr class="memitem:a17389523643f1a3717c6d60eab8af459" id="r_a17389523643f1a3717c6d60eab8af459"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17389523643f1a3717c6d60eab8af459">count_zeros</a> () const</td></tr>
<tr class="memdesc:a17389523643f1a3717c6d60eab8af459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of zero elements in the bit-matrix.  <br /></td></tr>
<tr class="memitem:a7fd6d8e4a67c3ed9219202ec675c779a" id="r_a7fd6d8e4a67c3ed9219202ec675c779a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fd6d8e4a67c3ed9219202ec675c779a">count_ones_on_diagonal</a> () const</td></tr>
<tr class="memdesc:a7fd6d8e4a67c3ed9219202ec675c779a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ones on the main diagonal of the bit-matrix.  <br /></td></tr>
<tr class="memitem:ab6bbc74411849c034fb06bb15aa5f71e" id="r_ab6bbc74411849c034fb06bb15aa5f71e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6bbc74411849c034fb06bb15aa5f71e">trace</a> () const</td></tr>
<tr class="memdesc:ab6bbc74411849c034fb06bb15aa5f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "sum" of the main diagonal elements of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Overall State Queries</div></td></tr>
<tr class="memitem:a3ce2c5a81f79dfdb8d09d8d7ebabbaad" id="r_a3ce2c5a81f79dfdb8d09d8d7ebabbaad"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ce2c5a81f79dfdb8d09d8d7ebabbaad">any</a> () const</td></tr>
<tr class="memdesc:a3ce2c5a81f79dfdb8d09d8d7ebabbaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if any element of the bit-matrix is set.  <br /></td></tr>
<tr class="memitem:a7792c00bc7a230dbb6f9c09567f7891c" id="r_a7792c00bc7a230dbb6f9c09567f7891c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7792c00bc7a230dbb6f9c09567f7891c">all</a> () const</td></tr>
<tr class="memdesc:a7792c00bc7a230dbb6f9c09567f7891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all elements of the bit-matrix are set.  <br /></td></tr>
<tr class="memitem:a76bc5d329b6606e05bbbd2a0739d0bc6" id="r_a76bc5d329b6606e05bbbd2a0739d0bc6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bc5d329b6606e05bbbd2a0739d0bc6">none</a> () const</td></tr>
<tr class="memdesc:a76bc5d329b6606e05bbbd2a0739d0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if no elements of the bit-matrix are set.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Individual Element Access</div></td></tr>
<tr class="memitem:a26840ca85eed88714fe311efe9001e46" id="r_a26840ca85eed88714fe311efe9001e46"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26840ca85eed88714fe311efe9001e46">get</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:a26840ca85eed88714fe311efe9001e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the element at row <span class="tt">r</span> and column <span class="tt">c</span> is set.  <br /></td></tr>
<tr class="memitem:a1d722c95b308f15a837158e454a1156b" id="r_a1d722c95b308f15a837158e454a1156b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d722c95b308f15a837158e454a1156b">operator()</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:a1d722c95b308f15a837158e454a1156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt">bool</span>.  <br /></td></tr>
<tr class="memitem:a05b863d6516f94628e5f7240da2838ac" id="r_a05b863d6516f94628e5f7240da2838ac"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b863d6516f94628e5f7240da2838ac">set</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c, bool val=true)</td></tr>
<tr class="memdesc:a05b863d6516f94628e5f7240da2838ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at row <span class="tt">r</span> and column <span class="tt">c</span> to the bool value <span class="tt">val</span>. The default is to set the bit to <span class="tt">true</span>.  <br /></td></tr>
<tr class="memitem:a5b8d39968f36adf2681e317320029bb0" id="r_a5b8d39968f36adf2681e317320029bb0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgf2_1_1BitRef.html">BitRef</a>&lt; row_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b8d39968f36adf2681e317320029bb0">operator()</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:a5b8d39968f36adf2681e317320029bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference which can be used to set the bit.  <br /></td></tr>
<tr class="memitem:a63d96e34c6ba2b6790009ad3115dca70" id="r_a63d96e34c6ba2b6790009ad3115dca70"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d96e34c6ba2b6790009ad3115dca70">flip</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:a63d96e34c6ba2b6790009ad3115dca70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the bit at row <span class="tt">r</span> and column <span class="tt">c</span>.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Row Access</div></td></tr>
<tr class="memitem:a23a559c0e9856fe9e40775724df31f8b" id="r_a23a559c0e9856fe9e40775724df31f8b"><td class="memItemLeft" align="right" valign="top">constexpr const row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23a559c0e9856fe9e40775724df31f8b">row</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r) const</td></tr>
<tr class="memdesc:a23a559c0e9856fe9e40775724df31f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:a3a0923161bde9281d5c389031d917cab" id="r_a3a0923161bde9281d5c389031d917cab"><td class="memItemLeft" align="right" valign="top">constexpr row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a0923161bde9281d5c389031d917cab">row</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:a3a0923161bde9281d5c389031d917cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:ae3d875d0593c466b0c6d0820a059a2e5" id="r_ae3d875d0593c466b0c6d0820a059a2e5"><td class="memItemLeft" align="right" valign="top">constexpr const row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3d875d0593c466b0c6d0820a059a2e5">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r) const</td></tr>
<tr class="memdesc:ae3d875d0593c466b0c6d0820a059a2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr class="memitem:af7e6f932769049fd64ca781a0675749f" id="r_af7e6f932769049fd64ca781a0675749f"><td class="memItemLeft" align="right" valign="top">constexpr row_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e6f932769049fd64ca781a0675749f">operator[]</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:af7e6f932769049fd64ca781a0675749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the row at index <span class="tt">r</span>.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Column Access</div></td></tr>
<tr class="memitem:ae6bccbc7ad5685af7a92f5f4cd867459" id="r_ae6bccbc7ad5685af7a92f5f4cd867459"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c) const</td></tr>
<tr class="memdesc:ae6bccbc7ad5685af7a92f5f4cd867459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <b>clone</b> of the elements in column <span class="tt">c</span> from the bit-matrix as an independent bit-vector.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Whole Matrix Mutators</div></td></tr>
<tr class="memitem:a1fd6971c0602d83bcdb1ac1868e9ea95" id="r_a1fd6971c0602d83bcdb1ac1868e9ea95"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd6971c0602d83bcdb1ac1868e9ea95">set_all</a> (bool value=true)</td></tr>
<tr class="memdesc:a1fd6971c0602d83bcdb1ac1868e9ea95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the elements of the bit-matrix to the specified boolean <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:aaa83c905ee51c74be6a95c9328547f0b" id="r_aaa83c905ee51c74be6a95c9328547f0b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa83c905ee51c74be6a95c9328547f0b">flip_all</a> ()</td></tr>
<tr class="memdesc:aaa83c905ee51c74be6a95c9328547f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Diagonal Mutators</div></td></tr>
<tr class="memitem:abbf2d199c359040316b7ed497991e535" id="r_abbf2d199c359040316b7ed497991e535"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf2d199c359040316b7ed497991e535">set_diagonal</a> (bool val=true)</td></tr>
<tr class="memdesc:abbf2d199c359040316b7ed497991e535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the main diagonal of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a652216b04ee02a515588c76283bd8788" id="r_a652216b04ee02a515588c76283bd8788"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a652216b04ee02a515588c76283bd8788">flip_diagonal</a> ()</td></tr>
<tr class="memdesc:a652216b04ee02a515588c76283bd8788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the main diagonal of a square bit-matrix.  <br /></td></tr>
<tr class="memitem:ac996c7bad9217a51c32d246cb515d3bd" id="r_ac996c7bad9217a51c32d246cb515d3bd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac996c7bad9217a51c32d246cb515d3bd">set_super_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d, bool val=true)</td></tr>
<tr class="memdesc:ac996c7bad9217a51c32d246cb515d3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the elements on super-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a474bac1dd3227f980d8d130db801304a" id="r_a474bac1dd3227f980d8d130db801304a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474bac1dd3227f980d8d130db801304a">flip_super_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d)</td></tr>
<tr class="memdesc:a474bac1dd3227f980d8d130db801304a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the super-diagonal <span class="tt">d</span> of a square bit-matrix.  <br /></td></tr>
<tr class="memitem:a09043ce58925edf3de04b69b3909a39b" id="r_a09043ce58925edf3de04b69b3909a39b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09043ce58925edf3de04b69b3909a39b">set_sub_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d, bool val=true)</td></tr>
<tr class="memdesc:a09043ce58925edf3de04b69b3909a39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the elements on sub-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:ab47ecf702774bddeceb16f73be15366a" id="r_ab47ecf702774bddeceb16f73be15366a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab47ecf702774bddeceb16f73be15366a">flip_sub_diagonal</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> d)</td></tr>
<tr class="memdesc:ab47ecf702774bddeceb16f73be15366a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all the elements on the sub-diagonal <span class="tt">d</span> of a square bit-matrix.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Resizing</div></td></tr>
<tr class="memitem:a8eb76dca82ceaefd147bce32dacc8887" id="r_a8eb76dca82ceaefd147bce32dacc8887"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:a8eb76dca82ceaefd147bce32dacc8887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the bit-matrix to <span class="tt">r</span> rows and <span class="tt">c</span> columns.  <br /></td></tr>
<tr class="memitem:a13b6af5a75668a2684b27f6cba4df15b" id="r_a13b6af5a75668a2684b27f6cba4df15b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b6af5a75668a2684b27f6cba4df15b">clear</a> ()</td></tr>
<tr class="memdesc:a13b6af5a75668a2684b27f6cba4df15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the bit-matrix.  <br /></td></tr>
<tr class="memitem:a87f39f93fc76b11e9b9e84b514df5c18" id="r_a87f39f93fc76b11e9b9e84b514df5c18"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f39f93fc76b11e9b9e84b514df5c18">make_square</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a87f39f93fc76b11e9b9e84b514df5c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an arbitrary rectangular bit-matrix into a square <span class="tt"><a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a></span>.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Appending Rows and Columns</div></td></tr>
<tr class="memitem:aa5fc0e4faea5f7df54f9b69431650e94" id="r_aa5fc0e4faea5f7df54f9b69431650e94"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:aa5fc0e4faea5f7df54f9b69431650e94 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5fc0e4faea5f7df54f9b69431650e94">append_row</a> (Store const &amp;<a class="el" href="#a23a559c0e9856fe9e40775724df31f8b">row</a>)</td></tr>
<tr class="memdesc:aa5fc0e4faea5f7df54f9b69431650e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single row onto the end of the bit-matrix by copying it and returns a reference to the this for chaining.  <br /></td></tr>
<tr class="memitem:af6db102126a773bcc1fcd61a0a529b85" id="r_af6db102126a773bcc1fcd61a0a529b85"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:af6db102126a773bcc1fcd61a0a529b85 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6db102126a773bcc1fcd61a0a529b85">append_row</a> (Store &amp;&amp;<a class="el" href="#a23a559c0e9856fe9e40775724df31f8b">row</a>)</td></tr>
<tr class="memdesc:af6db102126a773bcc1fcd61a0a529b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single row onto the end of the bit-matrix by moving it and returns a reference to the this for chaining.  <br /></td></tr>
<tr class="memitem:a0d4fe2cd8131b280f9d631cc48627f50" id="r_a0d4fe2cd8131b280f9d631cc48627f50"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4fe2cd8131b280f9d631cc48627f50">append_rows</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:a0d4fe2cd8131b280f9d631cc48627f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by copying them and returns a reference to the this for chaining.  <br /></td></tr>
<tr class="memitem:ac7ee7e74a1ae2aab82a8986fdc8ab103" id="r_ac7ee7e74a1ae2aab82a8986fdc8ab103"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ee7e74a1ae2aab82a8986fdc8ab103">append_rows</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:ac7ee7e74a1ae2aab82a8986fdc8ab103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by moving them and returns a reference to the this for chaining.  <br /></td></tr>
<tr class="memitem:a6b827025748175fcc62740c47f3daffa" id="r_a6b827025748175fcc62740c47f3daffa"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:a6b827025748175fcc62740c47f3daffa template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b827025748175fcc62740c47f3daffa">append_col</a> (Store const &amp;<a class="el" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>)</td></tr>
<tr class="memdesc:a6b827025748175fcc62740c47f3daffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single column <span class="tt"><a class="el" href="#ae6bccbc7ad5685af7a92f5f4cd867459" title="Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.">col</a></span> onto the right of the bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|col</span> and returns a reference to the this for chaining.  <br /></td></tr>
<tr class="memitem:a482a2a5699a87124331471d52dd4af18" id="r_a482a2a5699a87124331471d52dd4af18"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a482a2a5699a87124331471d52dd4af18">append_cols</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:a482a2a5699a87124331471d52dd4af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all the columns from the <span class="tt">src</span> bit-matrix onto the right of this bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|src</span> and returns a reference to the this for chaining.  <br /></td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Removing Rows and Columns</div></td></tr>
<tr class="memitem:a2ceafc420345dfd11bf8cb4b2541ebdb" id="r_a2ceafc420345dfd11bf8cb4b2541ebdb"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceafc420345dfd11bf8cb4b2541ebdb">remove_row</a> ()</td></tr>
<tr class="memdesc:a2ceafc420345dfd11bf8cb4b2541ebdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a row off the end of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty.  <br /></td></tr>
<tr class="memitem:adb124132aa42cc9cd5a93f9739911702" id="r_adb124132aa42cc9cd5a93f9739911702"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb124132aa42cc9cd5a93f9739911702">remove_rows</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> k)</td></tr>
<tr class="memdesc:adb124132aa42cc9cd5a93f9739911702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <span class="tt">k</span> rows off the end of the bit-matrix and returns them as a new bit-matrix or <span class="tt">std::nullopt</span> if the bit-matrix has fewer than <span class="tt">k</span> rows.  <br /></td></tr>
<tr class="memitem:a3217cfe4444372ccd61e17b5735e1778" id="r_a3217cfe4444372ccd61e17b5735e1778"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3217cfe4444372ccd61e17b5735e1778">remove_col</a> ()</td></tr>
<tr class="memdesc:a3217cfe4444372ccd61e17b5735e1778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a column off the right of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty.  <br /></td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Sub-matrices</div></td></tr>
<tr class="memitem:a3189f2c2d533cf7095919e046cbec07b" id="r_a3189f2c2d533cf7095919e046cbec07b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3189f2c2d533cf7095919e046cbec07b">sub_matrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r_start, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r_end, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c_start, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c_end) const</td></tr>
<tr class="memdesc:a3189f2c2d533cf7095919e046cbec07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the sub-matrix delimited by the given row and column ranges.  <br /></td></tr>
<tr class="memitem:a77a793d34475a74063d5748fb91ffc65" id="r_a77a793d34475a74063d5748fb91ffc65"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a793d34475a74063d5748fb91ffc65">replace_sub_matrix</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> top, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> left, <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;src)</td></tr>
<tr class="memdesc:a77a793d34475a74063d5748fb91ffc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the sub-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span> with a copy of the sub-matrix <span class="tt">src</span>.  <br /></td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Triangular Sub-Matrices</div></td></tr>
<tr class="memitem:ae78b4ac4135e4b133e56ed5a11208fac" id="r_ae78b4ac4135e4b133e56ed5a11208fac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78b4ac4135e4b133e56ed5a11208fac">lower</a> () const</td></tr>
<tr class="memdesc:ae78b4ac4135e4b133e56ed5a11208fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a28ffed34d9f4b0cbbef78a7797298d8a" id="r_a28ffed34d9f4b0cbbef78a7797298d8a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ffed34d9f4b0cbbef78a7797298d8a">upper</a> () const</td></tr>
<tr class="memdesc:a28ffed34d9f4b0cbbef78a7797298d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the upper triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:ab6c25fb805a0ca7f1a43b629ae407425" id="r_ab6c25fb805a0ca7f1a43b629ae407425"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6c25fb805a0ca7f1a43b629ae407425">strictly_lower</a> () const</td></tr>
<tr class="memdesc:ab6c25fb805a0ca7f1a43b629ae407425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the strictly lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a6a6935a54eb964b26942876e01abd18d" id="r_a6a6935a54eb964b26942876e01abd18d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a6935a54eb964b26942876e01abd18d">strictly_upper</a> () const</td></tr>
<tr class="memdesc:a6a6935a54eb964b26942876e01abd18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the strictly upper triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a9b0cfb23fc27cc2a97edc613ef463e68" id="r_a9b0cfb23fc27cc2a97edc613ef463e68"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b0cfb23fc27cc2a97edc613ef463e68">unit_lower</a> () const</td></tr>
<tr class="memdesc:a9b0cfb23fc27cc2a97edc613ef463e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the unit lower triangular part of the bit-matrix.  <br /></td></tr>
<tr class="memitem:ad111547f2ab4c20cb8ec0588d04c34fd" id="r_ad111547f2ab4c20cb8ec0588d04c34fd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad111547f2ab4c20cb8ec0588d04c34fd">unit_upper</a> () const</td></tr>
<tr class="memdesc:ad111547f2ab4c20cb8ec0588d04c34fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an independent <em>clone</em> of the unit upper triangular part of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Elementary Row and Column Operations</div></td></tr>
<tr class="memitem:a143d9cbb3015422571eede697fe86c3d" id="r_a143d9cbb3015422571eede697fe86c3d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a143d9cbb3015422571eede697fe86c3d">swap_rows</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> j)</td></tr>
<tr class="memdesc:a143d9cbb3015422571eede697fe86c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps rows <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix.  <br /></td></tr>
<tr class="memitem:a03d22db34174e04d17ae575898373a2d" id="r_a03d22db34174e04d17ae575898373a2d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d22db34174e04d17ae575898373a2d">swap_cols</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> j)</td></tr>
<tr class="memdesc:a03d22db34174e04d17ae575898373a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps columns <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix.  <br /></td></tr>
<tr class="memitem:abe1da6156d267325f5ca10c1a3ed5aee" id="r_abe1da6156d267325f5ca10c1a3ed5aee"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe1da6156d267325f5ca10c1a3ed5aee">add_identity</a> ()</td></tr>
<tr class="memdesc:abe1da6156d267325f5ca10c1a3ed5aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the identity bit-matrix to the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Transposing</div></td></tr>
<tr class="memitem:a128d5e4f60bd3f15583507b9726d72fc" id="r_a128d5e4f60bd3f15583507b9726d72fc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128d5e4f60bd3f15583507b9726d72fc">transposed</a> () const</td></tr>
<tr class="memdesc:a128d5e4f60bd3f15583507b9726d72fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is the transpose of this one.  <br /></td></tr>
<tr class="memitem:ac6a84a334103aa833eb46ca7c16c4e90" id="r_ac6a84a334103aa833eb46ca7c16c4e90"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a84a334103aa833eb46ca7c16c4e90">transpose</a> ()</td></tr>
<tr class="memdesc:ac6a84a334103aa833eb46ca7c16c4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a <em>square</em> bit-matrix in place.  <br /></td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Exponentiation</div></td></tr>
<tr class="memitem:ab67c02641d3a769905e2fd056b6e3d63" id="r_ab67c02641d3a769905e2fd056b6e3d63"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67c02641d3a769905e2fd056b6e3d63">to_the</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, bool n_is_log2=false) const</td></tr>
<tr class="memdesc:ab67c02641d3a769905e2fd056b6e3d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is this one raised to some power <span class="tt">n</span> or <span class="tt">2^n</span>.  <br /></td></tr>
<tr id="pub-methods-18" class="groupHeader"><td colspan="2"><div class="groupHeader">Row-echelon forms</div></td></tr>
<tr class="memitem:aec7e8d35bd0964624e61907ccc2ce551" id="r_aec7e8d35bd0964624e61907ccc2ce551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7e8d35bd0964624e61907ccc2ce551">to_echelon_form</a> ()</td></tr>
<tr class="memdesc:aec7e8d35bd0964624e61907ccc2ce551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an arbitrary shaped, non-empty, bit-matrix to row-echelon form (in-place).  <br /></td></tr>
<tr class="memitem:a6e31859fe6991d1acab6fad23a585f63" id="r_a6e31859fe6991d1acab6fad23a585f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e31859fe6991d1acab6fad23a585f63">to_reduced_echelon_form</a> ()</td></tr>
<tr class="memdesc:a6e31859fe6991d1acab6fad23a585f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the bit-matrix to reduced row-echelon form (in-place).  <br /></td></tr>
<tr id="pub-methods-19" class="groupHeader"><td colspan="2"><div class="groupHeader">LU Decomposition</div></td></tr>
<tr class="memitem:a31496c74a8fb2a4a2407e558db90e29f" id="r_a31496c74a8fb2a4a2407e558db90e29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitLU.html">BitLU</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31496c74a8fb2a4a2407e558db90e29f">LU</a> () const</td></tr>
<tr class="memdesc:a31496c74a8fb2a4a2407e558db90e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LU decomposition of the bit-matrix.  <br /></td></tr>
<tr id="pub-methods-20" class="groupHeader"><td colspan="2"><div class="groupHeader">Solving systems of linear equations</div></td></tr>
<tr class="memitem:a558f19425492b27f2af65123af3900a1" id="r_a558f19425492b27f2af65123af3900a1"><td class="memTemplParams" colspan="2">template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a558f19425492b27f2af65123af3900a1 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a558f19425492b27f2af65123af3900a1">solver_for</a> (Rhs const &amp;b) const</td></tr>
<tr class="memdesc:a558f19425492b27f2af65123af3900a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gaussian elimination solver for this bit-matrix and the passed r.h.s. vector <span class="tt">b</span>.  <br /></td></tr>
<tr class="memitem:aae09e28a15626120d57844915487190f" id="r_aae09e28a15626120d57844915487190f"><td class="memTemplParams" colspan="2">template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:aae09e28a15626120d57844915487190f template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae09e28a15626120d57844915487190f">x_for</a> (Rhs const &amp;b) const</td></tr>
<tr class="memdesc:aae09e28a15626120d57844915487190f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a solution to the system of linear equations <span class="tt">A.x_ = b</span> or <span class="tt">std::nullopt</span> if there are none.  <br /></td></tr>
<tr id="pub-methods-21" class="groupHeader"><td colspan="2"><div class="groupHeader">Bitwise Operations</div></td></tr>
<tr class="memitem:adb66819f1c65988577c0a106653be663" id="r_adb66819f1c65988577c0a106653be663"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb66819f1c65988577c0a106653be663">operator^=</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:adb66819f1c65988577c0a106653be663"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">XOR</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:a1cef692a868cc889c2c920284a381b2f" id="r_a1cef692a868cc889c2c920284a381b2f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cef692a868cc889c2c920284a381b2f">operator&amp;=</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a1cef692a868cc889c2c920284a381b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">AND</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:afd1fbe0556d69c01f4ce0939cdeac05d" id="r_afd1fbe0556d69c01f4ce0939cdeac05d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1fbe0556d69c01f4ce0939cdeac05d">operator|=</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:afd1fbe0556d69c01f4ce0939cdeac05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place <span class="tt">OR</span> with a bit-matrix <span class="tt">rhs</span>.  <br /></td></tr>
<tr class="memitem:ab26ca6d2e1ff0ee5259648f316c7106d" id="r_ab26ca6d2e1ff0ee5259648f316c7106d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26ca6d2e1ff0ee5259648f316c7106d">operator^</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:ab26ca6d2e1ff0ee5259648f316c7106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">XOR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:ad1f5d6471aa5213dee5d6de9348158a8" id="r_ad1f5d6471aa5213dee5d6de9348158a8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f5d6471aa5213dee5d6de9348158a8">operator&amp;</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:ad1f5d6471aa5213dee5d6de9348158a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">AND</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:a0d4f4289546df12506a249df4d46857d" id="r_a0d4f4289546df12506a249df4d46857d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4f4289546df12506a249df4d46857d">operator|</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a0d4f4289546df12506a249df4d46857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The<span class="tt">OR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix.  <br /></td></tr>
<tr class="memitem:ae0207cf4915063a9d9364b0797ed51e6" id="r_ae0207cf4915063a9d9364b0797ed51e6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0207cf4915063a9d9364b0797ed51e6">operator~</a> ()</td></tr>
<tr class="memdesc:ae0207cf4915063a9d9364b0797ed51e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this bit-matrix with all the elements flipped.  <br /></td></tr>
<tr id="pub-methods-22" class="groupHeader"><td colspan="2"><div class="groupHeader">Arithmetic Operations</div></td></tr>
<tr class="memitem:ad2fc73c4836de2fed0288c392e868d33" id="r_ad2fc73c4836de2fed0288c392e868d33"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2fc73c4836de2fed0288c392e868d33">operator+=</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ad2fc73c4836de2fed0288c392e868d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) addition is the same as <span class="tt">XOR</span>.  <br /></td></tr>
<tr class="memitem:a6ae3a559abd1ca358281883e2e3af168" id="r_a6ae3a559abd1ca358281883e2e3af168"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae3a559abd1ca358281883e2e3af168">operator-=</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a6ae3a559abd1ca358281883e2e3af168"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place difference with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) subtraction is the same as <span class="tt">XOR</span>.  <br /></td></tr>
<tr class="memitem:a2fdaf27aa81697c0ed36bf4b9cbc0881" id="r_a2fdaf27aa81697c0ed36bf4b9cbc0881"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdaf27aa81697c0ed36bf4b9cbc0881">operator+</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a2fdaf27aa81697c0ed36bf4b9cbc0881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is <span class="tt">*this + rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2).  <br /></td></tr>
<tr class="memitem:a6cbf8e5d796b1cb895abb9acebd58bde" id="r_a6cbf8e5d796b1cb895abb9acebd58bde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cbf8e5d796b1cb895abb9acebd58bde">operator-</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:a6cbf8e5d796b1cb895abb9acebd58bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new bit-matrix that is <span class="tt">*this - rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2).  <br /></td></tr>
<tr id="pub-methods-23" class="groupHeader"><td colspan="2"><div class="groupHeader">String Representations</div></td></tr>
<tr class="memitem:a2266f12271b6353759a6b1941de6ccb4" id="r_a2266f12271b6353759a6b1941de6ccb4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a> (std::string_view row_sep=&quot;\n&quot;, std::string_view bit_sep=&quot;&quot;, std::string_view row_prefix=&quot;&quot;, std::string_view row_suffix=&quot;&quot;) const</td></tr>
<tr class="memdesc:a2266f12271b6353759a6b1941de6ccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a configurable binary string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:ad9f837326c007a7409f697c39fb7702d" id="r_ad9f837326c007a7409f697c39fb7702d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a> () const</td></tr>
<tr class="memdesc:ad9f837326c007a7409f697c39fb7702d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a one-line minimal binary string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:a34bff5d41dfac388664628d34ee09229" id="r_a34bff5d41dfac388664628d34ee09229"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34bff5d41dfac388664628d34ee09229">to_string</a> () const</td></tr>
<tr class="memdesc:a34bff5d41dfac388664628d34ee09229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:adab9ef71beec4e827595508ce4849d5d" id="r_adab9ef71beec4e827595508ce4849d5d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adab9ef71beec4e827595508ce4849d5d">to_pretty_string</a> () const</td></tr>
<tr class="memdesc:adab9ef71beec4e827595508ce4849d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default pretty string representation for this bit-matrix.  <br /></td></tr>
<tr class="memitem:a67c36a94bd9baa9fe134b41c966c4f8e" id="r_a67c36a94bd9baa9fe134b41c966c4f8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67c36a94bd9baa9fe134b41c966c4f8e">to_hex_string</a> (std::string_view row_sep=&quot;\n&quot;) const</td></tr>
<tr class="memdesc:a67c36a94bd9baa9fe134b41c966c4f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Returns the "hex" string representation of the bit-matrix  <br /></td></tr>
<tr class="memitem:a320c4578d71269d36c000cd1f5a897f2" id="r_a320c4578d71269d36c000cd1f5a897f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a320c4578d71269d36c000cd1f5a897f2">to_compact_hex_string</a> () const</td></tr>
<tr class="memdesc:a320c4578d71269d36c000cd1f5a897f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compact "hex" string representation of the bit-matrix.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Factory Constructors</div></td></tr>
<tr class="memitem:ac1d3def1adcb007ac348873c3580f276" id="r_ac1d3def1adcb007ac348873c3580f276"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1d3def1adcb007ac348873c3580f276">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ac1d3def1adcb007ac348873c3580f276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> zero bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:ac997646668549e4699fdd28a779f78e5" id="r_ac997646668549e4699fdd28a779f78e5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac997646668549e4699fdd28a779f78e5">zeros</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:ac997646668549e4699fdd28a779f78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 0.  <br /></td></tr>
<tr class="memitem:a95ec8df5690d34cb09e4446271b18f05" id="r_a95ec8df5690d34cb09e4446271b18f05"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ec8df5690d34cb09e4446271b18f05">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:a95ec8df5690d34cb09e4446271b18f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix with all the elements set to 1.  <br /></td></tr>
<tr class="memitem:aa3e90bb8c4b85662a1744b5ae275d7f5" id="r_aa3e90bb8c4b85662a1744b5ae275d7f5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3e90bb8c4b85662a1744b5ae275d7f5">ones</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:aa3e90bb8c4b85662a1744b5ae275d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 1.  <br /></td></tr>
<tr class="memitem:ae19b8bd9b773089f0e8d005ecccc8bb8" id="r_ae19b8bd9b773089f0e8d005ecccc8bb8"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19b8bd9b773089f0e8d005ecccc8bb8">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ae19b8bd9b773089f0e8d005ecccc8bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix with alternating elements.  <br /></td></tr>
<tr class="memitem:a48aafc3a8207e73556e54fa2cfdb6b13" id="r_a48aafc3a8207e73556e54fa2cfdb6b13"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48aafc3a8207e73556e54fa2cfdb6b13">alternating</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a48aafc3a8207e73556e54fa2cfdb6b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square bit-matrix with alternating elements.  <br /></td></tr>
<tr class="memitem:a82463948ff0b9fe876bf010d84b47aa7" id="r_a82463948ff0b9fe876bf010d84b47aa7"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:a82463948ff0b9fe876bf010d84b47aa7 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82463948ff0b9fe876bf010d84b47aa7">from_outer_product</a> (Lhs const &amp;u, Rhs const &amp;v)</td></tr>
<tr class="memdesc:a82463948ff0b9fe876bf010d84b47aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer product of the given bit-stores.  <br /></td></tr>
<tr class="memitem:abf565298a448092e5878fa02ab774a16" id="r_abf565298a448092e5878fa02ab774a16"><td class="memTemplParams" colspan="2">template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</td></tr>
<tr class="memitem:abf565298a448092e5878fa02ab774a16 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf565298a448092e5878fa02ab774a16">from_outer_sum</a> (Lhs const &amp;u, Rhs const &amp;v)</td></tr>
<tr class="memdesc:abf565298a448092e5878fa02ab774a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer sum of the given bit-stores.  <br /></td></tr>
<tr class="memitem:a8cd8c97d9645de2420efe9075deb06d6" id="r_a8cd8c97d9645de2420efe9075deb06d6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cd8c97d9645de2420efe9075deb06d6">from</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto f)</td></tr>
<tr class="memdesc:a8cd8c97d9645de2420efe9075deb06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct an \(m \times n\) bit-matrix by repeatedly calling <span class="tt">f(i, j)</span> for each index pair.  <br /></td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Randomly Populated Constructors</div></td></tr>
<tr class="memitem:a47a029b47df5b3641f6f06483b549ce6" id="r_a47a029b47df5b3641f6f06483b549ce6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47a029b47df5b3641f6f06483b549ce6">random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, double p=0.5, std::uint64_t seed=0)</td></tr>
<tr class="memdesc:a47a029b47df5b3641f6f06483b549ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are picked at random.  <br /></td></tr>
<tr class="memitem:ae64047186ba4f7f492488e6656b3a830" id="r_ae64047186ba4f7f492488e6656b3a830"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64047186ba4f7f492488e6656b3a830">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, std::uint64_t seed)</td></tr>
<tr class="memdesc:ae64047186ba4f7f492488e6656b3a830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:aad722ffb0e8ced1306fe9b7f6b23728f" id="r_aad722ffb0e8ced1306fe9b7f6b23728f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad722ffb0e8ced1306fe9b7f6b23728f">seeded_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, std::uint64_t seed)</td></tr>
<tr class="memdesc:aad722ffb0e8ced1306fe9b7f6b23728f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>.  <br /></td></tr>
<tr class="memitem:a1a6f5a1b96bdc7d9d4738d70cf32b49e" id="r_a1a6f5a1b96bdc7d9d4738d70cf32b49e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, double p)</td></tr>
<tr class="memdesc:a1a6f5a1b96bdc7d9d4738d70cf32b49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:acfa2e69664b85fe8ddd5e93d48cc7cc4" id="r_acfa2e69664b85fe8ddd5e93d48cc7cc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfa2e69664b85fe8ddd5e93d48cc7cc4">biased_random</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m, double p)</td></tr>
<tr class="memdesc:acfa2e69664b85fe8ddd5e93d48cc7cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>.  <br /></td></tr>
<tr id="pub-static-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors for Special Matrices</div></td></tr>
<tr class="memitem:a54ad547e9cbfad34e4eadee8ebc7b5f8" id="r_a54ad547e9cbfad34e4eadee8ebc7b5f8"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">zero</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:a54ad547e9cbfad34e4eadee8ebc7b5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> square "zero" bit-matrix.  <br /></td></tr>
<tr class="memitem:ab34ac8ed7a00be3f9f1548bb881e216e" id="r_ab34ac8ed7a00be3f9f1548bb881e216e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34ac8ed7a00be3f9f1548bb881e216e">identity</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> m)</td></tr>
<tr class="memdesc:ab34ac8ed7a00be3f9f1548bb881e216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create the <span class="tt">m x m</span> identity bit-matrix.  <br /></td></tr>
<tr class="memitem:aadfb60775af85b351d7f3de9bba17d24" id="r_aadfb60775af85b351d7f3de9bba17d24"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:aadfb60775af85b351d7f3de9bba17d24 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadfb60775af85b351d7f3de9bba17d24">companion</a> (Store const &amp;top_row)</td></tr>
<tr class="memdesc:aadfb60775af85b351d7f3de9bba17d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a square <em>companion <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a></em> with a copy of the given top row and a sub-diagonal of <span class="tt">1</span>s.  <br /></td></tr>
<tr class="memitem:ae8dbd5a56c0ea28ea96298a5007e4ff4" id="r_ae8dbd5a56c0ea28ea96298a5007e4ff4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8dbd5a56c0ea28ea96298a5007e4ff4">left_shift</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:ae8dbd5a56c0ea28ea96298a5007e4ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> shift-left by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>.  <br /></td></tr>
<tr class="memitem:a58d167b1673c17996bac2c74a03f4bc2" id="r_a58d167b1673c17996bac2c74a03f4bc2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d167b1673c17996bac2c74a03f4bc2">right_shift</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:a58d167b1673c17996bac2c74a03f4bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> shift-right by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>.  <br /></td></tr>
<tr class="memitem:a8b23de84fa10d85060a045c3c4058242" id="r_a8b23de84fa10d85060a045c3c4058242"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b23de84fa10d85060a045c3c4058242">left_rotation</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:a8b23de84fa10d85060a045c3c4058242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> rotate-left by <span class="tt">p</span> places matrix.  <br /></td></tr>
<tr class="memitem:a6fefecbb0bd5f81e499abeec66751e60" id="r_a6fefecbb0bd5f81e499abeec66751e60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fefecbb0bd5f81e499abeec66751e60">right_rotation</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> p)</td></tr>
<tr class="memdesc:a6fefecbb0bd5f81e499abeec66751e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <span class="tt">n x n</span> rotate-right by <span class="tt">p</span> places matrix.  <br /></td></tr>
<tr id="pub-static-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction by reshaping bit-stores.</div></td></tr>
<tr class="memitem:abd6578b7c373b477d1af169915e9c893" id="r_abd6578b7c373b477d1af169915e9c893"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:abd6578b7c373b477d1af169915e9c893 template"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6578b7c373b477d1af169915e9c893">from_row_store</a> (Store const &amp;v, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> r)</td></tr>
<tr class="memdesc:abd6578b7c373b477d1af169915e9c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to reshape a bit-vector <span class="tt">v</span> that is assumed to a sequence of <span class="tt">r</span> rows into a bit-matrix.  <br /></td></tr>
<tr class="memitem:aa15224a12a4c3d08fa80f8e1ab010f3f" id="r_aa15224a12a4c3d08fa80f8e1ab010f3f"><td class="memTemplParams" colspan="2">template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</td></tr>
<tr class="memitem:aa15224a12a4c3d08fa80f8e1ab010f3f template"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa15224a12a4c3d08fa80f8e1ab010f3f">from_col_store</a> (Store const &amp;v, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> c)</td></tr>
<tr class="memdesc:aa15224a12a4c3d08fa80f8e1ab010f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to reshape a bit-vector that is assumed to a sequence of <span class="tt">c</span> columns into a bit-matrix.  <br /></td></tr>
<tr id="pub-static-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction from strings</div></td></tr>
<tr class="memitem:a0b6cb72f20bd6a8b1377c0e5139ad482" id="r_a0b6cb72f20bd6a8b1377c0e5139ad482"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b6cb72f20bd6a8b1377c0e5139ad482">from_string</a> (std::string_view s)</td></tr>
<tr class="memdesc:a0b6cb72f20bd6a8b1377c0e5139ad482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Inversion</h2></td></tr>
<tr class="memitem:af6a3b548e9d1d91ebb501566dc72ebf0" id="r_af6a3b548e9d1d91ebb501566dc72ebf0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a3b548e9d1d91ebb501566dc72ebf0">inverse</a> () const</td></tr>
<tr class="memdesc:af6a3b548e9d1d91ebb501566dc72ebf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of a square bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular.  <br /></td></tr>
<tr class="memitem:ad037ef7306a35e234e545aa70b34ead1" id="r_ad037ef7306a35e234e545aa70b34ead1"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad037ef7306a35e234e545aa70b34ead1">probability_invertible</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ad037ef7306a35e234e545aa70b34ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is invertible if each element is chosen independently and uniformly at random by flips of a fair coin.  <br /></td></tr>
<tr class="memitem:ac3a45b35307c319db9f475ee9a4c6efd" id="r_ac3a45b35307c319db9f475ee9a4c6efd"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3a45b35307c319db9f475ee9a4c6efd">probability_singular</a> (<a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> n)</td></tr>
<tr class="memdesc:ac3a45b35307c319db9f475ee9a4c6efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is singular if each element is chosen independently and uniformly at random by flips of a fair coin.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Characteristic Polynomial</h2></td></tr>
<tr class="memitem:a6d9eddc365a7974d59f36e5d822419f4" id="r_a6d9eddc365a7974d59f36e5d822419f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9eddc365a7974d59f36e5d822419f4">characteristic_polynomial</a> () const</td></tr>
<tr class="memdesc:a6d9eddc365a7974d59f36e5d822419f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the characteristic polynomial of any square bit-matrix as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>.  <br /></td></tr>
<tr class="memitem:a93c0558987efc50fb3c5ab7d99882b25" id="r_a93c0558987efc50fb3c5ab7d99882b25"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93c0558987efc50fb3c5ab7d99882b25">frobenius_form</a> () const</td></tr>
<tr class="memdesc:a93c0558987efc50fb3c5ab7d99882b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>Frobenius form</em> of this bit-matrix in compact top-row only form.  <br /></td></tr>
<tr class="memitem:a88bf784a40aa4821ffe4fcbf4b3dd938" id="r_a88bf784a40aa4821ffe4fcbf4b3dd938"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bf784a40aa4821ffe4fcbf4b3dd938">frobenius_matrix_characteristic_polynomial</a> (std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; const &amp;top_rows)</td></tr>
<tr class="memdesc:a88bf784a40aa4821ffe4fcbf4b3dd938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method that returns the characteristic polynomial of a <em>Frobenius matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>.  <br /></td></tr>
<tr class="memitem:a12ed86c8502461391ab2c141748cbd18" id="r_a12ed86c8502461391ab2c141748cbd18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12ed86c8502461391ab2c141748cbd18">companion_matrix_characteristic_polynomial</a> (<a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; const &amp;top_row)</td></tr>
<tr class="memdesc:a12ed86c8502461391ab2c141748cbd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class method to return the characteristic polynomial of a <em>companion matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Comparison Operator</h2></td></tr>
<tr class="memitem:aa07d8f45bfb2a64685f2bee65a0792c3" id="r_aa07d8f45bfb2a64685f2bee65a0792c3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa07d8f45bfb2a64685f2bee65a0792c3">operator==</a> (<a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> const &amp;lhs, <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> const &amp;rhs)</td></tr>
<tr class="memdesc:aa07d8f45bfb2a64685f2bee65a0792c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator checks that any pair of bit-matrices are equal in content.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Unsigned Word = usize&gt;<br />
class gf2::BitMatrix&lt; Word &gt;</div><p>A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the matrix. The row elements are compactly stored in standard vectors of primitive unsigned words whose type is given by the template parameter <span class="tt">Word</span>. </p>
<h1 class="doxsection"><a class="anchor" id="note-11"></a>
Note</h1>
<p>Bit-matrices are stored by row, so it is always more efficient to arrange computations to operate on rows instead of columns. The high-level methods in this library take care of this for you. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5c368ef2b300f03a588f7461623d177" name="ae5c368ef2b300f03a588f7461623d177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c368ef2b300f03a588f7461623d177">&#9670;&#160;</a></span>BitMatrix() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::BitMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor creates an empty bit-matrix with no rows or columns. </p>
<h1 class="doxsection"><a class="anchor" id="example-94"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ad9f837326c007a7409f697c39fb7702d"><div class="ttname"><a href="#ad9f837326c007a7409f697c39fb7702d">gf2::BitMatrix::to_compact_binary_string</a></div><div class="ttdeci">std::string to_compact_binary_string() const</div><div class="ttdoc">Returns a one-line minimal binary string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2340</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae5c368ef2b300f03a588f7461623d177"><div class="ttname"><a href="#ae5c368ef2b300f03a588f7461623d177">gf2::BitMatrix::BitMatrix</a></div><div class="ttdeci">constexpr BitMatrix()</div><div class="ttdoc">The default constructor creates an empty bit-matrix with no rows or columns.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:55</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a22e7cc4d491400a387a1ab895effffed" name="a22e7cc4d491400a387a1ab895effffed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e7cc4d491400a387a1ab895effffed">&#9670;&#160;</a></span>BitMatrix() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::BitMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> square bit-matrix with all the elements set to 0. </p>
<p>If <span class="tt">n</span> is zero, we create an empty bit-matrix with no rows or columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-95"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m{3};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a24d56fbaf0c9a945967734a6f7d35272" name="a24d56fbaf0c9a945967734a6f7d35272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d56fbaf0c9a945967734a6f7d35272">&#9670;&#160;</a></span>BitMatrix() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::BitMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">m x n</span> bit-matrix with all the elements set to 0. </p>
<p>If either <span class="tt">m</span> or <span class="tt">n</span> is zero, we create an empty bit-matrix with no rows or columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-96"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m{3, 4};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a>(), <span class="stringliteral">&quot;0000 0000 0000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af17834d1275c5d4894412337e2fae78a" name="af17834d1275c5d4894412337e2fae78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17834d1275c5d4894412337e2fae78a">&#9670;&#160;</a></span>BitMatrix() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::BitMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; row_type &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit-matrix by <em>copying</em> a given set of rows which can be any <span class="tt"><a class="el" href="conceptgf2_1_1BitStore.html" title="A concept that is satisfied by all bit-vector-like types, which we refer to as bit-stores.">BitStore</a></span> subclass. </p>
<h1 class="doxsection"><a class="anchor" id="panics-26"></a>
Panics</h1>
<p>We check that all the rows have the same size unless <span class="tt">NDEBUG</span> is defined.</p>
<h1 class="doxsection"><a class="anchor" id="example-97"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a> = std::vector{<a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(3), <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3)};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitMatrix.html">BitMatrix</a> m{<a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a>};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html"><div class="ttname"><a href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a></div><div class="ttdoc">A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...</div><div class="ttdef"><b>Definition</b> BitMatrix.h:33</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a28475ec720b56857bf838222f5bcff28"><div class="ttname"><a href="#a28475ec720b56857bf838222f5bcff28">gf2::BitMatrix::rows</a></div><div class="ttdeci">constexpr usize rows() const</div><div class="ttdoc">Returns the number of rows in the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:629</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a66ff1e24db7bf631af2d638dd0b620c1"><div class="ttname"><a href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">gf2::BitVector::zeros</a></div><div class="ttdeci">static constexpr BitVector zeros(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 0.</div><div class="ttdef"><b>Definition</b> BitVector.h:196</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_abcfb7a88f30c8faa177519571a76ba8d"><div class="ttname"><a href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">gf2::BitVector::ones</a></div><div class="ttdeci">static constexpr BitVector ones(usize n)</div><div class="ttdoc">Factory method to generate a bit-vector of length n where the elements are all 1.</div><div class="ttdef"><b>Definition</b> BitVector.h:204</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a20261a0691dbb5ba0c3ad02164506db6" name="a20261a0691dbb5ba0c3ad02164506db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20261a0691dbb5ba0c3ad02164506db6">&#9670;&#160;</a></span>BitMatrix() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::BitMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit-matrix by <em>moving</em> the given rows. </p>
<p>Use <span class="tt">std::move(rows)</span> in the constructor argument to get this version. The input rows are moved into the bit-matrix so they are no longer valid after this constructor.</p>
<h1 class="doxsection"><a class="anchor" id="panics-27"></a>
Panics</h1>
<p>We check that all the rows have the same size unless <span class="tt">NDEBUG</span> is defined.</p>
<h1 class="doxsection"><a class="anchor" id="example-98"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a> = std::vector{<a class="code hl_function" href="classgf2_1_1BitVector.html#a66ff1e24db7bf631af2d638dd0b620c1">BitVector&lt;&gt;::zeros</a>(3), <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3)};</div>
<div class="line"><a class="code hl_class" href="classgf2_1_1BitMatrix.html">BitMatrix</a> m{std::move(<a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a>)};</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ad9f837326c007a7409f697c39fb7702d">to_compact_binary_string</a>(), <span class="stringliteral">&quot;000 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="abe1da6156d267325f5ca10c1a3ed5aee" name="abe1da6156d267325f5ca10c1a3ed5aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1da6156d267325f5ca10c1a3ed5aee">&#9670;&#160;</a></span>add_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::add_identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the identity bit-matrix to the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-56"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-174"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.add_identity();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a54ad547e9cbfad34e4eadee8ebc7b5f8"><div class="ttname"><a href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">gf2::BitMatrix::zero</a></div><div class="ttdeci">static constexpr BitMatrix zero(usize m)</div><div class="ttdoc">Factory method to create the m x m square &quot;zero&quot; bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:374</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7792c00bc7a230dbb6f9c09567f7891c" name="a7792c00bc7a230dbb6f9c09567f7891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7792c00bc7a230dbb6f9c09567f7891c">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all elements of the bit-matrix are set. </p>
<p>Empty matrices are considered to have all bits set.</p>
<h1 class="doxsection"><a class="anchor" id="example-132"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.all(), <span class="keyword">false</span>);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.all(), <span class="keyword">true</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.all(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a48aafc3a8207e73556e54fa2cfdb6b13" name="a48aafc3a8207e73556e54fa2cfdb6b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48aafc3a8207e73556e54fa2cfdb6b13">&#9670;&#160;</a></span>alternating() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with alternating elements. </p>
<h1 class="doxsection"><a class="anchor" id="example-104"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ae19b8bd9b773089f0e8d005ecccc8bb8">BitMatrix&lt;&gt;::alternating</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;101 010 101&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae19b8bd9b773089f0e8d005ecccc8bb8"><div class="ttname"><a href="#ae19b8bd9b773089f0e8d005ecccc8bb8">gf2::BitMatrix::alternating</a></div><div class="ttdeci">static constexpr BitMatrix alternating(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n bit-matrix with alternating elements.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:166</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae19b8bd9b773089f0e8d005ecccc8bb8" name="ae19b8bd9b773089f0e8d005ecccc8bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19b8bd9b773089f0e8d005ecccc8bb8">&#9670;&#160;</a></span>alternating() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::alternating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix with alternating elements. </p>
<h1 class="doxsection"><a class="anchor" id="example-103"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ae19b8bd9b773089f0e8d005ecccc8bb8">BitMatrix&lt;&gt;::alternating</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;1010 0101 1010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ce2c5a81f79dfdb8d09d8d7ebabbaad" name="a3ce2c5a81f79dfdb8d09d8d7ebabbaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce2c5a81f79dfdb8d09d8d7ebabbaad">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if any element of the bit-matrix is set. </p>
<p>Empty matrices are considered to have no set bits.</p>
<h1 class="doxsection"><a class="anchor" id="example-131"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.any(), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.any(), <span class="keyword">true</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.any(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6b827025748175fcc62740c47f3daffa" name="a6b827025748175fcc62740c47f3daffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b827025748175fcc62740c47f3daffa">&#9670;&#160;</a></span>append_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_col </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>col</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single column <span class="tt"><a class="el" href="#ae6bccbc7ad5685af7a92f5f4cd867459" title="Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.">col</a></span> onto the right of the bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|col</span> and returns a reference to the this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-50"></a>
Panics</h1>
<p>The column must have the same number of elements as the bit-matrix has rows.</p>
<h1 class="doxsection"><a class="anchor" id="example-159"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a> = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3);</div>
<div class="line">m.append_col(<a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;0001 0001 0001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae6bccbc7ad5685af7a92f5f4cd867459"><div class="ttname"><a href="#ae6bccbc7ad5685af7a92f5f4cd867459">gf2::BitMatrix::col</a></div><div class="ttdeci">constexpr BitVector&lt; Word &gt; col(usize c) const</div><div class="ttdoc">Returns a clone of the elements in column c from the bit-matrix as an independent bit-vector.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:1018</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a482a2a5699a87124331471d52dd4af18" name="a482a2a5699a87124331471d52dd4af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482a2a5699a87124331471d52dd4af18">&#9670;&#160;</a></span>append_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the columns from the <span class="tt">src</span> bit-matrix onto the right of this bit-matrix so <span class="tt">M</span> -&gt; <span class="tt">M|src</span> and returns a reference to the this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-51"></a>
Panics</h1>
<p>The source bit-matrix must have the same number of rows as this bit-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="example-160"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> src = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 2);</div>
<div class="line">m.append_cols(src);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00011 00011 00011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a95ec8df5690d34cb09e4446271b18f05"><div class="ttname"><a href="#a95ec8df5690d34cb09e4446271b18f05">gf2::BitMatrix::ones</a></div><div class="ttdeci">static constexpr BitMatrix ones(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n bit-matrix with all the elements set to 1.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:145</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6db102126a773bcc1fcd61a0a529b85" name="af6db102126a773bcc1fcd61a0a529b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6db102126a773bcc1fcd61a0a529b85">&#9670;&#160;</a></span>append_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_row </td>
          <td>(</td>
          <td class="paramtype">Store &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single row onto the end of the bit-matrix by moving it and returns a reference to the this for chaining. </p>
<p>Use <span class="tt">std::move(row)</span> in the method argument to guarantee this version. The input row is moved into the matrix and is no longer valid after this call.</p>
<h1 class="doxsection"><a class="anchor" id="panics-47"></a>
Panics</h1>
<p>The row must have the same number of elements as the bit-matrix has columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-156"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.append_row(<a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa5fc0e4faea5f7df54f9b69431650e94" name="aa5fc0e4faea5f7df54f9b69431650e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fc0e4faea5f7df54f9b69431650e94">&#9670;&#160;</a></span>append_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_row </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a single row onto the end of the bit-matrix by copying it and returns a reference to the this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-46"></a>
Panics</h1>
<p>The row must have the same number of elements as the bit-matrix has columns.</p>
<h1 class="doxsection"><a class="anchor" id="example-155"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a23a559c0e9856fe9e40775724df31f8b">row</a> = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3);</div>
<div class="line">m.append_row(<a class="code hl_function" href="#a23a559c0e9856fe9e40775724df31f8b">row</a>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a23a559c0e9856fe9e40775724df31f8b"><div class="ttname"><a href="#a23a559c0e9856fe9e40775724df31f8b">gf2::BitMatrix::row</a></div><div class="ttdeci">constexpr const row_type &amp; row(usize r) const</div><div class="ttdoc">Returns a read-only reference to the row at index r.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:939</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac7ee7e74a1ae2aab82a8986fdc8ab103" name="ac7ee7e74a1ae2aab82a8986fdc8ab103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ee7e74a1ae2aab82a8986fdc8ab103">&#9670;&#160;</a></span>append_rows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by moving them and returns a reference to the this for chaining. </p>
<p>Use <span class="tt">std::move(src)</span> in the method argument to guarantee this version. The source bit-matrix is moved into this matrix and is no longer valid after this call.</p>
<h1 class="doxsection"><a class="anchor" id="panics-49"></a>
Panics</h1>
<p>The source bit-matrix must have the same number of columns as this bit-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="example-158"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.append_rows(<a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0d4fe2cd8131b280f9d631cc48627f50" name="a0d4fe2cd8131b280f9d631cc48627f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4fe2cd8131b280f9d631cc48627f50">&#9670;&#160;</a></span>append_rows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::append_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all the rows from the <span class="tt">src</span> bit-matrix onto the end of this bit-matrix by copying them and returns a reference to the this for chaining. </p>
<h1 class="doxsection"><a class="anchor" id="panics-48"></a>
Panics</h1>
<p>The source bit-matrix must have the same number of columns as this bit-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="example-157"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line"><span class="keyword">auto</span> src = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line">m.append_rows(src);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000 111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acfa2e69664b85fe8ddd5e93d48cc7cc4" name="acfa2e69664b85fe8ddd5e93d48cc7cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa2e69664b85fe8ddd5e93d48cc7cc4">&#9670;&#160;</a></span>biased_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-112"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">BitMatrix&lt;&gt;::biased_random</a>(10, 0.3);</div>
<div class="line">assert_eq(u.size(), 100);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a1a6f5a1b96bdc7d9d4738d70cf32b49e"><div class="ttname"><a href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">gf2::BitMatrix::biased_random</a></div><div class="ttdeci">static BitMatrix biased_random(usize m, usize n, double p)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are from independent fair co...</div><div class="ttdef"><b>Definition</b> BitMatrix.h:348</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1a6f5a1b96bdc7d9d4738d70cf32b49e" name="a1a6f5a1b96bdc7d9d4738d70cf32b49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">&#9670;&#160;</a></span>biased_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::biased_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips and where each bit is 1 with probability <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-111"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">BitMatrix&lt;&gt;::biased_random</a>(10, 7, 0.3);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a1a6f5a1b96bdc7d9d4738d70cf32b49e">BitMatrix&lt;&gt;::biased_random</a>(10, 7, 0.3);</div>
<div class="line">assert_eq(u.size(), v.size());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6d9eddc365a7974d59f36e5d822419f4" name="a6d9eddc365a7974d59f36e5d822419f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9eddc365a7974d59f36e5d822419f4">&#9670;&#160;</a></span>characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::characteristic_polynomial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the characteristic polynomial of any square bit-matrix as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>. </p>
<p>The method uses similarity transformations to convert the bit-matrix to <em>Frobenius form</em> which has a readily computable characteristic polynomial. Similarity transformations preserve eigen-structure, and in particular they preserve the characteristic polynomial.</p>
<h1 class="doxsection"><a class="anchor" id="panics-63"></a>
Panics</h1>
<p>This method panics if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-186"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(2);</div>
<div class="line">assert_eq(m2.characteristic_polynomial().to_string(), <span class="stringliteral">&quot;1 + x^2&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m3.characteristic_polynomial().to_string(), <span class="stringliteral">&quot;1 + x + x^2 + x^3&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m100 = <a class="code hl_function" href="#a47a029b47df5b3641f6f06483b549ce6">BitMatrix&lt;&gt;::random</a>(100, 100);</div>
<div class="line"><span class="keyword">auto</span> p = m100.characteristic_polynomial();</div>
<div class="line">assert_eq(p(m100).<a class="code hl_function" href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">is_zero</a>(), <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a47a029b47df5b3641f6f06483b549ce6"><div class="ttname"><a href="#a47a029b47df5b3641f6f06483b549ce6">gf2::BitMatrix::random</a></div><div class="ttdeci">static BitMatrix random(usize m, usize n, double p=0.5, std::uint64_t seed=0)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are picked at random.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:264</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ab34ac8ed7a00be3f9f1548bb881e216e"><div class="ttname"><a href="#ab34ac8ed7a00be3f9f1548bb881e216e">gf2::BitMatrix::identity</a></div><div class="ttdeci">static constexpr BitMatrix identity(usize m)</div><div class="ttdoc">Factory method to create the m x m identity bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:383</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae4bdba6def6fc1bbbfeba7ee3a350c1b"><div class="ttname"><a href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">gf2::BitMatrix::is_zero</a></div><div class="ttdeci">constexpr bool is_zero() const</div><div class="ttdoc">Returns true if this a square zero bit-matrix?</div><div class="ttdef"><b>Definition</b> BitMatrix.h:668</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a13b6af5a75668a2684b27f6cba4df15b" name="a13b6af5a75668a2684b27f6cba4df15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b6af5a75668a2684b27f6cba4df15b">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the elements from the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-153"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.rows(), 0);</div>
<div class="line">assert_eq(m.cols(), 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae6bccbc7ad5685af7a92f5f4cd867459" name="ae6bccbc7ad5685af7a92f5f4cd867459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bccbc7ad5685af7a92f5f4cd867459">&#9670;&#160;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <b>clone</b> of the elements in column <span class="tt">c</span> from the bit-matrix as an independent bit-vector. </p>
<p>Matrices are stored by rows and there is no cheap reference style access to the <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a> columns!</p>
<h1 class="doxsection"><a class="anchor" id="panics-39"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-143"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a> = m.col(1);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>.to_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>.set(0);</div>
<div class="line"><a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>.set(2);</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aadfb60775af85b351d7f3de9bba17d24" name="aadfb60775af85b351d7f3de9bba17d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfb60775af85b351d7f3de9bba17d24">&#9670;&#160;</a></span>companion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::companion </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a square <em>companion <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a></em> with a copy of the given top row and a sub-diagonal of <span class="tt">1</span>s. </p>
<p>The top row should be passed as a bit-store and is copied to the first row of the <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>. The rest of the <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a> is initialized to zero and the sub-diagonal is set to <span class="tt">1</span>s.</p>
<h1 class="doxsection"><a class="anchor" id="example-115"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> top_row = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(5);</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#aadfb60775af85b351d7f3de9bba17d24">BitMatrix&lt;&gt;::companion</a>(top_row);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11111 10000 01000 00100 00010&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_aadfb60775af85b351d7f3de9bba17d24"><div class="ttname"><a href="#aadfb60775af85b351d7f3de9bba17d24">gf2::BitMatrix::companion</a></div><div class="ttdeci">static constexpr BitMatrix companion(Store const &amp;top_row)</div><div class="ttdoc">Constructs a square companion BitMatrix with a copy of the given top row and a sub-diagonal of 1s.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:402</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a12ed86c8502461391ab2c141748cbd18" name="a12ed86c8502461391ab2c141748cbd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ed86c8502461391ab2c141748cbd18">&#9670;&#160;</a></span>companion_matrix_characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::companion_matrix_characteristic_polynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_row</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method to return the characteristic polynomial of a <em>companion matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>. </p>
<p>The function expects to be passed the top row of the companion matrix as a bit-vector.</p>
<p>A companion matrix is a square matrix that is all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>The characteristic polynomial of a companion matrix can be computed from its top row.</p>
<h1 class="doxsection"><a class="anchor" id="example-187"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> top_row = <a class="code hl_function" href="classgf2_1_1BitVector.html#a193a2ffb36fa664bbdbfe057f4f491d2">BitVector&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a12ed86c8502461391ab2c141748cbd18">BitMatrix&lt;&gt;::companion_matrix_characteristic_polynomial</a>(top_row).<a class="code hl_function" href="#a34bff5d41dfac388664628d34ee09229">to_string</a>(), <span class="stringliteral">&quot;1 + x^2 + x^3&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a12ed86c8502461391ab2c141748cbd18"><div class="ttname"><a href="#a12ed86c8502461391ab2c141748cbd18">gf2::BitMatrix::companion_matrix_characteristic_polynomial</a></div><div class="ttdeci">static BitPolynomial&lt; Word &gt; companion_matrix_characteristic_polynomial(BitVector&lt; Word &gt; const &amp;top_row)</div><div class="ttdoc">Class method to return the characteristic polynomial of a companion matrix as a gf2::BitPolynomial.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2040</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a34bff5d41dfac388664628d34ee09229"><div class="ttname"><a href="#a34bff5d41dfac388664628d34ee09229">gf2::BitMatrix::to_string</a></div><div class="ttdeci">std::string to_string() const</div><div class="ttdoc">Returns the default string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2351</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a193a2ffb36fa664bbdbfe057f4f491d2"><div class="ttname"><a href="classgf2_1_1BitVector.html#a193a2ffb36fa664bbdbfe057f4f491d2">gf2::BitVector::from_binary_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_binary_string(std::string_view sv, bool no_punctuation=false)</div><div class="ttdoc">Factory method to construct a bit-vector from a binary string, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:473</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3cd140ee3e9e76f01e88d0438fb3f44a" name="a3cd140ee3e9e76f01e88d0438fb3f44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd140ee3e9e76f01e88d0438fb3f44a">&#9670;&#160;</a></span>count_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::count_ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of one elements in the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-127"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.count_ones(), 0);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.count_ones(), 9);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7fd6d8e4a67c3ed9219202ec675c779a" name="a7fd6d8e4a67c3ed9219202ec675c779a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd6d8e4a67c3ed9219202ec675c779a">&#9670;&#160;</a></span>count_ones_on_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::count_ones_on_diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ones on the main diagonal of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-28"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-129"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.count_ones_on_diagonal(), 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17389523643f1a3717c6d60eab8af459" name="a17389523643f1a3717c6d60eab8af459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17389523643f1a3717c6d60eab8af459">&#9670;&#160;</a></span>count_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::count_zeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of zero elements in the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-128"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.count_zeros(), 6);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a63d96e34c6ba2b6790009ad3115dca70" name="a63d96e34c6ba2b6790009ad3115dca70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d96e34c6ba2b6790009ad3115dca70">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips the bit at row <span class="tt">r</span> and column <span class="tt">c</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-34"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-138"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaa83c905ee51c74be6a95c9328547f0b" name="aaa83c905ee51c74be6a95c9328547f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa83c905ee51c74be6a95c9328547f0b">&#9670;&#160;</a></span>flip_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::flip_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-145"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a652216b04ee02a515588c76283bd8788" name="a652216b04ee02a515588c76283bd8788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652216b04ee02a515588c76283bd8788">&#9670;&#160;</a></span>flip_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::flip_diagonal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the main diagonal of a square bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-41"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-147"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.flip_diagonal();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab47ecf702774bddeceb16f73be15366a" name="ab47ecf702774bddeceb16f73be15366a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47ecf702774bddeceb16f73be15366a">&#9670;&#160;</a></span>flip_sub_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::flip_sub_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the sub-diagonal <span class="tt">d</span> of a square bit-matrix. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first sub-diagonal etc.</p>
<h1 class="doxsection"><a class="anchor" id="panics-45"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-151"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m.flip_sub_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00000 10000 01000 00100 00010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a474bac1dd3227f980d8d130db801304a" name="a474bac1dd3227f980d8d130db801304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474bac1dd3227f980d8d130db801304a">&#9670;&#160;</a></span>flip_super_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::flip_super_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all the elements on the super-diagonal <span class="tt">d</span> of a square bit-matrix. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first super-diagonal etc.</p>
<h1 class="doxsection"><a class="anchor" id="panics-43"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-149"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m.flip_super_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;01000 00100 00010 00001 00000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a93c0558987efc50fb3c5ab7d99882b25" name="a93c0558987efc50fb3c5ab7d99882b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0558987efc50fb3c5ab7d99882b25">&#9670;&#160;</a></span>frobenius_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::frobenius_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>Frobenius form</em> of this bit-matrix in compact top-row only form. </p>
<p>A Frobenius matrix is a square matrix that consists of one or more blocks of <em>companion matrices</em> along the diagonal. The companion matrices are square matrices that are all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>We can convert any bit-matrix to Frobenius form via a sequence of similarity transformations that preserve the eigen-structure of the original matrix.</p>
<p>We return the Frobenius companion matrices in a compact form as a <span class="tt">Vec</span> of their top rows as bit-vectors.</p>
<h1 class="doxsection"><a class="anchor" id="panics-64"></a>
Panics</h1>
<p>This method panics if the bit-matrix is not square. </p>

</div>
</div>
<a id="a88bf784a40aa4821ffe4fcbf4b3dd938" name="a88bf784a40aa4821ffe4fcbf4b3dd938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bf784a40aa4821ffe4fcbf4b3dd938">&#9670;&#160;</a></span>frobenius_matrix_characteristic_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitPolynomial.html">BitPolynomial</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::frobenius_matrix_characteristic_polynomial </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>top_rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the characteristic polynomial of a <em>Frobenius matrix</em> as a <span class="tt"><a class="el" href="classgf2_1_1BitPolynomial.html" title="A BitPolynomial represents a polynomial over GF(2) where we store the polynomial coefficients in a bi...">gf2::BitPolynomial</a></span>. </p>
<p>A Frobenius matrix is a square matrix that consists of blocks of <em>companion matrices</em> along the diagonal. Each companion matrix is a square matrix that is all zeros except for an arbitrary top row and a principal sub-diagonal of all ones. Companion matrices can be compactly represented by their top rows only.</p>
<p>This associated function expects to be passed the top rows of the companion matrices as an array of bit-vectors. The characteristic polynomial of a Frobenius matrix is the product of the characteristic polynomials of its block companion matrices which are readily computed. </p>

</div>
</div>
<a id="a8cd8c97d9645de2420efe9075deb06d6" name="a8cd8c97d9645de2420efe9075deb06d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd8c97d9645de2420efe9075deb06d6">&#9670;&#160;</a></span>from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>, <a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> &gt; auto</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct an \(m \times n\) bit-matrix by repeatedly calling <span class="tt">f(i, j)</span> for each index pair. </p>
<h1 class="doxsection"><a class="anchor" id="example-107"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a8cd8c97d9645de2420efe9075deb06d6">BitMatrix&lt;&gt;::from</a>(3, 2, [](<a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a> i, <a class="code hl_typedef" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a>) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 00 11&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a8cd8c97d9645de2420efe9075deb06d6"><div class="ttname"><a href="#a8cd8c97d9645de2420efe9075deb06d6">gf2::BitMatrix::from</a></div><div class="ttdeci">static constexpr BitMatrix from(usize m, usize n, std::invocable&lt; usize, usize &gt; auto f)</div><div class="ttdoc">Factory method to construct an  bit-matrix by repeatedly calling f(i, j) for each index pair.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:229</div></div>
<div class="ttc" id="anamespacegf2_html_abed1a83530f112d069e809d8883c13a8"><div class="ttname"><a href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">gf2::usize</a></div><div class="ttdeci">std::size_t usize</div><div class="ttdoc">Word type alias for the platform&#39;s &quot;native&quot;-sized unsigned integer.</div><div class="ttdef"><b>Definition</b> Unsigned.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa15224a12a4c3d08fa80f8e1ab010f3f" name="aa15224a12a4c3d08fa80f8e1ab010f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15224a12a4c3d08fa80f8e1ab010f3f">&#9670;&#160;</a></span>from_col_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from_col_store </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to reshape a bit-vector that is assumed to a sequence of <span class="tt">c</span> columns into a bit-matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The bit-vector to reshape. </td></tr>
    <tr><td class="paramname">c</td><td>The number of columns.</td></tr>
  </table>
  </dd>
</dl>
<h1 class="doxsection"><a class="anchor" id="example-121"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(15);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#aa15224a12a4c3d08fa80f8e1ab010f3f">BitMatrix&lt;&gt;::from_col_store</a>(v, 3).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#aa15224a12a4c3d08fa80f8e1ab010f3f">BitMatrix&lt;&gt;::from_col_store</a>(v, 5).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;11111 11111 11111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#aa15224a12a4c3d08fa80f8e1ab010f3f">BitMatrix&lt;&gt;::from_col_store</a>(v, 15).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;111111111111111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_aa15224a12a4c3d08fa80f8e1ab010f3f"><div class="ttname"><a href="#aa15224a12a4c3d08fa80f8e1ab010f3f">gf2::BitMatrix::from_col_store</a></div><div class="ttdeci">static std::optional&lt; BitMatrix &gt; from_col_store(Store const &amp;v, usize c)</div><div class="ttdoc">Factory method to reshape a bit-vector that is assumed to a sequence of c columns into a bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:536</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a82463948ff0b9fe876bf010d84b47aa7" name="a82463948ff0b9fe876bf010d84b47aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82463948ff0b9fe876bf010d84b47aa7">&#9670;&#160;</a></span>from_outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from_outer_product </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer product of the given bit-stores. </p>
<h1 class="doxsection"><a class="anchor" id="example-105"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;110&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a82463948ff0b9fe876bf010d84b47aa7">BitMatrix&lt;&gt;::from_outer_product</a>(u, v);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;110 000 110&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a82463948ff0b9fe876bf010d84b47aa7"><div class="ttname"><a href="#a82463948ff0b9fe876bf010d84b47aa7">gf2::BitMatrix::from_outer_product</a></div><div class="ttdeci">static constexpr BitMatrix from_outer_product(Lhs const &amp;u, Rhs const &amp;v)</div><div class="ttdoc">Factory method to create the m x n bit-matrix from the outer product of the given bit-stores.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:193</div></div>
<div class="ttc" id="aclassgf2_1_1BitVector_html_a17ba4f50de43f5e84ef3943ad77410ea"><div class="ttname"><a href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">gf2::BitVector::from_string</a></div><div class="ttdeci">static std::optional&lt; BitVector &gt; from_string(std::string_view sv)</div><div class="ttdoc">Factory method to construct a bit-vector from a string s, returning std::nullopt on failure.</div><div class="ttdef"><b>Definition</b> BitVector.h:436</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abf565298a448092e5878fa02ab774a16" name="abf565298a448092e5878fa02ab774a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf565298a448092e5878fa02ab774a16">&#9670;&#160;</a></span>from_outer_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Lhs, BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Lhs::word_type, Word&gt; &amp;&amp; std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from_outer_sum </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix from the outer sum of the given bit-stores. </p>
<h1 class="doxsection"><a class="anchor" id="example-106"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;101&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a17ba4f50de43f5e84ef3943ad77410ea">BitVector&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;110&quot;</span>).value();</div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#abf565298a448092e5878fa02ab774a16">BitMatrix&lt;&gt;::from_outer_sum</a>(u, v);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;001 110 001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_abf565298a448092e5878fa02ab774a16"><div class="ttname"><a href="#abf565298a448092e5878fa02ab774a16">gf2::BitMatrix::from_outer_sum</a></div><div class="ttdeci">static constexpr BitMatrix from_outer_sum(Lhs const &amp;u, Rhs const &amp;v)</div><div class="ttdoc">Factory method to create the m x n bit-matrix from the outer sum of the given bit-stores.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:213</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abd6578b7c373b477d1af169915e9c893" name="abd6578b7c373b477d1af169915e9c893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6578b7c373b477d1af169915e9c893">&#9670;&#160;</a></span>from_row_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Store&gt; <br />
requires std::same_as&lt;typename Store::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from_row_store </td>
          <td>(</td>
          <td class="paramtype">Store const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to reshape a bit-vector <span class="tt">v</span> that is assumed to a sequence of <span class="tt">r</span> rows into a bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-120"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(15);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#abd6578b7c373b477d1af169915e9c893">BitMatrix&lt;&gt;::from_row_store</a>(v, 3).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;11111 11111 11111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#abd6578b7c373b477d1af169915e9c893">BitMatrix&lt;&gt;::from_row_store</a>(v, 5).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#abd6578b7c373b477d1af169915e9c893">BitMatrix&lt;&gt;::from_row_store</a>(v, 15).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;1 1 1 1 1 1 1 1 1 1 1 1 1 1 1&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_abd6578b7c373b477d1af169915e9c893"><div class="ttname"><a href="#abd6578b7c373b477d1af169915e9c893">gf2::BitMatrix::from_row_store</a></div><div class="ttdeci">static std::optional&lt; BitMatrix &gt; from_row_store(Store const &amp;v, usize r)</div><div class="ttdoc">Factory method to reshape a bit-vector v that is assumed to a sequence of r rows into a bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:499</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0b6cb72f20bd6a8b1377c0e5139ad482" name="a0b6cb72f20bd6a8b1377c0e5139ad482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6cb72f20bd6a8b1377c0e5139ad482">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::from_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows. </p>
<p>The rows can be separated by newlines, white space, commas, single quotes, or semicolons. Each row should be a binary or hex string representation of a bit-vector. The rows can have an optional prefix of "0b", "0x" or "0X" to indicate that the string is binary or hex.</p>
<p>A hex string can have a suffix of ".2", ".4", or ".8" to indicate the base of the last digit/character. This allows for rows of any length as opposed to just a multiple of 4.</p>
<p>After parsing, the rows must all have the same length.</p>
<h1 class="doxsection"><a class="anchor" id="example-122"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a0b6cb72f20bd6a8b1377c0e5139ad482">BitMatrix&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;111   111\n111&quot;</span>).value();</div>
<div class="line">assert_eq(m1.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a0b6cb72f20bd6a8b1377c0e5139ad482">BitMatrix&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0XAA; 0b1111_0000&quot;</span>).value();</div>
<div class="line">assert_eq(m2.to_compact_binary_string(), <span class="stringliteral">&quot;10101010 11110000&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#a0b6cb72f20bd6a8b1377c0e5139ad482">BitMatrix&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;0x7.8 000&quot;</span>).value();</div>
<div class="line">assert_eq(m3.to_compact_binary_string(), <span class="stringliteral">&quot;111 000&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a0b6cb72f20bd6a8b1377c0e5139ad482"><div class="ttname"><a href="#a0b6cb72f20bd6a8b1377c0e5139ad482">gf2::BitMatrix::from_string</a></div><div class="ttdeci">static std::optional&lt; BitMatrix &gt; from_string(std::string_view s)</div><div class="ttdoc">Factory method to construct a bit-matrix from a string that is assumed to be a sequence of rows.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:582</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a26840ca85eed88714fe311efe9001e46" name="a26840ca85eed88714fe311efe9001e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26840ca85eed88714fe311efe9001e46">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the element at row <span class="tt">r</span> and column <span class="tt">c</span> is set. </p>
<h1 class="doxsection"><a class="anchor" id="panics-30"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-134"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab34ac8ed7a00be3f9f1548bb881e216e" name="ab34ac8ed7a00be3f9f1548bb881e216e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34ac8ed7a00be3f9f1548bb881e216e">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> identity bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-114"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6a3b548e9d1d91ebb501566dc72ebf0" name="af6a3b548e9d1d91ebb501566dc72ebf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a3b548e9d1d91ebb501566dc72ebf0">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of a square bit-matrix or <span class="tt">std::nullopt</span> if the matrix is singular. </p>
<h1 class="doxsection"><a class="anchor" id="example-180"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.inverse().value().to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab22926c01bdf883d1132ef55a988e75c" name="ab22926c01bdf883d1132ef55a988e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22926c01bdf883d1132ef55a988e75c">&#9670;&#160;</a></span>is_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::is_identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this is the identity bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-125"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.is_identity(), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a643db1e6f224de8b2d6f83cd6122258d" name="a643db1e6f224de8b2d6f83cd6122258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643db1e6f224de8b2d6f83cd6122258d">&#9670;&#160;</a></span>is_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::is_square </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this a square bit-matrix? Note that empty bit-matrices are NOT considered square. </p>
<h1 class="doxsection"><a class="anchor" id="example-123"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a643db1e6f224de8b2d6f83cd6122258d">is_square</a>(), <span class="keyword">false</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(3, 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a643db1e6f224de8b2d6f83cd6122258d">is_square</a>(), <span class="keyword">true</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(3, 4);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a643db1e6f224de8b2d6f83cd6122258d">is_square</a>(), <span class="keyword">false</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a643db1e6f224de8b2d6f83cd6122258d"><div class="ttname"><a href="#a643db1e6f224de8b2d6f83cd6122258d">gf2::BitMatrix::is_square</a></div><div class="ttdeci">constexpr bool is_square() const</div><div class="ttdoc">Returns true if this a square bit-matrix? Note that empty bit-matrices are NOT considered square.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:655</div></div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a8eb76dca82ceaefd147bce32dacc8887"><div class="ttname"><a href="#a8eb76dca82ceaefd147bce32dacc8887">gf2::BitMatrix::resize</a></div><div class="ttdeci">constexpr void resize(usize r, usize c)</div><div class="ttdoc">Resize the bit-matrix to r rows and c columns.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:1189</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0cb0145058cc1a40b353b66704a2b543" name="a0cb0145058cc1a40b353b66704a2b543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb0145058cc1a40b353b66704a2b543">&#9670;&#160;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::is_symmetric </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this is a symmetric square bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-126"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.is_symmetric(), <span class="keyword">true</span>);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.is_symmetric(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae4bdba6def6fc1bbbfeba7ee3a350c1b" name="ae4bdba6def6fc1bbbfeba7ee3a350c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">&#9670;&#160;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::is_zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this a square <em>zero</em> bit-matrix? </p>
<h1 class="doxsection"><a class="anchor" id="example-124"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m;</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">is_zero</a>(), <span class="keyword">false</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(3, 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">is_zero</a>(), <span class="keyword">true</span>);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(3, 4);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#ae4bdba6def6fc1bbbfeba7ee3a350c1b">is_zero</a>(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b23de84fa10d85060a045c3c4058242" name="a8b23de84fa10d85060a045c3c4058242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b23de84fa10d85060a045c3c4058242">&#9670;&#160;</a></span>left_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::left_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> rotate-left by <span class="tt">p</span> places matrix. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector rotated right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-118"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a8b23de84fa10d85060a045c3c4058242">BitMatrix&lt;&gt;::left_rotation</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a193a2ffb36fa664bbdbfe057f4f491d2">BitVector&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;11100&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf">dot</a>(m, v).<a class="code hl_function" href="#a34bff5d41dfac388664628d34ee09229">to_string</a>(), <span class="stringliteral">&quot;00111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a8b23de84fa10d85060a045c3c4058242"><div class="ttname"><a href="#a8b23de84fa10d85060a045c3c4058242">gf2::BitMatrix::left_rotation</a></div><div class="ttdeci">static BitMatrix left_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-left by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:453</div></div>
<div class="ttc" id="anamespacegf2_html_a612727967670558acfd0fd2adc99eccf"><div class="ttname"><a href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf">gf2::dot</a></div><div class="ttdeci">constexpr auto dot(BitMatrix&lt; Word &gt; const &amp;lhs, Rhs const &amp;rhs)</div><div class="ttdoc">Bit-matrix, bit-store multiplication, M * v, returning a new bit-vector.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2573</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8dbd5a56c0ea28ea96298a5007e4ff4" name="ae8dbd5a56c0ea28ea96298a5007e4ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8dbd5a56c0ea28ea96298a5007e4ff4">&#9670;&#160;</a></span>left_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::left_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> shift-left by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector shifted left by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-116"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ae8dbd5a56c0ea28ea96298a5007e4ff4">BitMatrix&lt;&gt;::left_shift</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf">dot</a>(m, v).<a class="code hl_function" href="#a34bff5d41dfac388664628d34ee09229">to_string</a>(), <span class="stringliteral">&quot;11100&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae8dbd5a56c0ea28ea96298a5007e4ff4"><div class="ttname"><a href="#ae8dbd5a56c0ea28ea96298a5007e4ff4">gf2::BitMatrix::left_shift</a></div><div class="ttdeci">static constexpr BitMatrix left_shift(usize n, usize p)</div><div class="ttdoc">Constructs the n x n shift-left by p places BitMatrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:421</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae78b4ac4135e4b133e56ed5a11208fac" name="ae78b4ac4135e4b133e56ed5a11208fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78b4ac4135e4b133e56ed5a11208fac">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the lower triangular part of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-166"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 110 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a31496c74a8fb2a4a2407e558db90e29f" name="a31496c74a8fb2a4a2407e558db90e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31496c74a8fb2a4a2407e558db90e29f">&#9670;&#160;</a></span>LU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitLU.html">BitLU</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::LU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the LU decomposition of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-183"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> lu = m.LU();</div>
<div class="line">assert_eq(lu.LU().to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a87f39f93fc76b11e9b9e84b514df5c18" name="a87f39f93fc76b11e9b9e84b514df5c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f39f93fc76b11e9b9e84b514df5c18">&#9670;&#160;</a></span>make_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::make_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an arbitrary rectangular bit-matrix into a square <span class="tt"><a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a></span>. </p>
<p>Existing elements are preserved. Any added elements are initialized to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-154"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a0b6cb72f20bd6a8b1377c0e5139ad482">BitMatrix&lt;&gt;::from_string</a>(<span class="stringliteral">&quot;111 111 111 111&quot;</span>).value();</div>
<div class="line">m.make_square(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a76bc5d329b6606e05bbbd2a0739d0bc6" name="a76bc5d329b6606e05bbbd2a0739d0bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bc5d329b6606e05bbbd2a0739d0bc6">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::none </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if no elements of the bit-matrix are set. </p>
<p>Empty matrices are considered to have no set bits.</p>
<h1 class="doxsection"><a class="anchor" id="example-133"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.none(), <span class="keyword">true</span>);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.none(), <span class="keyword">false</span>);</div>
<div class="line">m.clear();</div>
<div class="line">assert_eq(m.none(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa3e90bb8c4b85662a1744b5ae275d7f5" name="aa3e90bb8c4b85662a1744b5ae275d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e90bb8c4b85662a1744b5ae275d7f5">&#9670;&#160;</a></span>ones() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-102"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a95ec8df5690d34cb09e4446271b18f05" name="a95ec8df5690d34cb09e4446271b18f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ec8df5690d34cb09e4446271b18f05">&#9670;&#160;</a></span>ones() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> bit-matrix with all the elements set to 1. </p>
<h1 class="doxsection"><a class="anchor" id="example-101"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;1111 1111 1111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1f5d6471aa5213dee5d6de9348158a8" name="ad1f5d6471aa5213dee5d6de9348158a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f5d6471aa5213dee5d6de9348158a8">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">AND</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-69"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-192"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs &amp; rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1cef692a868cc889c2c920284a381b2f" name="a1cef692a868cc889c2c920284a381b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cef692a868cc889c2c920284a381b2f">&#9670;&#160;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">AND</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-66"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-189"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs &amp;= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b8d39968f36adf2681e317320029bb0" name="a5b8d39968f36adf2681e317320029bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8d39968f36adf2681e317320029bb0">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitRef.html">BitRef</a>&lt; row_type &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt"><a class="el" href="classgf2_1_1BitRef.html" title="A BitRef is a proxy class to reference a single bit in a bit-store.">BitRef</a></span> reference which can be used to set the bit. </p>
<h1 class="doxsection"><a class="anchor" id="panics-33"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-137"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m(0,0), <span class="keyword">false</span>);</div>
<div class="line">m(0,0) = <span class="keyword">true</span>;</div>
<div class="line">assert_eq(m(0,0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1d722c95b308f15a837158e454a1156b" name="a1d722c95b308f15a837158e454a1156b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d722c95b308f15a837158e454a1156b">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the bit at row <span class="tt">r</span> and column <span class="tt">c</span> as a <span class="tt">bool</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-31"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-135"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m(0, 0), <span class="keyword">false</span>);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2fdaf27aa81697c0ed36bf4b9cbc0881" name="a2fdaf27aa81697c0ed36bf4b9cbc0881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdaf27aa81697c0ed36bf4b9cbc0881">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is <span class="tt">*this + rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2). </p>
<h1 class="doxsection"><a class="anchor" id="panics-73"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-197"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs - rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad2fc73c4836de2fed0288c392e868d33" name="ad2fc73c4836de2fed0288c392e868d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fc73c4836de2fed0288c392e868d33">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) addition is the same as <span class="tt">XOR</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-71"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-195"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs += rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6cbf8e5d796b1cb895abb9acebd58bde" name="a6cbf8e5d796b1cb895abb9acebd58bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbf8e5d796b1cb895abb9acebd58bde">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is <span class="tt">*this - rhs</span> which is <span class="tt">*this ^ rhs</span> in GF(2). </p>
<h1 class="doxsection"><a class="anchor" id="panics-74"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-198"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs + rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ae3a559abd1ca358281883e2e3af168" name="a6ae3a559abd1ca358281883e2e3af168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3a559abd1ca358281883e2e3af168">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place difference with a bit-matrix <span class="tt">rhs</span> &ndash; in GF(2) subtraction is the same as <span class="tt">XOR</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-72"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-196"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs -= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af7e6f932769049fd64ca781a0675749f" name="af7e6f932769049fd64ca781a0675749f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e6f932769049fd64ca781a0675749f">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_type &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the row at index <span class="tt">r</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-38"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-142"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m[0].set(1);</div>
<div class="line">assert_eq(m[0].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;110&quot;</span>);</div>
<div class="line">assert_eq(m[1].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m[2].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;001&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a2266f12271b6353759a6b1941de6ccb4"><div class="ttname"><a href="#a2266f12271b6353759a6b1941de6ccb4">gf2::BitMatrix::to_binary_string</a></div><div class="ttdeci">std::string to_binary_string(std::string_view row_sep=&quot;\n&quot;, std::string_view bit_sep=&quot;&quot;, std::string_view row_prefix=&quot;&quot;, std::string_view row_suffix=&quot;&quot;) const</div><div class="ttdoc">Returns a configurable binary string representation for this bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2312</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae3d875d0593c466b0c6d0820a059a2e5" name="ae3d875d0593c466b0c6d0820a059a2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d875d0593c466b0c6d0820a059a2e5">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const row_type &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the row at index <span class="tt">r</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-37"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-141"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m[0].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">assert_eq(m[1].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m[2].<a class="code hl_function" href="#a2266f12271b6353759a6b1941de6ccb4">to_binary_string</a>(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab26ca6d2e1ff0ee5259648f316c7106d" name="ab26ca6d2e1ff0ee5259648f316c7106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ca6d2e1ff0ee5259648f316c7106d">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">XOR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-68"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-191"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs ^ rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adb66819f1c65988577c0a106653be663" name="adb66819f1c65988577c0a106653be663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb66819f1c65988577c0a106653be663">&#9670;&#160;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">XOR</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-65"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-188"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs ^= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0d4f4289546df12506a249df4d46857d" name="a0d4f4289546df12506a249df4d46857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4f4289546df12506a249df4d46857d">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The<span class="tt">OR</span> of this with a bit-matrix <span class="tt">rhs</span> returning a new bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-70"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-193"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line"><span class="keyword">auto</span> result = lhs | rhs;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd1fbe0556d69c01f4ce0939cdeac05d" name="afd1fbe0556d69c01f4ce0939cdeac05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1fbe0556d69c01f4ce0939cdeac05d">&#9670;&#160;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place <span class="tt">OR</span> with a bit-matrix <span class="tt">rhs</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-67"></a>
Panics</h1>
<p>This method panics if the dimensions do not match.</p>
<h1 class="doxsection"><a class="anchor" id="example-190"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> rhs = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">rhs.flip_all();</div>
<div class="line">lhs |= rhs;</div>
<div class="line">assert_eq(lhs.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae0207cf4915063a9d9364b0797ed51e6" name="ae0207cf4915063a9d9364b0797ed51e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0207cf4915063a9d9364b0797ed51e6">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of this bit-matrix with all the elements flipped. </p>
<h1 class="doxsection"><a class="anchor" id="example-194"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> result = ~m;</div>
<div class="line">assert_eq(result.to_compact_binary_string(), <span class="stringliteral">&quot;011 101 110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad037ef7306a35e234e545aa70b34ead1" name="ad037ef7306a35e234e545aa70b34ead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad037ef7306a35e234e545aa70b34ead1">&#9670;&#160;</a></span>probability_invertible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::probability_invertible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is invertible if each element is chosen independently and uniformly at random by flips of a fair coin. </p>
<p>For large <span class="tt">n</span>, the value is roughly 29% and that holds for n as low as 10.</p>
<h1 class="doxsection"><a class="anchor" id="panics-61"></a>
Panics</h1>
<p>This method panics if <span class="tt">n</span> is 0 &ndash; based on the assumption that querying the probability of a 0 x 0 bit-matrix being invertible is an upstream error somewhere.</p>
<h1 class="doxsection"><a class="anchor" id="example-181"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#ad037ef7306a35e234e545aa70b34ead1">BitMatrix&lt;&gt;::probability_invertible</a>(10);</div>
<div class="line">assert(abs(p - 0.289) &lt; 1e-3);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ad037ef7306a35e234e545aa70b34ead1"><div class="ttname"><a href="#ad037ef7306a35e234e545aa70b34ead1">gf2::BitMatrix::probability_invertible</a></div><div class="ttdeci">static constexpr double probability_invertible(usize n)</div><div class="ttdoc">Class method that returns the probability that a square n x n bit-matrix is invertible if each elemen...</div><div class="ttdef"><b>Definition</b> BitMatrix.h:1893</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac3a45b35307c319db9f475ee9a4c6efd" name="ac3a45b35307c319db9f475ee9a4c6efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a45b35307c319db9f475ee9a4c6efd">&#9670;&#160;</a></span>probability_singular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::probability_singular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class method that returns the probability that a square <span class="tt">n x n</span> bit-matrix is singular if each element is chosen independently and uniformly at random by flips of a fair coin. </p>
<p>For large <span class="tt">n</span>, the value is 71% and that holds for n as low as 10.</p>
<h1 class="doxsection"><a class="anchor" id="panics-62"></a>
Panics</h1>
<p>This method panics if <span class="tt">n</span> is 0 &ndash; based on the assumption that querying the probability of a 0 x 0 bit-matrix being invertible is an upstream error somewhere</p>
<h1 class="doxsection"><a class="anchor" id="example-182"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#ac3a45b35307c319db9f475ee9a4c6efd">BitMatrix&lt;&gt;::probability_singular</a>(10);</div>
<div class="line">assert(abs(p - 0.711) &lt; 1e-3);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ac3a45b35307c319db9f475ee9a4c6efd"><div class="ttname"><a href="#ac3a45b35307c319db9f475ee9a4c6efd">gf2::BitMatrix::probability_singular</a></div><div class="ttdeci">static constexpr double probability_singular(usize n)</div><div class="ttdoc">Class method that returns the probability that a square n x n bit-matrix is singular if each element ...</div><div class="ttdef"><b>Definition</b> BitMatrix.h:1924</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a47a029b47df5b3641f6f06483b549ce6" name="a47a029b47df5b3641f6f06483b549ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a029b47df5b3641f6f06483b549ce6">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are picked at random. </p>
<p>This is the workhorse method for generating random bit-matrices that allows one to specify the probability of each bit being 1, and also a seed for the random number generator for reproducibility. If you set the seed to 0 then computer entropy is used to seed the RNG.</p>
<p>The default call <span class="tt"><a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>&lt;&gt;::random(m, n)</span> produces a random bit-matrix with each bit being 1 with probability 0.5 and where the RNG is seeded from entropy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">p</td><td>The probability of the elements being 1 (defaults to a fair coin, i.e. 50-50). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (defaults to 0, which means use entropy).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-108"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#a47a029b47df5b3641f6f06483b549ce6">BitMatrix&lt;&gt;::random</a>(3, 2, 0.5, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a47a029b47df5b3641f6f06483b549ce6">BitMatrix&lt;&gt;::random</a>(3, 2, 0.5, seed);</div>
<div class="line">assert(u == v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3217cfe4444372ccd61e17b5735e1778" name="a3217cfe4444372ccd61e17b5735e1778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3217cfe4444372ccd61e17b5735e1778">&#9670;&#160;</a></span>remove_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::remove_col </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a column off the right of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-163"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a> = m.remove_col();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#ae6bccbc7ad5685af7a92f5f4cd867459">col</a>-&gt;to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 11 11&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ceafc420345dfd11bf8cb4b2541ebdb" name="a2ceafc420345dfd11bf8cb4b2541ebdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceafc420345dfd11bf8cb4b2541ebdb">&#9670;&#160;</a></span>remove_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::remove_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a row off the end of the bit-matrix and returns it or <span class="tt">std::nullopt</span> if the bit-matrix is empty. </p>
<h1 class="doxsection"><a class="anchor" id="example-161"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a23a559c0e9856fe9e40775724df31f8b">row</a> = m.remove_row();</div>
<div class="line">assert_eq(<a class="code hl_function" href="#a23a559c0e9856fe9e40775724df31f8b">row</a>-&gt;to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adb124132aa42cc9cd5a93f9739911702" name="adb124132aa42cc9cd5a93f9739911702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb124132aa42cc9cd5a93f9739911702">&#9670;&#160;</a></span>remove_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::remove_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <span class="tt">k</span> rows off the end of the bit-matrix and returns them as a new bit-matrix or <span class="tt">std::nullopt</span> if the bit-matrix has fewer than <span class="tt">k</span> rows. </p>
<h1 class="doxsection"><a class="anchor" id="example-162"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> popped = m.remove_rows(2);</div>
<div class="line">assert_eq(popped-&gt;to_compact_binary_string(), <span class="stringliteral">&quot;111 111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a77a793d34475a74063d5748fb91ffc65" name="a77a793d34475a74063d5748fb91ffc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a793d34475a74063d5748fb91ffc65">&#9670;&#160;</a></span>replace_sub_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::replace_sub_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>top</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the sub-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span> with a copy of the sub-matrix <span class="tt">src</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-53"></a>
Panics</h1>
<p>Panics if <span class="tt">src</span> does not fit within this bit-matrix starting at row <span class="tt">top</span> and column <span class="tt">left</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-165"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(5);</div>
<div class="line">m.replace_sub_matrix(1, 1, <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3));</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;10000 01110 01110 01110 00001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8eb76dca82ceaefd147bce32dacc8887" name="a8eb76dca82ceaefd147bce32dacc8887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb76dca82ceaefd147bce32dacc8887">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the bit-matrix to <span class="tt">r</span> rows and <span class="tt">c</span> columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The new number of rows &ndash; if r &lt; <a class="el" href="#a28475ec720b56857bf838222f5bcff28" title="Returns the number of rows in the bit-matrix.">rows()</a> then we lose the excess rows. </td></tr>
    <tr><td class="paramname">c</td><td>The new number of columns &ndash; if c &lt; <a class="el" href="#a442cc69f62dc133313a62100f404a376" title="Returns the number of columns in the bit-matrix.">cols()</a> then we lose the excess columns.</td></tr>
  </table>
  </dd>
</dl>
<p>Any added elements are set to 0.</p>
<h1 class="doxsection"><a class="anchor" id="example-152"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m;</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(10, 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a>(), 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a442cc69f62dc133313a62100f404a376">cols</a>(), 10);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(3, 7);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a>(), 3);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a442cc69f62dc133313a62100f404a376">cols</a>(), 7);</div>
<div class="line">m.<a class="code hl_function" href="#a8eb76dca82ceaefd147bce32dacc8887">resize</a>(0, 10);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a28475ec720b56857bf838222f5bcff28">rows</a>(), 0);</div>
<div class="line">assert_eq(m.<a class="code hl_function" href="#a442cc69f62dc133313a62100f404a376">cols</a>(), 0);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a442cc69f62dc133313a62100f404a376"><div class="ttname"><a href="#a442cc69f62dc133313a62100f404a376">gf2::BitMatrix::cols</a></div><div class="ttdeci">constexpr usize cols() const</div><div class="ttdoc">Returns the number of columns in the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:632</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6fefecbb0bd5f81e499abeec66751e60" name="a6fefecbb0bd5f81e499abeec66751e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fefecbb0bd5f81e499abeec66751e60">&#9670;&#160;</a></span>right_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::right_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> rotate-right by <span class="tt">p</span> places matrix. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector rotated right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-119"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a6fefecbb0bd5f81e499abeec66751e60">BitMatrix&lt;&gt;::right_rotation</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#a193a2ffb36fa664bbdbfe057f4f491d2">BitVector&lt;&gt;::from_binary_string</a>(<span class="stringliteral">&quot;11100&quot;</span>).value();</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf">dot</a>(m, v).<a class="code hl_function" href="#a34bff5d41dfac388664628d34ee09229">to_string</a>(), <span class="stringliteral">&quot;10011&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a6fefecbb0bd5f81e499abeec66751e60"><div class="ttname"><a href="#a6fefecbb0bd5f81e499abeec66751e60">gf2::BitMatrix::right_rotation</a></div><div class="ttdeci">static BitMatrix right_rotation(usize n, usize p)</div><div class="ttdoc">Constructs the n x n rotate-right by p places matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:472</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a58d167b1673c17996bac2c74a03f4bc2" name="a58d167b1673c17996bac2c74a03f4bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d167b1673c17996bac2c74a03f4bc2">&#9670;&#160;</a></span>right_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::right_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <span class="tt">n x n</span> shift-right by <span class="tt">p</span> places <a class="el" href="classgf2_1_1BitMatrix.html" title="A dynamically-sized matrix over GF(2) stored as a vector of bit-vectors representing the rows of the ...">BitMatrix</a>. </p>
<p>If the bit-matrix is multiplied by a bit-vector, the result is the bit-vector shifted right by <span class="tt">p</span> places.</p>
<h1 class="doxsection"><a class="anchor" id="example-117"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a58d167b1673c17996bac2c74a03f4bc2">BitMatrix&lt;&gt;::right_shift</a>(5, 2);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(5);</div>
<div class="line">assert_eq(<a class="code hl_function" href="namespacegf2.html#a612727967670558acfd0fd2adc99eccf">dot</a>(m, v).<a class="code hl_function" href="#a34bff5d41dfac388664628d34ee09229">to_string</a>(), <span class="stringliteral">&quot;00111&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a58d167b1673c17996bac2c74a03f4bc2"><div class="ttname"><a href="#a58d167b1673c17996bac2c74a03f4bc2">gf2::BitMatrix::right_shift</a></div><div class="ttdeci">static BitMatrix right_shift(usize n, usize p)</div><div class="ttdoc">Constructs the n x n shift-right by p places BitMatrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:437</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3a0923161bde9281d5c389031d917cab" name="a3a0923161bde9281d5c389031d917cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0923161bde9281d5c389031d917cab">&#9670;&#160;</a></span>row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_type &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the row at index <span class="tt">r</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-36"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-140"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m.row(0).set(1);</div>
<div class="line">assert_eq(m.row(0).to_binary_string(), <span class="stringliteral">&quot;110&quot;</span>);</div>
<div class="line">assert_eq(m.row(1).to_binary_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m.row(2).to_binary_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23a559c0e9856fe9e40775724df31f8b" name="a23a559c0e9856fe9e40775724df31f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a559c0e9856fe9e40775724df31f8b">&#9670;&#160;</a></span>row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const row_type &amp; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the row at index <span class="tt">r</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-35"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-139"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m.row(0).to_binary_string(), <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">assert_eq(m.row(1).to_binary_string(), <span class="stringliteral">&quot;010&quot;</span>);</div>
<div class="line">assert_eq(m.row(2).to_binary_string(), <span class="stringliteral">&quot;001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aad722ffb0e8ced1306fe9b7f6b23728f" name="aad722ffb0e8ced1306fe9b7f6b23728f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad722ffb0e8ced1306fe9b7f6b23728f">&#9670;&#160;</a></span>seeded_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a square bit-matrix of size <span class="tt">m x m</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random square bit-matrices, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows &amp; columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-110"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ae64047186ba4f7f492488e6656b3a830">BitMatrix&lt;&gt;::seeded_random</a>(3, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ae64047186ba4f7f492488e6656b3a830">BitMatrix&lt;&gt;::seeded_random</a>(3, seed);</div>
<div class="line">assert(u == v);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ae64047186ba4f7f492488e6656b3a830"><div class="ttname"><a href="#ae64047186ba4f7f492488e6656b3a830">gf2::BitMatrix::seeded_random</a></div><div class="ttdeci">static BitMatrix seeded_random(usize m, usize n, std::uint64_t seed)</div><div class="ttdoc">Factory method to generate a bit-matrix of size m x n where the elements are from independent fair co...</div><div class="ttdef"><b>Definition</b> BitMatrix.h:314</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae64047186ba4f7f492488e6656b3a830" name="ae64047186ba4f7f492488e6656b3a830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64047186ba4f7f492488e6656b3a830">&#9670;&#160;</a></span>seeded_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::seeded_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to generate a bit-matrix of size <span class="tt">m x n</span> where the elements are from independent fair coin flips generated from an RNG seeded with the given <span class="tt">seed</span>. </p>
<p>This allows one to have reproducible random bit-vectors, which is useful for testing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the bit-matrix to generate. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed to use for the random number generator (if you set this to 0 then entropy is used).</td></tr>
  </table>
  </dd>
</dl>
<p>If <span class="tt">p &lt; 0</span> then the bit-matrix is all zeros, if <span class="tt">p &gt; 1</span> then the bit-matrix is all ones.</p>
<h1 class="doxsection"><a class="anchor" id="example-109"></a>
Example</h1>
<div class="fragment"><div class="line">std::uint64_t seed = 1234567890;</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code hl_function" href="#ae64047186ba4f7f492488e6656b3a830">BitMatrix&lt;&gt;::seeded_random</a>(3, 2, seed);</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#ae64047186ba4f7f492488e6656b3a830">BitMatrix&lt;&gt;::seeded_random</a>(3, 2, seed);</div>
<div class="line">assert(u == v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05b863d6516f94628e5f7240da2838ac" name="a05b863d6516f94628e5f7240da2838ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b863d6516f94628e5f7240da2838ac">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit at row <span class="tt">r</span> and column <span class="tt">c</span> to the bool value <span class="tt">val</span>. The default is to set the bit to <span class="tt">true</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-32"></a>
Panics</h1>
<p>In debug mode, this method will panic if <span class="tt">r</span> or <span class="tt">c</span> is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-136"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set(0, 0);</div>
<div class="line">assert_eq(m.get(0, 0), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1fd6971c0602d83bcdb1ac1868e9ea95" name="a1fd6971c0602d83bcdb1ac1868e9ea95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd6971c0602d83bcdb1ac1868e9ea95">&#9670;&#160;</a></span>set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the elements of the bit-matrix to the specified boolean <span class="tt">value</span>. </p>
<p>By default, all bits are set to <span class="tt">true</span>.</p>
<h1 class="doxsection"><a class="anchor" id="example-144"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 111 111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abbf2d199c359040316b7ed497991e535" name="abbf2d199c359040316b7ed497991e535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf2d199c359040316b7ed497991e535">&#9670;&#160;</a></span>set_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::set_diagonal </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the main diagonal of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<h1 class="doxsection"><a class="anchor" id="panics-40"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-146"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.set_diagonal();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09043ce58925edf3de04b69b3909a39b" name="a09043ce58925edf3de04b69b3909a39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09043ce58925edf3de04b69b3909a39b">&#9670;&#160;</a></span>set_sub_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::set_sub_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the elements on sub-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first sub-diagonal etc.</p>
<h1 class="doxsection"><a class="anchor" id="panics-44"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-150"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m.set_sub_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;00000 10000 01000 00100 00010&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac996c7bad9217a51c32d246cb515d3bd" name="ac996c7bad9217a51c32d246cb515d3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac996c7bad9217a51c32d246cb515d3bd">&#9670;&#160;</a></span>set_super_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::set_super_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the elements on super-diagonal <span class="tt">d</span> of a square bit-matrix to the boolean value <span class="tt">val</span>. </p>
<p>Here <span class="tt">d = 0</span> is the main diagonal and <span class="tt">d = 1</span> is the first super-diagonal etc.</p>
<h1 class="doxsection"><a class="anchor" id="panics-42"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-148"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m.set_super_diagonal(1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;01000 00100 00010 00001 00000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a558f19425492b27f2af65123af3900a1" name="a558f19425492b27f2af65123af3900a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558f19425492b27f2af65123af3900a1">&#9670;&#160;</a></span>solver_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::solver_for </td>
          <td>(</td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Gaussian elimination solver for this bit-matrix and the passed r.h.s. vector <span class="tt">b</span>. </p>
<h1 class="doxsection"><a class="anchor" id="example-184"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3);</div>
<div class="line"><span class="keyword">auto</span> solver = A.solver_for(b);</div>
<div class="line">assert_eq(solver.rank(), 1);</div>
<div class="line">assert_eq(solver.free_count(), 2);</div>
<div class="line">assert_eq(solver.solution_count(), 4);</div>
<div class="line">assert_eq(solver.is_underdetermined(), <span class="keyword">true</span>);</div>
<div class="line">assert_eq(solver.is_consistent(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6c25fb805a0ca7f1a43b629ae407425" name="ab6c25fb805a0ca7f1a43b629ae407425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c25fb805a0ca7f1a43b629ae407425">&#9670;&#160;</a></span>strictly_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::strictly_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the strictly lower triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#ae78b4ac4135e4b133e56ed5a11208fac" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal reset to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-168"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.strictly_lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;000 100 110&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6a6935a54eb964b26942876e01abd18d" name="a6a6935a54eb964b26942876e01abd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6935a54eb964b26942876e01abd18d">&#9670;&#160;</a></span>strictly_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::strictly_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the strictly upper triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#ae78b4ac4135e4b133e56ed5a11208fac" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal reset to zero.</p>
<h1 class="doxsection"><a class="anchor" id="example-169"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.strictly_upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;011 001 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3189f2c2d533cf7095919e046cbec07b" name="a3189f2c2d533cf7095919e046cbec07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189f2c2d533cf7095919e046cbec07b">&#9670;&#160;</a></span>sub_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::sub_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>r_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>c_end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the sub-matrix delimited by the given row and column ranges. </p>
<p>The ranges are half open <span class="tt">[r_start, r_end) X [c_start, c_end)</span> where <span class="tt">r</span> is for rows and <span class="tt">c</span> for columns.</p>
<h1 class="doxsection"><a class="anchor" id="panics-52"></a>
Panics</h1>
<p>Panics if the bit-matrix has incompatible dimensions with the requested sub-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="example-164"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(5);</div>
<div class="line"><span class="keyword">auto</span> sub1 = m.sub_matrix(1, 4, 1, 4);</div>
<div class="line">assert_eq(sub1.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sub2 = m.sub_matrix(1, 1, 1, 1);</div>
<div class="line">assert_eq(sub2.to_compact_binary_string(), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a03d22db34174e04d17ae575898373a2d" name="a03d22db34174e04d17ae575898373a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d22db34174e04d17ae575898373a2d">&#9670;&#160;</a></span>swap_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::swap_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps columns <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-55"></a>
Panics</h1>
<p>In debug mode, this method will panic if either of the indices is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-173"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m.swap_cols(0, 1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;010 100 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a143d9cbb3015422571eede697fe86c3d" name="a143d9cbb3015422571eede697fe86c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143d9cbb3015422571eede697fe86c3d">&#9670;&#160;</a></span>swap_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::swap_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps rows <span class="tt">i</span> and <span class="tt">j</span> of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="panics-54"></a>
Panics</h1>
<p>In debug mode, this method will panic if either of the indices is out of bounds.</p>
<h1 class="doxsection"><a class="anchor" id="example-172"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m.swap_rows(0, 1);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;010 100 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2266f12271b6353759a6b1941de6ccb4" name="a2266f12271b6353759a6b1941de6ccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2266f12271b6353759a6b1941de6ccb4">&#9670;&#160;</a></span>to_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_binary_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;\n&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>bit_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a configurable binary string representation for this bit-matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_sep</td><td>What we use to separate the rows (defaults to a "\n"). </td></tr>
    <tr><td class="paramname">bit_sep</td><td>What we use to separate the bit elements in the rows (defaults to ""). </td></tr>
    <tr><td class="paramname">row_prefix</td><td>Added to the left of each row (defaults to ""). </td></tr>
    <tr><td class="paramname">row_suffix</td><td>Added to the right of each row (defaults to "").</td></tr>
  </table>
  </dd>
</dl>
<p>The default prints each row as 0's and 1's without any formatting, and separates the rows with newlines.</p>
<h1 class="doxsection"><a class="anchor" id="example-199"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_binary_string(), <span class="stringliteral">&quot;1000\n0100\n0010\n0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad9f837326c007a7409f697c39fb7702d" name="ad9f837326c007a7409f697c39fb7702d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f837326c007a7409f697c39fb7702d">&#9670;&#160;</a></span>to_compact_binary_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_compact_binary_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a one-line minimal binary string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's without any formatting, and separates the rows with a single space.</p>
<h1 class="doxsection"><a class="anchor" id="example-200"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_compact_binary_string(), <span class="stringliteral">&quot;1000 0100 0010 0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a320c4578d71269d36c000cd1f5a897f2" name="a320c4578d71269d36c000cd1f5a897f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c4578d71269d36c000cd1f5a897f2">&#9670;&#160;</a></span>to_compact_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_compact_hex_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a compact "hex" string representation of the bit-matrix. </p>
<p>Empty bit-matrices are represented as the empty string.</p>
<p>Each row in a non-empty bit-matrix is a string of hex chars without any spaces, commas, or other formatting. The rows are separated by a single space.</p>
<p>Each row may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-204"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m0;</div>
<div class="line">assert_eq(m0.<a class="code hl_function" href="#a320c4578d71269d36c000cd1f5a897f2">to_compact_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(4);</div>
<div class="line">m1.set_all();</div>
<div class="line">assert_eq(m1.to_compact_hex_string(), <span class="stringliteral">&quot;F F F F&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m2.flip_all();</div>
<div class="line">assert_eq(m2.to_compact_hex_string(), <span class="stringliteral">&quot;F1.2 F1.2 F1.2 F1.2 F1.2&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a320c4578d71269d36c000cd1f5a897f2"><div class="ttname"><a href="#a320c4578d71269d36c000cd1f5a897f2">gf2::BitMatrix::to_compact_hex_string</a></div><div class="ttdeci">std::string to_compact_hex_string() const</div><div class="ttdoc">Returns a compact &quot;hex&quot; string representation of the bit-matrix.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2440</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aec7e8d35bd0964624e61907ccc2ce551" name="aec7e8d35bd0964624e61907ccc2ce551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7e8d35bd0964624e61907ccc2ce551">&#9670;&#160;</a></span>to_echelon_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_echelon_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an arbitrary shaped, non-empty, bit-matrix to row-echelon form (in-place). </p>
<p>The method returns a bit-vector that shows which columns have a "pivot" (a non-zero on or below the diagonal). The matrix <em>rank</em> is the number of set bits in that pivot bit-vector.</p>
<p>A bit-matrix is in echelon form if the first 1 in any row is to the right of the first 1 in the preceding row. It is a generalization of an upper triangular form &ndash; the result is a matrix with a "staircase" shape.</p>
<p>The transformation is Gaussian elimination. Any all zero rows are moved to the bottom of the matrix. The echelon form is not unique.</p>
<h1 class="doxsection"><a class="anchor" id="panics-59"></a>
Panics</h1>
<p>This method will panic if the bit-matrix is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-178"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m.set(2, 1, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">auto</span> has_pivot = m.to_echelon_form();</div>
<div class="line">assert_eq(has_pivot.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a67c36a94bd9baa9fe134b41c966c4f8e" name="a67c36a94bd9baa9fe134b41c966c4f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c36a94bd9baa9fe134b41c966c4f8e">&#9670;&#160;</a></span>to_hex_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_hex_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>row_sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;\n&quot;</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Returns the "hex" string representation of the bit-matrix </p>
<p>Empty bit-matrices are represented as the empty string.</p>
<p>Each row in a non-empty bit-matrix is a string of hex chars without any spaces, commas, or other formatting. By default, the rows are separated by newlines.</p>
<p>Each row may have a two character <em>suffix</em> of the form ".base" where <span class="tt">base</span> is one of 2, 4 or 8. <br  />
 All hex characters encode 4 bits: "0X0" -&gt; <span class="tt">0b0000</span>, "0X1" -&gt; <span class="tt">0b0001</span>, ..., "0XF" -&gt; <span class="tt">0b1111</span>. <br  />
 The three possible ".base" suffixes allow for bit-vectors whose length is not a multiple of 4. <br  />
</p>
<ul>
<li><span class="tt">0X1</span> is the hex representation of the bit-vector <span class="tt">0001</span> =&gt; length 4.</li>
<li><span class="tt">0X1.8</span> is the hex representation of the bit-vector <span class="tt">001</span> =&gt; length 3.</li>
<li><span class="tt">0X1.4</span> is the hex representation of the bit-vector <span class="tt">01</span> =&gt; length 2.</li>
<li><span class="tt">0X1.2</span> is the hex representation of the bit-vector <span class="tt">1</span> =&gt; length 1.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="example-203"></a>
Example</h1>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> m0;</div>
<div class="line">assert_eq(m0.<a class="code hl_function" href="#a67c36a94bd9baa9fe134b41c966c4f8e">to_hex_string</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(4);</div>
<div class="line">m1.set_all();</div>
<div class="line">assert_eq(m1.to_hex_string(), <span class="stringliteral">&quot;F\nF\nF\nF&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(5);</div>
<div class="line">m2.flip_all();</div>
<div class="line">assert_eq(m2.to_hex_string(), <span class="stringliteral">&quot;F1.2\nF1.2\nF1.2\nF1.2\nF1.2&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_a67c36a94bd9baa9fe134b41c966c4f8e"><div class="ttname"><a href="#a67c36a94bd9baa9fe134b41c966c4f8e">gf2::BitMatrix::to_hex_string</a></div><div class="ttdeci">std::string to_hex_string(std::string_view row_sep=&quot;\n&quot;) const</div><div class="ttdoc">&quot;Returns the &quot;hex&quot; string representation of the bit-matrix</div><div class="ttdef"><b>Definition</b> BitMatrix.h:2395</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adab9ef71beec4e827595508ce4849d5d" name="adab9ef71beec4e827595508ce4849d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9ef71beec4e827595508ce4849d5d">&#9670;&#160;</a></span>to_pretty_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_pretty_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default pretty string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's with a space between each element. The rows are delimited by a light vertical bar on the left and right. The rows are separated by newlines.</p>
<h1 class="doxsection"><a class="anchor" id="example-202"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> bar = <span class="stringliteral">&quot;\u2502&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> expected = std::format(<span class="stringliteral">&quot;{0}1 0 0{0}\n{0}0 1 0{0}\n{0}0 0 1{0}&quot;</span>, bar);</div>
<div class="line">assert_eq(I.to_pretty_string(), expected);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6e31859fe6991d1acab6fad23a585f63" name="a6e31859fe6991d1acab6fad23a585f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e31859fe6991d1acab6fad23a585f63">&#9670;&#160;</a></span>to_reduced_echelon_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf2_1_1BitVector.html">BitVector</a>&lt; Word &gt; <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_reduced_echelon_form </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the bit-matrix to reduced row-echelon form (in-place). </p>
<p>The method returns a bit-vector that shows which columns have a "pivot" (a non-zero on or below the diagonal). The matrix <em>rank</em> is the number of set bits in that bit-vector.</p>
<p>A bit-matrix is in reduced echelon form if it is in echelon form with at most one 1 in each column. The reduced echelon form is unique.</p>
<h1 class="doxsection"><a class="anchor" id="panics-60"></a>
Panics</h1>
<p>This method will panic if the bit-matrix is empty.</p>
<h1 class="doxsection"><a class="anchor" id="example-179"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">m.set(2, 1, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">auto</span> pivots = m.to_reduced_echelon_form();</div>
<div class="line">assert_eq(pivots.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a34bff5d41dfac388664628d34ee09229" name="a34bff5d41dfac388664628d34ee09229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bff5d41dfac388664628d34ee09229">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default string representation for this bit-matrix. </p>
<p>Each row is shown as 0's and 1's without any formatting, and separates the rows with a newline.</p>
<h1 class="doxsection"><a class="anchor" id="example-201"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> I = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(4);</div>
<div class="line">assert_eq(I.to_string(), <span class="stringliteral">&quot;1000\n0100\n0010\n0001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab67c02641d3a769905e2fd056b6e3d63" name="ab67c02641d3a769905e2fd056b6e3d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67c02641d3a769905e2fd056b6e3d63">&#9670;&#160;</a></span>to_the()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::to_the </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>n_is_log2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is this one raised to some power <span class="tt">n</span> or <span class="tt">2^n</span>. </p>
<p>We efficiently compute <span class="tt">M^e</span> by using a square and multiply algorithm where by default <span class="tt">e = n</span>. If the second argument <span class="tt">n_is_log2 = true</span> then we consider <span class="tt">e = 2^n</span> instead.</p>
<h1 class="doxsection"><a class="anchor" id="panics-58"></a>
Panics</h1>
<p>This method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-177"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a47a029b47df5b3641f6f06483b549ce6">BitMatrix&lt;&gt;::random</a>(100, 100);</div>
<div class="line"><span class="keyword">auto</span> p1 = m.to_the(3);</div>
<div class="line"><span class="keyword">auto</span> o1 = m * m * m;</div>
<div class="line">assert_eq(p1, o1);</div>
<div class="line"><span class="keyword">auto</span> p2 = m.to_the(2, <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> o2 = m * o1;</div>
<div class="line">assert_eq(p2, o2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6bbc74411849c034fb06bb15aa5f71e" name="ab6bbc74411849c034fb06bb15aa5f71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bbc74411849c034fb06bb15aa5f71e">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::trace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "sum" of the main diagonal elements of the bit-matrix. </p>
<p>Returns the "sum" of the main diagonal elements of the bit-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="panics-29"></a>
Panics</h1>
<p>In debug mode, this method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-130"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert_eq(m1.trace(), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(4);</div>
<div class="line">assert_eq(m2.trace(), <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac6a84a334103aa833eb46ca7c16c4e90" name="ac6a84a334103aa833eb46ca7c16c4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a84a334103aa833eb46ca7c16c4e90">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a <em>square</em> bit-matrix in place. </p>
<h1 class="doxsection"><a class="anchor" id="panics-57"></a>
Panics</h1>
<p>This method will panic if the bit-matrix is not square.</p>
<h1 class="doxsection"><a class="anchor" id="example-176"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;111 000 000&quot;</span>);</div>
<div class="line">m.transpose();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;100 100 100&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a128d5e4f60bd3f15583507b9726d72fc" name="a128d5e4f60bd3f15583507b9726d72fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128d5e4f60bd3f15583507b9726d72fc">&#9670;&#160;</a></span>transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::transposed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new bit-matrix that is the transpose of this one. </p>
<p><b>Note:</b> This method isn't particularly efficient as it works by iterating over all elements of the bit-matrix.</p>
<h1 class="doxsection"><a class="anchor" id="example-175"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac1d3def1adcb007ac348873c3580f276">BitMatrix&lt;&gt;::zeros</a>(3, 2);</div>
<div class="line">m.row(0).set_all();</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;11 00 00&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> n = m.transposed();</div>
<div class="line">assert_eq(n.to_compact_binary_string(), <span class="stringliteral">&quot;100 100&quot;</span>);</div>
<div class="ttc" id="aclassgf2_1_1BitMatrix_html_ac1d3def1adcb007ac348873c3580f276"><div class="ttname"><a href="#ac1d3def1adcb007ac348873c3580f276">gf2::BitMatrix::zeros</a></div><div class="ttdeci">static constexpr BitMatrix zeros(usize m, usize n)</div><div class="ttdoc">Factory method to create the m x n zero bit-matrix with all the elements set to 0.</div><div class="ttdef"><b>Definition</b> BitMatrix.h:127</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9b0cfb23fc27cc2a97edc613ef463e68" name="a9b0cfb23fc27cc2a97edc613ef463e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0cfb23fc27cc2a97edc613ef463e68">&#9670;&#160;</a></span>unit_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::unit_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the unit lower triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#ae78b4ac4135e4b133e56ed5a11208fac" title="Returns an independent clone of the lower triangular part of the bit-matrix.">lower()</a></span> but with the diagonal set to one.</p>
<h1 class="doxsection"><a class="anchor" id="example-170"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac1d3def1adcb007ac348873c3580f276">BitMatrix&lt;&gt;::zeros</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.unit_lower();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad111547f2ab4c20cb8ec0588d04c34fd" name="ad111547f2ab4c20cb8ec0588d04c34fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad111547f2ab4c20cb8ec0588d04c34fd">&#9670;&#160;</a></span>unit_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::unit_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the unit upper triangular part of the bit-matrix. </p>
<p>This is the same as <span class="tt"><a class="el" href="#a28ffed34d9f4b0cbbef78a7797298d8a" title="Returns an independent clone of the upper triangular part of the bit-matrix.">upper()</a></span> but with the diagonal set to one.</p>
<h1 class="doxsection"><a class="anchor" id="example-171"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac1d3def1adcb007ac348873c3580f276">BitMatrix&lt;&gt;::zeros</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.unit_upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;100 010 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a28ffed34d9f4b0cbbef78a7797298d8a" name="a28ffed34d9f4b0cbbef78a7797298d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ffed34d9f4b0cbbef78a7797298d8a">&#9670;&#160;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an independent <em>clone</em> of the upper triangular part of the bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-167"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a95ec8df5690d34cb09e4446271b18f05">BitMatrix&lt;&gt;::ones</a>(3, 3);</div>
<div class="line"><span class="keyword">auto</span> sub_m = m.upper();</div>
<div class="line">assert_eq(sub_m.to_compact_binary_string(), <span class="stringliteral">&quot;111 011 001&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aae09e28a15626120d57844915487190f" name="aae09e28a15626120d57844915487190f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae09e28a15626120d57844915487190f">&#9670;&#160;</a></span>x_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<div class="memtemplate">
template&lt;BitStore Rhs&gt; <br />
requires std::same_as&lt;typename Rhs::word_type, Word&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::x_for </td>
          <td>(</td>
          <td class="paramtype">Rhs const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a solution to the system of linear equations <span class="tt">A.x_ = b</span> or <span class="tt">std::nullopt</span> if there are none. </p>
<h1 class="doxsection"><a class="anchor" id="example-185"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="classgf2_1_1BitVector.html#abcfb7a88f30c8faa177519571a76ba8d">BitVector&lt;&gt;::ones</a>(3);</div>
<div class="line"><span class="keyword">auto</span> x = A.x_for(b).value();</div>
<div class="line">assert_eq(x.to_string(), <span class="stringliteral">&quot;111&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a54ad547e9cbfad34e4eadee8ebc7b5f8" name="a54ad547e9cbfad34e4eadee8ebc7b5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">&#9670;&#160;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square "zero" bit-matrix. </p>
<h1 class="doxsection"><a class="anchor" id="example-113"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#a54ad547e9cbfad34e4eadee8ebc7b5f8">BitMatrix&lt;&gt;::zero</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac997646668549e4699fdd28a779f78e5" name="ac997646668549e4699fdd28a779f78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac997646668549e4699fdd28a779f78e5">&#9670;&#160;</a></span>zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x m</span> square bit-matrix with all the elements set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-100"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac1d3def1adcb007ac348873c3580f276">BitMatrix&lt;&gt;::zeros</a>(3);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;000 000 000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac1d3def1adcb007ac348873c3580f276" name="ac1d3def1adcb007ac348873c3580f276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d3def1adcb007ac348873c3580f276">&#9670;&#160;</a></span>zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a> <a class="el" href="classgf2_1_1BitMatrix.html">gf2::BitMatrix</a>&lt; Word &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegf2.html#abed1a83530f112d069e809d8883c13a8">usize</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create the <span class="tt">m x n</span> zero bit-matrix with all the elements set to 0. </p>
<h1 class="doxsection"><a class="anchor" id="example-99"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ac1d3def1adcb007ac348873c3580f276">BitMatrix&lt;&gt;::zeros</a>(3, 4);</div>
<div class="line">assert_eq(m.to_compact_binary_string(), <span class="stringliteral">&quot;0000 0000 0000&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa07d8f45bfb2a64685f2bee65a0792c3" name="aa07d8f45bfb2a64685f2bee65a0792c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07d8f45bfb2a64685f2bee65a0792c3">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Unsigned Word = usize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae5c368ef2b300f03a588f7461623d177">BitMatrix</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator checks that any pair of bit-matrices are equal in content. </p>
<h1 class="doxsection"><a class="anchor" id="example-205"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line"><span class="keyword">auto</span> q = <a class="code hl_function" href="#ab34ac8ed7a00be3f9f1548bb881e216e">BitMatrix&lt;&gt;::identity</a>(3);</div>
<div class="line">assert(p == q);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacegf2.html">gf2</a></li><li class="navelem"><a href="classgf2_1_1BitMatrix.html">BitMatrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
