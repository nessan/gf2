<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.15.0" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GF2++: Modular Reduction</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/mathtools']
  },
  tex: {
    macros: {},
    packages: {
        '[+]': ['mathtools']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectalign">
                                    <div id="projectname">
                                        GF2++
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('Reduction.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Modular Reduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2pages_2Notes_2Reduction"></a></p>
<h1 class="doxsection"><a class="anchor" id="introduction-13"></a>
Introduction</h1>
<p>We are interested in computing the modular reduction of \(x^N\) by a polynomial \(p(x)\) over <a href="https://en.wikipedia.org/wiki/GF(2)">GF2</a>, where \(N\) is a potentially huge integer.</p>
<p>Let \(P(x)\) be a nonzero polynomial of degree \(n\) over \(\mathbb{F}_2\).</p>
<p>Any other polynomial \(h(x)\) over \(\mathbb{F}_2\) can be decomposed as:</p>
<p>$$ h(x) = q(x) P(x) + r(x), $$</p>
<p>where \(q(x)\) is the <em>quotient</em> polynomial, and \(r(x)\) is the <em>remainder</em> polynomial with degree less than \(n\).</p>
<p>We say that \(r(x)\) is the <em>modular reduction</em> of \(h(x)\) by \(P(x)\)</p>
<p>$$ r(x) = h(x) \mid {P(x)}. $$</p>
<h1 class="doxsection"><a class="anchor" id="the-polynomial-fxnf"></a>
The Polynomial \(x^N\)</h1>
<p>The simplest, single-term polynomial \(h(x) = x^N\) is of particular importance, especially for cases where \(N \gg 1\).</p>
<p>This is because some numerical algorithms have a critical iteration step that can formally be written as:</p>
<p>$$ \mathbf{v} \gets M \cdot \mathbf{v}, $$</p>
<p>where \(\mathbf{v}\) is a bit-vector bucket of \(n\) bits and \(M\) is an \(n \times n\) bit-matrix.</p>
<p>For example, many well-known random number generators can be cast into this form, where a <em>state vector</em> \(\mathbf{v}\) is advanced at each step before it is reduced to the following random number. We note in passing that the generator is unlikely to be coded as matrix-vector multiply in GF(2) &mdash; \(M\) It is typically rather sparse and special so that the iteration can be carried out much more efficiently by other means. Nevertheless, the mathematical analysis of the generator will depend on the structure of \(M\).</p>
<p>Now you want to jump very far ahead in a random number stream. This lets one start a parallel thread of computation using the same set of random numbers but so far ahead that there is no danger of overlaps. To jump \(N\) steps ahead where \(N \gg 1\) we need to compute</p>
<p>$$ M^N \cdot \mathbf{v}. $$</p>
<p>Even if \(M\) is sparse and special; there usually is no easy way to compute \(M^N\).</p>
<p>But suppose that \(P(x)\) is the known degree \(n\) characteristic polynomial for \(M\) then the <a href="https://en.wikipedia.org/wiki/Cayleyâ€“Hamilton_theorem">Cayley Hamilton theorem</a> tells us that:</p>
<p>$$ P(M) = 0. $$</p>
<p>We can use that as follows &mdash; first, express \(x^N\) as</p>
<p>$$ x^N = q(x)P(x) + r(x), $$</p>
<p>then using Cayley Hamilton we get</p>
<p>$$ M^N = q(M)P(M) + r(M) = r(M). $$</p>
<p>So we can replace \(M^N\) by \(r(M)\) where the degree of \(r\) is less than \(n\) and typically \(N \gg n\).</p>
<p>Thus, once we know \(r(x) = x^N \mid P(x)\), we can jump \(N\) steps ahead in the algorithm by computing the inexpensive polynomial sum \(r(M)\).</p>
<p>For more details see <a href="https://www.iro.umontreal.ca/~lecuyer/myftp/papers/jumpmt.pdf">this paper</a>.</p>
<h1 class="doxsection"><a class="anchor" id="an-iterative-technique"></a>
An Iterative Technique</h1>
<p>We will describe an iterative technique to compute \(x^N \mid P(x)\) for arbitrary non-negative integers \(N\).</p>
<p>Suppose \(P(x)\) has degree \(n\) so there is a polynomial \(p(x)\) of degree less than \(n\) such that</p>
<p>$$ P(x) = p(x) + x^n = p_0 + p_1 x + \cdots + p_{n-1} x^{n-1} + x^n. $$</p>
<p>Then \(p(x)\) can be represented as the vector of its coefficients:</p>
<p>$$ p(x) \sim \mathbf{p} = \lbrack p_0 p_1 \ldots p_{n-1} \rbrack . $$</p>
<p>There are three cases to consider as we compute \(x^N \mid P(x)\).</p>
<h2 class="doxsection"><a class="anchor" id="case-fn--nf"></a>
Case \(N &lt; n\)</h2>
<p>If \(N &lt; n\) then \(P(x)\) does not divide \(x^N\) so</p>
<p>$$ x^N \mid P(x) = x^N. $$</p>
<p>Defining \(\mathbf{u}_N\) as the <em>unit</em> bit-vector of size \(n\), which is all zeros except for a one in the \(N^{\mathrm{th}}\) slot, we can write:</p>
<p>$$ x^N \mid P(x) \sim \mathbf{u}_N \text{ if } N &lt; n. $$</p>
<h2 class="doxsection"><a class="anchor" id="case-fn--nf-1"></a>
Case \(N = n\)</h2>
<p>In this case \(P(x) = p(x) + x^N\) so \(x^N = P(x) - p(x)\).</p>
<p>Therefore</p>
<p>$$ x^N \mid P(x) = -p(x). $$</p>
<p>In \(\mathbb{F}_2\) we can ignore that minus sign and write</p>
<p>$$ x^N \mid P(x) \sim \mathbf{p} \text{ if } N = n. $$</p>
<h2 class="doxsection"><a class="anchor" id="case-fn--nf-2"></a>
Case \(N &gt; n\)</h2>
<p>It remains to determine \(x^N \mid P(x)\) for \(N &gt; n\).</p>
<p>Now <em>any</em> polynomial \(h(x)\) over \(\mathbb{F}_2\) can be written as some multiple of \(P(x)\) plus a remainder term:</p>
<p>$$ h(x) = q(x) P(x) + r(x) $$</p>
<p>where the <em>quotient</em> \(q(x)\) and <em>remainder</em> \(r(x)\) are polynomials over \(\mathbb{F}_2\) and the degree of \(r(x)\) is strictly less than \(n\).</p>
<p>$$ r(x) \equiv h(x) \mid P(x) $$</p>
<p>Suppose we already know the explicit form for \(r(x) = h(x) \mid P(x)\)</p>
<p>$$ r(x) = r_0 + r_1 x + \cdots + r_{n-2} x^{n-2} + r_{n-1} x^{n-1}. $$</p>
<p>That is, we know the elements in the bit-vector of coefficients for \(r(x)\)</p>
<p>$$ r(x) \sim \mathbf{r} = \lbrack r_0 r_1 \ldots r_{n-1} \rbrack. $$</p>
<p>Now</p>
<p>$$ x\,h(x) = x\,q(x) P(x) + x\,r(x) \implies x\,h(x) \mid P(x) = x\,r(x) \mid P(x). $$</p>
<p>Thus</p>
<p>$$ x\,h(x) \mid P(x) = \left(r_0 x + r_1 x^2 + \cdots + r_{n-2} x^{n-1}\right) \mid P(x) + r_{n-1} x^n \mid P(x). $$</p>
<p>Using our two known cases for \(N &lt; n\) and \(N = n\) we get</p>
<p>$$ x\,h(x) \mid P(x) \sim \lbrack 0 r_0 \ldots r_{n-2} \rbrack + r_{n-1} \mathbf{p}. $$</p>
<p>Thus if we know that \(h(x) \mid P(x) \sim \mathbf{r}\) then</p>
<p>$$ x\,h(x) \mid P(x) \sim (\mathbf{r} \gg 1 ) \; \wedge \; r_{n-1} \mathbf{p}. $$</p>
<p>Here \(\mathbf{r} \gg 1\) means we shift \(\mathbf{r}\) one place to the right and introduce a zero on the left.</p>
<h2 class="doxsection"><a class="anchor" id="summary"></a>
Summary</h2>
<p>Using the notation</p>
<p>$$ x^N \mid P(x) = r^N(x) \sim \mathbf{r}^N, $$</p>
<p>where \(\mathbf{r}^N\) is a bit-vector of size \(n\):</p>
<p>$$ \mathbf{r}^N = \lbrack r^N_0 r^N_1 \ldots r^N_{n-1} \rbrack, $$</p>
<p>we can compute \(\mathbf{r}^N\) directly for small values of \(N\) and iteratively for larger values of \(N\):</p>
<p>$$ \mathbf{r}^N = \begin{cases} \mathbf{u}_N, &amp; N &lt; n \\[.5em] \mathbf{p}, &amp; N = n \\[.5em] \left(\mathbf{r}^{N-1} \gg 1 \right) \; \wedge \; r_{n-1}^{N-1} \, \mathbf{p} &amp; N &gt; n \end{cases} $$</p>
<h1 class="doxsection"><a class="anchor" id="a-multiply--square-technique"></a>
A Multiply &amp; Square Technique</h1>
<p>For cases of practical interest where \(N \gg 1\), the iterative scheme outlined above is much too slow.</p>
<p>We can speed it up considerably by using a "multiply &amp; square" approach &ndash; there are variations on the theme but observe that we can always write:</p>
<p>$$ x^N = \begin{cases} x \, \left( x^{\frac{N-1}{2}} \right)^2, &amp; N \text{ odd} \\[.5em] \left( x^{\frac{N}{2}} \right)^2 &amp; N \text{ even} \end{cases} $$</p>
<p>In our case, we want to compute \(x^N \mid P(x)\) as opposed to just computing the value of \(x^N\) but we can still use a fast <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">exponentiation technique</a>.</p>
<p>If \(g\) and \(h\) are polynomials over \(\mathbb{F}_2\) with the remainders on division by \(P(x)\) given by \(r_g\) and \(r_h\) respectively:</p>
<p>$$ \begin{align} r_g &amp;= g(x) \mid P(x), \\ r_h &amp;= h(x) \mid P(x) \end{align} $$</p>
<p>then it is easily verified that</p>
<p>$$ g(x) h(x) \mid P(x) = r_g(x) r_h(x) \mid P(x). $$</p>
<p>So while the polynomial product \(g h\) may have a very high degree, we can instead work with the much remainder product \(r_g r_h\) whose degree is at most \(2n -2\).</p>
<p>In our case, suppose we already know \(r(x) = x^k \mid P(x)\) for some power \(k\) i.e. we know the coefficients \(\mathbf{r}\) of the polynomial \(r(x)\):</p>
<p>$$ r(x) \sim \mathbf{r} = [r_0 r_1 \ldots r_{n-1}]. $$</p>
<p>To get to \(x^N \mid P(x)\) from there, the multiply and square algorithm requires two procedures:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Step  </th><th class="markdownTableHeadCenter">Assuming the degree of \(r(x) &lt; n\) and \(r(x) \sim \mathbf{r}\).  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><span class="tt">MultiplyStep</span>  </td><td class="markdownTableBodyCenter">Computes \(\mathbf{r} \gets x r(x) \mid P(x)\)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><span class="tt">SquareStep</span>  </td><td class="markdownTableBodyCenter">Computes \(\mathbf{r} \gets r(x)^2 \mid P(x)\)  </td></tr>
</table>
<p>With those in place we can proceed as shown in the following sketch:</p>
<div class="pseudocode"><ol type="1">
<li><em>Input:</em> A coefficient bit-vector \(\mathbf{p}\) of size \(n\) where \(P(x) = x^n + p(x)\)</li>
<li><em>Input:</em> An integer \(N\) where we wish to compute \(x^N \mid P(x)\).</li>
<li>Initialise a result bit-vector \(\mathbf{r}\) of size \(n\) to \(\mathbf{0}\).</li>
<li>Set \(r_1 = 1\).</li>
<li>While \(N &gt; 0\) do:<ol type="a">
<li><b>if</b> \(N\) is odd, perform a <span class="tt">MultiplyStep</span> on \(\mathbf{r}\).</li>
<li>Perform a <span class="tt">SquareStep</span> on \(\mathbf{r}\).</li>
<li>\(N \gets N/2\).</li>
</ol>
</li>
<li>When the loop ends, \(\mathbf{r}\) contains the coefficients of \(x^N \mid P(x)\). </li>
</ol>
</div><p>The full code handles the decomposition of \(P(x)\) into the \(x^n + p(x)\) and manages edge cases such as \(P(x) = 1\). It also handles the trivial cases where \(N \le n\). For larger values of \(N\) it uses its binary representation in the main loop. Nevertheless, the sketch shows the importance of the two sub-procedures, <span class="tt">MultiplyStep</span> and <span class="tt">SquareStep</span> which we discuss next.</p>
<h2 class="doxsection"><a class="anchor" id="the-multiply-step"></a>
The Multiply Step</h2>
<p>If \(q(x)\) is a polynomial of degree less than \(n\) so that</p>
<p>$$ q(x) \mid P(x) = q(x), $$</p>
<p>then the following procedure performs the step</p>
<p>$$ q(x) \gets x q(x) \mid P(x), $$</p>
<div class="pseudocode"><ol type="1">
<li><em>Input:</em> A coefficient bit-vector \(\mathbf{p}\) of size \(n\) where \(P(x) = x^n + p(x)\).</li>
<li><em>Input:</em> A coefficient bit-vector \(\mathbf{q}\) of size \(n\) where \(q(x) \sim \mathbf{q}\).<ol type="a">
<li>\(tmp \gets q_{n-1}\)</li>
<li>\(\mathbf{q} \gets \mathbf{q} \gg 1\)</li>
<li><b>if</b> \(tmp\) <b>then</b> \(\mathbf{q} \gets \mathbf{q} \wedge \mathbf{p}\)</li>
</ol>
</li>
<li>On return \(\mathbf{q}\) has the coefficients for \(x q(x) \mid P(x)\). </li>
</ol>
</div><h2 class="doxsection"><a class="anchor" id="the-square-step"></a>
The Square Step</h2>
<p>In GF(2) if a polynomial \(q(x)\) is represented by the coefficient bit-vector \(\mathbf{q} = [q_0, q_1, q_2, \ldots, q_{n-1}]\):</p>
<p>$$ q(x) = q_0 + q_1 x + q_2 x^2 + \ldots q_{n-1} x^{n-1}, $$</p>
<p>one can easily show that</p>
<p>$$ q(x)^2 = q_0 + q_1 x^2 + q_2 x^4 + \cdots + q_{n-1} x^{2n-2}, $$</p>
<p>so \(s(x) = q(x)^2\) is represented by <em>riffling</em> the bit-vector \(\mathbf{q}\)</p>
<p>$$ s(x) = q(x)^2 \sim \mathbf{s} = [q_0, 0, q_1, 0, q_2, \ldots, 0, q_{n-1}], $$</p>
<p>i.e. the bit-vector we get by interspersing the elements of \(\mathbf{q}\) with zeros.</p>
<p>Riffling can be done very efficiently word by word. The <span class="tt">gf2::BitVec::riffle_into</span> method takes a bit-vector \(\mathbf{q}\) and fills a destination bit-vector \(\mathbf{s}\) with a <em>riffled</em> version of \(\mathbf{q}\).</p>
<p>The <span class="tt"><a class="el" href="classgf2_1_1BitVec.html#aad2cdea9a00459c91c7183b3ac190712" title="Views a bit-store as two parts containing the elements [0, at) and [at, size()) respectively.">gf2::BitVec::split_at</a></span> method takes a bit-vector \(\mathbf{s}\), a number \(n\), and then fills two other bit-vectors \(\mathbf{l}\) and \(\mathbf{h}\) where \(\mathbf{l}\) gets the first \(n\) elements in \(\mathbf{s}\) and \(\mathbf{h}\) gets the rest.</p>
<p>$$ \begin{align} \mathbf{l} &amp;= [s_0, s_1, \ldots, s_{n-1}], \\ \mathbf{h} &amp;= [s_n, s_{n+1}, \dots]. \end{align} $$</p>
<p>In polynomial terms this is equivalent to the decomposition:</p>
<p>$$ s(x) = l(x) + x^n \, h(x), $$</p>
<p>where the degree of \(l(x)\) is less than \(n\).</p>
<p>Given that \(s(x) = q(x)^2\) we have</p>
<p>$$ q(x)^2 \mid P(x) = s(x) \mid P(x) = l(x) \mid P(x) + x^n h(x) \mid P(x), $$</p>
<p>and because the degree of \(l(x)\) is less than \(n\) we have</p>
<p>$$ q(x)^2 \mid P(x) = l(x) + x^n h(x) \mid P(x). $$</p>
<p>Writing \(h(x)\) as</p>
<p>$$ h(x) = \sum_{i=0}^{n-1} h_i x^i $$</p>
<p>it follows that</p>
<p>$$ q(x)^2 \mid P(x) = l(x) + \sum_{i=0}^{n} h_i x^{n + i} \mid P(x). $$</p>
<p>Define the bit-vectors \(\mathbf{x}^i\) by the equivalence:</p>
<p>$$ \mathbf{x}^i \sim x^{n+i} \mid P(x) \text{ for } i = 0, \ldots, n-1. $$</p>
<p>Now we know that \(x^n \mid P(x) = p(x)\) so</p>
<p>$$ \mathbf{x}^0 = \mathbf{p}. $$</p>
<p>With that starting point, we can easily fill in bit-vectors \(\mathbf{x}^i\) for \(i = 1, \ldots, n-1\) by using the <span class="tt">MultiplyStep</span> algorithm.</p>
<p>The squaring step for a polynomial \(q(x)\) looks like the following:</p>
<div class="pseudocode"><ol type="1">
<li><em>Input:</em> A coefficient bit-vector \(\mathbf{p}\) of size \(n\) where \(P(x) = x^n + p(x)\).</li>
<li><em>Input:</em> A coefficient bit-vector \(\mathbf{q}\) of size \(n\) where \(q(x) \sim \mathbf{q}\).</li>
<li><em>Precomputed:</em> Bit-vectors \(\mathbf{x}^i\), where \(\mathbf{x}^i \sim x^{n+i} \mid P(x)\).</li>
<li><em>Workspace:</em> Bit-vector \(\mathbf{s}\) of size \(2n\), bit-vectors \(\mathbf{l}, \mathbf{h}\) of size \(n\).<ol type="a">
<li>Riffle \(\mathbf{q}\) into \(\mathbf{s}\).</li>
<li>Split \(\mathbf{s}\) at \(n\) into \(\mathbf{l}\) and \(\mathbf{h}\).</li>
<li>\(\mathbf{q} \gets \mathbf{l}\).</li>
<li><b>for</b> \(i \gets 0, n-1\)<ol type="i">
<li><b>if</b> \(h_i\) <b>then</b> \(\mathbf{q} \gets \mathbf{q} \wedge \mathbf{x}^i\)</li>
</ol>
</li>
</ol>
</li>
<li>On return \(\mathbf{q}\) has the coefficients for \(q(x)^2 \mid P(x)\). </li>
</ol>
</div><p>The full code can implement some efficiencies in this algorithm's loop &ndash; for example, at most every second element in \(\mathbf{h}\) is ever set. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.15.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="md_docs_2pages_2Notes_2Introduction.html">Technical Notes</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
