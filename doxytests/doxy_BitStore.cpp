// This file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `BitStore.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-22 18:02:34

#include "../include/gf2/BitStore.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    // Trace the source for the tests.
    auto header_file = "BitStore.h";
    std::size_t test_count = 67;
    std::println(stderr, "Running {} tests extracted from: `{}`", test_count, header_file);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for `{}`:", doxy::max_fails, header_file);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    // Run the tests ...
    header_line = 155;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(get(v, 0), false);
        set(v, 0);
        assert_eq(get(v, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 177;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        ref(v, 2) = true;
        assert(to_string(v) == "0010000000");
        auto w = BitVector<>::ones(10);
        ref(v, 3) = get(w, 3);
        assert(to_string(v) == "0011000000");
        ref(v, 4) |= get(w, 4);
        assert(to_string(v) == "0011100000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 199;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(front(v), true);
        set_all(v, false);
        assert_eq(front(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 217;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(10);
        assert_eq(back(v), true);
        set_all(v, false);
        assert_eq(back(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 236;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(get(v, 0), false);
        set(v, 0);
        assert_eq(get(v, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 258;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        flip(v, 0);
        assert_eq(to_string(v), "0111111111");
        flip(v, 1);
        assert_eq(to_string(v), "0011111111");
        flip(v, 9);
        assert_eq(to_string(v), "0011111110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 282;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::zeros(10);
        set(v, 0);
        assert_eq(to_string(v), "1000000000");
        swap(v, 0, 1);
        assert_eq(to_string(v), "0100000000");
        swap(v, 0, 1);
        assert_eq(to_string(v), "1000000000");
        swap(v, 0, 9);
        assert_eq(to_string(v), "0000000001");
        swap(v, 0, 9);
        assert_eq(to_string(v), "1000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 328;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v;
        assert_eq(is_empty(v), true);
        BitVector u{10};
        assert_eq(is_empty(u), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 345;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(any(v), false);
        set(v, 0);
        assert_eq(any(v), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 364;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{3};
        assert_eq(all(v), false);
        set(v, 0);
        set(v, 1);
        set(v, 2);
        assert_eq(all(v), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 399;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(none(v), true);
        set(v,0);
        assert_eq(none(v), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 420;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        set_all(v);
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 437;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        flip_all(v);
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 462;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector<u8> v{16};
        u16 src = 0b1010101010101010;
        copy(src, v);
        assert_eq(to_string(v), "0101010101010101");
        BitVector<u32> w{16};
        copy(src, w);
        assert_eq(to_string(w), "0101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 502;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u64>::ones(10);
        assert_eq(to_string(v), "1111111111");
        copy(BitVector<u8>::alternating(10), v);
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 574;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::bitset<10> src{0b1010101010};
        BitVector v{10};
        copy(src, v);
        assert_eq(to_string(v), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 596;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        copy(v, [](usize i) { return i % 2 == 0; });
        assert_eq(v.size(), 10);
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 621;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector u{10}, v{10};
        u64 seed = 1234567890;
        fill_random(u, 0.5, seed);
        fill_random(v, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 665;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(count_ones(v), 0);
        set(v, 0);
        assert_eq(count_ones(v), 1);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 682;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(count_zeros(v), 10);
        set(v, 0);
        assert_eq(count_zeros(v), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 697;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{37};
        assert_eq(leading_zeros(v), 37);
        set(v, 27);
        assert_eq(leading_zeros(v), 27);
        auto w = BitVector<u8>::ones(10);
        assert_eq(leading_zeros(w), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 720;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(27);
        assert_eq(trailing_zeros(v), 27);
        set(v, 0);
        assert_eq(trailing_zeros(v), 26);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 755;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(first_set(v) == std::optional<usize>{});
        set(v, 2);
        assert(first_set(v) == std::optional<usize>{2});
        set(v, 2, false);
        assert(first_set(v) == std::optional<usize>{});
        set(v, 27);
        assert(first_set(v) == std::optional<usize>{27});
        BitVector empty;
        assert(first_set(empty) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 782;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(last_set(v) == std::optional<usize>{});
        set(v, 2);
        assert(last_set(v) == std::optional<usize>{2});
        set(v, 27);
        assert(last_set(v) == std::optional<usize>{27});
        BitVector empty;
        assert(last_set(empty) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 807;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(next_set(v,0) == std::optional<usize>{});
        set(v,2);
        set(v,27);
        assert(next_set(v,0) == std::optional<usize>{2});
        assert(next_set(v,2) == std::optional<usize>{27});
        assert(next_set(v,27) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 845;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(37);
        assert(previous_set(v,36) == std::optional<usize>{});
        set(v,2);
        set(v,27);
        assert(previous_set(v,36) == std::optional<usize>{27});
        assert(previous_set(v,27) == std::optional<usize>{2});
        assert(previous_set(v,2)  == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 888;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(first_unset(v) == std::optional<usize>{});
        set(v,2,false);
        assert(first_unset(v) == std::optional<usize>{2});
        set(v,2);
        assert(first_unset(v) == std::optional<usize>{});
        set(v,27,false);
        assert(first_unset(v) == std::optional<usize>{27});
        BitVector empty;
        assert(empty.first_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 921;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(last_unset(v) == std::optional<usize>{});
        set(v,2, false);
        assert(last_unset(v) == std::optional<usize>{2});
        set(v,2);
        assert(last_unset(v) == std::optional<usize>{});
        set(v,27, false);
        assert(last_unset(v) == std::optional<usize>{27});
        BitVector empty;
        assert(empty.last_unset() == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 954;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.next_unset(0) == std::optional<usize>{});
        set(v,2, false);
        set(v,27, false);
        assert(v.next_unset(0) == std::optional<usize>{2});
        assert(v.next_unset(2) == std::optional<usize>{27});
        assert(v.next_unset(27) == std::optional<usize>{});
        BitVector empty;
        assert(empty.next_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 999;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(37);
        assert(v.previous_unset(0) == std::optional<usize>{});
        set(v,2, false);
        set(v,27, false);
        assert(v.previous_unset(36) == std::optional<usize>{27});
        assert(v.previous_unset(27) == std::optional<usize>{2});
        assert(v.previous_unset(2) == std::optional<usize>{});
        BitVector empty;
        assert(empty.previous_unset(0) == std::optional<usize>{});
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1054;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(10);
        for (auto&& bit : bits(u)) assert_eq(bit, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1072;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::zeros(10);
        for (auto&& bit : bits(v)) bit = true;
        assert_eq(to_string(v), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1088;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto indices = std::ranges::to<std::vector>(set_bits(v));
        assert_eq(indices, (std::vector<usize>{0, 2, 4, 6, 8}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1105;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto indices = std::ranges::to<std::vector>(unset_bits(v));
        assert_eq(indices, (std::vector<usize>{1, 3, 5, 7, 9}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1128;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        assert_eq(to_string(v), "1111111111");
        auto words = std::ranges::to<std::vector>(store_words(v));
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1145;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto words = to_words(v);
        assert_eq(words, (std::vector<u8>{0b1111'1111, 0b0000'0011}));
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1168;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        const auto v = BitVector<>::alternating(10);
        auto s = span(v, 1, 5);
        assert_eq(to_string(s), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1205;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        const auto v = BitVector<>::alternating(10);
        auto s = span(v, 1, 5);
        assert_eq(to_string(s), "0101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1242;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto s = sub(v,1,5);
        assert_eq(to_string(s), "0101");
        s.set_all();
        assert_eq(to_string(s), "1111");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1272;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        BitVector left, right;
        split(v, 5, left, right);
        assert_eq(to_string(left), "10101");
        assert_eq(to_string(right), "01010");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1301;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        auto [left, right] = split(v, 5);
        assert_eq(to_string(left), "10101");
        assert_eq(to_string(right), "01010");
        assert_eq(to_string(v), "1010101010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1322;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitVector<u16>::zeros(12);
        auto rhs = BitVector<u8>::ones(12);
        auto v = join(lhs, rhs);
        assert_eq(to_string(v), "000000000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1354;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        BitVector<u8> dst;
        riffle(v, dst);
        assert_eq(to_string(dst), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1395;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(10);
        auto dst = riffle(v);
        assert_eq(to_string(dst), "1010101010101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1422;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(to_binary_string(v), "0000000000");
        set(v, 0);
        assert_eq(to_binary_string(v), "1000000000");
        assert_eq(to_binary_string(v, ",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1473;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v{10};
        assert_eq(to_string(v), "0000000000");
        set(v, 0);
        assert_eq(to_string(v), "1000000000");
        assert_eq(to_string(v, ",", "[", "]"), "[1,0,0,0,0,0,0,0,0,0]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1492;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::alternating(10);
        assert_eq(to_pretty_string(v), "[1,0,1,0,1,0,1,0,1,0]");
        BitVector empty;
        assert_eq(to_pretty_string(empty), "[]");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1523;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitVector v0;
        assert_eq(to_hex_string(v0), "");
        auto v1 = BitVector<>::ones(4);
        assert_eq(to_hex_string(v1), "F");
        auto v2 = BitVector<>::ones(5);
        assert_eq(to_hex_string(v2), "F1.2");
        auto v3 = BitVector<>::alternating(8);
        assert_eq(to_binary_string(v3), "10101010");
        assert_eq(to_hex_string(v3), "AA");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1618;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<u8>::ones(55);
        auto v = BitVector<u8>::ones(55);
        assert(u == v);
        v.set(23, false);
        assert(u != v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1649;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        v <<= 8;
        assert_eq(to_string(v), "11111111111100000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1710;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        v >>= 8;
        assert_eq(to_string(v), "00000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1772;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        auto w = v << 8;
        assert_eq(to_string(w), "11111111111100000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1793;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::ones(20);
        auto w = v >> 8;
        assert_eq(to_string(w), "00000000111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1815;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 ^= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1833;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 &= ~v1;
        assert_eq(to_string(v1), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1851;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 |= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1871;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<u8>::alternating(10);
        assert_eq(to_string(v), "1010101010");
        auto w = ~v;
        assert_eq(to_string(w), "0101010101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1890;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 ^ v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1910;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 & v2;
        assert_eq(to_string(v3), "0000000000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1930;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 | v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1956;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 += ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1975;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        v1 -= ~v1;
        assert_eq(to_string(v1), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1998;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 + v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2020;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        auto v3 = v1 - v2;
        assert_eq(to_string(v3), "1111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2048;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        assert_eq(dot(v1, v1), true);
        assert_eq(dot(v1, v2), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2076;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v1 = BitVector<u8>::alternating(10);
        auto v2 = ~v1;
        assert_eq(v1*v1, true);
        assert_eq(v1*v2, false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2099;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitVector<>::ones(3);
        auto rhs = BitVector<>::ones(2);
        auto result = convolve(lhs, rhs);
        assert_eq(to_string(result), "1001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    // Print a summary of the tests results.
    if (fails == 0) {
        std::println(stderr, "[{}] All {} tests PASSED", header_file, test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Test FAIL summary for `{}`: Ran {} of a possible {} tests, PASSED: {}, FAILED: {}", header_file, test, test_count, test - fails, fails);
        std::print(stderr, "--------------------------------------------------------------------------------------");
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}