// This file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `BitMatrix.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2026-01-24 15:10:18

#include "../include/gf2/BitMatrix.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <gf2/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    // Trace the source for the tests.
    auto header_file = "BitMatrix.h";
    std::size_t test_count = 113;
    std::println(stderr, "Running {} tests extracted from: `{}`", test_count, header_file);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for `{}`:", doxy::max_fails, header_file);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    // Run the tests ...
    header_line = 50;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.to_compact_binary_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 61;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m{3};
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 74;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m{3, 4};
        assert_eq(m.to_compact_binary_string(), "0000 0000 0000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 87;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto rows = std::vector{BitVector<>::zeros(3), BitVector<>::ones(3)};
        BitMatrix m{rows};
        assert_eq(m.to_compact_binary_string(), "000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 104;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto rows = std::vector{BitVector<>::zeros(3), BitVector<>::ones(3)};
        BitMatrix m{std::move(rows)};
        assert_eq(m.to_compact_binary_string(), "000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 120;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 4);
        assert_eq(m.to_compact_binary_string(), "0000 0000 0000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 129;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3);
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 138;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 4);
        assert_eq(m.to_compact_binary_string(), "1111 1111 1111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 150;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3);
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 159;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::alternating(3, 4);
        assert_eq(m.to_compact_binary_string(), "1010 0101 1010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 173;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::alternating(3);
        assert_eq(m.to_compact_binary_string(), "101 010 101");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 182;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::from_string("101").value();
        auto v = BitVector<>::from_string("110").value();
        auto m = BitMatrix<>::from_outer_product(u, v);
        assert_eq(m.to_compact_binary_string(), "110 000 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 202;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitVector<>::from_string("101").value();
        auto v = BitVector<>::from_string("110").value();
        auto m = BitMatrix<>::from_outer_sum(u, v);
        assert_eq(m.to_compact_binary_string(), "001 110 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 222;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::from(3, 2, [](usize i, usize) { return i % 2 == 0; });
        assert_eq(m.to_compact_binary_string(), "11 00 11");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 255;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::random(3, 2, 0.5, seed);
        auto v = BitMatrix<>::random(3, 2, 0.5, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 305;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::seeded_random(3, 2, seed);
        auto v = BitMatrix<>::seeded_random(3, 2, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 324;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::uint64_t seed = 1234567890;
        auto u = BitMatrix<>::seeded_random(3, seed);
        auto v = BitMatrix<>::seeded_random(3, seed);
        assert(u == v);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 340;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitMatrix<>::biased_random(10, 7, 0.3);
        auto v = BitMatrix<>::biased_random(10, 7, 0.3);
        assert_eq(u.size(), v.size());
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 354;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto u = BitMatrix<>::biased_random(10, 0.3);
        assert_eq(u.size(), 100);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 367;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 376;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 392;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto top_row = BitVector<>::ones(5);
        auto m = BitMatrix<>::companion(top_row);
        assert_eq(m.to_compact_binary_string(), "11111 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 413;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::left_shift(5, 2);
        auto v = BitVector<>::ones(5);
        assert_eq(dot(m, v).to_string(), "11100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 429;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::right_shift(5, 2);
        auto v = BitVector<>::ones(5);
        assert_eq(dot(m, v).to_string(), "00111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 445;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::left_rotation(5, 2);
        auto v = BitVector<>::from_binary_string("11100").value();
        assert_eq(dot(m, v).to_string(), "00111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 464;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::right_rotation(5, 2);
        auto v = BitVector<>::from_binary_string("11100").value();
        assert_eq(dot(m, v).to_string(), "10011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 485;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(15);
        auto m1 = BitMatrix<>::from_row_store(v, 3).value();
        assert_eq(m1.to_compact_binary_string(), "11111 11111 11111");
        auto m2 = BitMatrix<>::from_row_store(v, 5).value();
        assert_eq(m2.to_compact_binary_string(), "111 111 111 111 111");
        auto m3 = BitMatrix<>::from_row_store(v, 15).value();
        assert_eq(m3.to_compact_binary_string(), "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 522;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto v = BitVector<>::ones(15);
        auto m1 = BitMatrix<>::from_col_store(v, 3).value();
        assert_eq(m1.to_compact_binary_string(), "111 111 111 111 111");
        auto m2 = BitMatrix<>::from_col_store(v, 5).value();
        assert_eq(m2.to_compact_binary_string(), "11111 11111 11111");
        auto m3 = BitMatrix<>::from_col_store(v, 15).value();
        assert_eq(m3.to_compact_binary_string(), "111111111111111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 571;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m1 = BitMatrix<>::from_string("111   111\n111").value();
        assert_eq(m1.to_compact_binary_string(), "111 111 111");
        auto m2 = BitMatrix<>::from_string("0XAA; 0b1111_0000").value();
        assert_eq(m2.to_compact_binary_string(), "10101010 11110000");
        auto m3 = BitMatrix<>::from_string("0x7.8 000").value();
        assert_eq(m3.to_compact_binary_string(), "111 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 644;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.is_square(), false);
        m.resize(3, 3);
        assert_eq(m.is_square(), true);
        m.resize(3, 4);
        assert_eq(m.is_square(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 657;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        assert_eq(m.is_zero(), false);
        m.resize(3, 3);
        assert_eq(m.is_zero(), true);
        m.resize(3, 4);
        assert_eq(m.is_zero(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 670;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.is_identity(), true);
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 688;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.is_symmetric(), true);
        m.row(0).set_all();
        assert_eq(m.is_symmetric(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 711;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.count_ones(), 0);
        m.set_all();
        assert_eq(m.count_ones(), 9);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 726;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.count_zeros(), 6);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 737;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.count_ones_on_diagonal(), 3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 756;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m1 = BitMatrix<>::identity(3);
        assert_eq(m1.trace(), true);
        auto m2 = BitMatrix<>::zero(4);
        assert_eq(m2.trace(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 773;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.any(), false);
        m.set(0, 0);
        assert_eq(m.any(), true);
        m.clear();
        assert_eq(m.any(), false);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 792;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.all(), false);
        m.set_all();
        assert_eq(m.all(), true);
        m.clear();
        assert_eq(m.all(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 811;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.none(), true);
        m.set_all();
        assert_eq(m.none(), false);
        m.clear();
        assert_eq(m.none(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 834;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m.get(0, 0), false);
        m.set(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 851;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m(0, 0), false);
        m.set(0, 0);
        assert_eq(m(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 869;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 885;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        assert_eq(m(0,0), false);
        m(0,0) = true;
        assert_eq(m(0,0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 902;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip(0, 0);
        assert_eq(m.get(0, 0), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 922;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.row(0).to_binary_string(), "100");
        assert_eq(m.row(1).to_binary_string(), "010");
        assert_eq(m.row(2).to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 938;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.row(0).set(1);
        assert_eq(m.row(0).to_binary_string(), "110");
        assert_eq(m.row(1).to_binary_string(), "010");
        assert_eq(m.row(2).to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 955;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m[0].to_binary_string(), "100");
        assert_eq(m[1].to_binary_string(), "010");
        assert_eq(m[2].to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 971;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m[0].set(1);
        assert_eq(m[0].to_binary_string(), "110");
        assert_eq(m[1].to_binary_string(), "010");
        assert_eq(m[2].to_binary_string(), "001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 994;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto col = m.col(1);
        assert_eq(col.to_string(), "010");
        col.set(0);
        col.set(2);
        assert_eq(col.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1021;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set_all();
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1033;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip_all();
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1051;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.set_diagonal();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1066;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.flip_diagonal();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1083;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.set_super_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "01000 00100 00010 00001 00000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1100;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.flip_super_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "01000 00100 00010 00001 00000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1117;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.set_sub_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "00000 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1134;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(5);
        m.flip_sub_diagonal(1);
        assert_eq(m.to_compact_binary_string(), "00000 10000 01000 00100 00010");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1156;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m;
        m.resize(10, 10);
        assert_eq(m.rows(), 10);
        assert_eq(m.cols(), 10);
        m.resize(3, 7);
        assert_eq(m.rows(), 3);
        assert_eq(m.cols(), 7);
        m.resize(0, 10);
        assert_eq(m.rows(), 0);
        assert_eq(m.cols(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1183;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.clear();
        assert_eq(m.rows(), 0);
        assert_eq(m.cols(), 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1196;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::from_string("111 111 111 111").value();
        m.make_square(3);
        assert_eq(m.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1213;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto row = BitVector<>::ones(3);
        m.append_row(row);
        assert_eq(m.to_compact_binary_string(), "000 000 000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1236;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.append_row(BitVector<>::ones(3));
        assert_eq(m.to_compact_binary_string(), "000 000 000 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1255;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto src = BitMatrix<>::ones(3, 3);
        m.append_rows(src);
        assert_eq(m.to_compact_binary_string(), "000 000 000 111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1276;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.append_rows(BitMatrix<>::ones(3, 3));
        assert_eq(m.to_compact_binary_string(), "000 000 000 111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1294;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto col = BitVector<>::ones(3);
        m.append_col(col);
        assert_eq(m.to_compact_binary_string(), "0001 0001 0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1314;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        auto src = BitMatrix<>::ones(3, 2);
        m.append_cols(src);
        assert_eq(m.to_compact_binary_string(), "00011 00011 00011");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1333;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto row = m.remove_row();
        assert_eq(row->to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1350;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto popped = m.remove_rows(2);
        assert_eq(popped->to_compact_binary_string(), "111 111");
        assert_eq(m.to_compact_binary_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1369;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto col = m.remove_col();
        assert_eq(col->to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "11 11 11");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1393;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(5);
        auto sub1 = m.sub_matrix(1, 4, 1, 4);
        assert_eq(sub1.to_compact_binary_string(), "100 010 001");
        auto sub2 = m.sub_matrix(1, 1, 1, 1);
        assert_eq(sub2.to_compact_binary_string(), "");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1426;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(5);
        m.replace_sub_matrix(1, 1, BitMatrix<>::ones(3, 3));
        assert_eq(m.to_compact_binary_string(), "10000 01110 01110 01110 00001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1446;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.lower();
        assert_eq(sub_m.to_compact_binary_string(), "100 110 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1470;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.upper();
        assert_eq(sub_m.to_compact_binary_string(), "111 011 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1496;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.strictly_lower();
        assert_eq(sub_m.to_compact_binary_string(), "000 100 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1512;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::ones(3, 3);
        auto sub_m = m.strictly_upper();
        assert_eq(sub_m.to_compact_binary_string(), "011 001 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1528;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 3);
        auto sub_m = m.unit_lower();
        assert_eq(sub_m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1544;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 3);
        auto sub_m = m.unit_upper();
        assert_eq(sub_m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1564;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.swap_rows(0, 1);
        assert_eq(m.to_compact_binary_string(), "010 100 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1580;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.swap_cols(0, 1);
        assert_eq(m.to_compact_binary_string(), "010 100 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1596;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.add_identity();
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1615;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zeros(3, 2);
        m.row(0).set_all();
        assert_eq(m.to_compact_binary_string(), "11 00 00");
        auto n = m.transposed();
        assert_eq(n.to_compact_binary_string(), "100 100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1639;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::zero(3);
        m.row(0).set_all();
        assert_eq(m.to_compact_binary_string(), "111 000 000");
        m.transpose();
        assert_eq(m.to_compact_binary_string(), "100 100 100");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1670;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::random(100, 100);
        auto p1 = m.to_the(3);
        auto o1 = m * m * m;
        assert_eq(p1, o1);
        auto p2 = m.to_the(2, true);
        auto o2 = m * o1;
        assert_eq(p2, o2);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1730;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.set(2, 1, false);
        auto has_pivot = m.to_echelon_form();
        assert_eq(has_pivot.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1787;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        m.set(2, 1, false);
        auto pivots = m.to_reduced_echelon_form();
        assert_eq(pivots.to_string(), "111");
        assert_eq(m.to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1820;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        assert_eq(m.inverse().value().to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1852;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::probability_invertible(10);
        assert(abs(p - 0.289) < 1e-3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1882;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::probability_singular(10);
        assert(abs(p - 0.711) < 1e-3);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1895;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto lu = m.LU();
        assert_eq(lu.LU().to_compact_binary_string(), "100 010 001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1909;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::ones(3, 3);
        auto b = BitVector<>::ones(3);
        auto solver = A.solver_for(b);
        assert_eq(solver.rank(), 1);
        assert_eq(solver.free_count(), 2);
        assert_eq(solver.solution_count(), 4);
        assert_eq(solver.is_underdetermined(), true);
        assert_eq(solver.is_consistent(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1928;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto A = BitMatrix<>::identity(3);
        auto b = BitVector<>::ones(3);
        auto x = A.x_for(b).value();
        assert_eq(x.to_string(), "111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1953;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m2 = BitMatrix<>::identity(2);
        assert_eq(m2.characteristic_polynomial().to_string(), "1 + x^2");
        auto m3 = BitMatrix<>::identity(3);
        assert_eq(m3.characteristic_polynomial().to_string(), "1 + x + x^2 + x^3");
        auto m100 = BitMatrix<>::random(100, 100);
        auto p = m100.characteristic_polynomial();
        assert_eq(p(m100).is_zero(), true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 1997;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto top_row = BitVector<>::from_binary_string("101").value();
        assert_eq(BitMatrix<>::companion_matrix_characteristic_polynomial(top_row).to_string(), "1 + x^2 + x^3");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2053;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs ^= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2071;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs &= rhs;
        assert_eq(lhs.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2089;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs |= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2107;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs ^ rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2127;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs & rhs;
        assert_eq(result.to_compact_binary_string(), "000 000 000");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2147;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs | rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2165;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<>::identity(3);
        auto result = ~m;
        assert_eq(result.to_compact_binary_string(), "011 101 110");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2185;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs += rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2199;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        lhs -= rhs;
        assert_eq(lhs.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2213;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs - rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2231;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto lhs = BitMatrix<>::identity(3);
        auto rhs = BitMatrix<>::identity(3);
        rhs.flip_all();
        auto result = lhs + rhs;
        assert_eq(result.to_compact_binary_string(), "111 111 111");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2258;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_binary_string(), "1000\n0100\n0010\n0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2286;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_compact_binary_string(), "1000 0100 0010 0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2297;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(4);
        assert_eq(I.to_string(), "1000\n0100\n0010\n0001");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2310;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto I = BitMatrix<>::identity(3);
        auto bar = "\u2502";
        auto expected = std::format("{0}1 0 0{0}\n{0}0 1 0{0}\n{0}0 0 1{0}", bar);
        assert_eq(I.to_pretty_string(), expected);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2335;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m0;
        assert_eq(m0.to_hex_string(), "");
        auto m1 = BitMatrix<>::zero(4);
        m1.set_all();
        assert_eq(m1.to_hex_string(), "F\nF\nF\nF");
        auto m2 = BitMatrix<>::zero(5);
        m2.flip_all();
        assert_eq(m2.to_hex_string(), "F1.2\nF1.2\nF1.2\nF1.2\nF1.2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2380;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        BitMatrix m0;
        assert_eq(m0.to_compact_hex_string(), "");
        auto m1 = BitMatrix<>::zero(4);
        m1.set_all();
        assert_eq(m1.to_compact_hex_string(), "F F F F");
        auto m2 = BitMatrix<>::zero(5);
        m2.flip_all();
        assert_eq(m2.to_compact_hex_string(), "F1.2 F1.2 F1.2 F1.2 F1.2");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2402;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto p = BitMatrix<>::identity(3);
        auto q = BitMatrix<>::identity(3);
        assert(p == q);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 2770;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        auto m = BitMatrix<u8>::zero(4);
        m.set_all();
        auto ms = std::format("{}", m);
        auto mp = std::format("{:p}", m);
        auto mx = std::format("{:x}", m);
        assert_eq(ms, "1111\n1111\n1111\n1111");
        assert_eq(mp, "\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502\n\u25021 1 1 1\u2502");
        assert_eq(mx, "F\nF\nF\nF");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    // Print a summary of the tests results.
    if (fails == 0) {
        std::println(stderr, "[{}] All {} tests PASSED", header_file, test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Test FAIL summary for `{}`: Ran {} of a possible {} tests, PASSED: {}, FAILED: {}", header_file, test, test_count, test - fails, fails);
        std::print(stderr, "--------------------------------------------------------------------------------------");
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}